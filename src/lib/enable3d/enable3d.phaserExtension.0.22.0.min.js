/*! For license information please see enable3d.phaserExtension.0.22.0.min.js.LICENSE.txt */
!(function (t, e) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = e(require('Phaser'), require('Matter')))
    : 'function' == typeof define && define.amd
    ? define(['Phaser', 'Matter'], e)
    : 'object' == typeof exports
    ? (exports.ENABLE3D = e(require('Phaser'), require('Matter')))
    : (t.ENABLE3D = e(t.Phaser, t.Matter))
})(self, function (t, e) {
  return (() => {
    'use strict'
    var n = {
        650: function (t, e, n) {
          var i =
            (this && this.__spreadArray) ||
            function (t, e) {
              for (var n = 0, i = e.length, r = t.length; n < i; n++, r++) t[r] = e[n]
              return t
            }
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.Events = void 0)
          var r = n(406),
            s = function (t, e, n) {
              void 0 === n && (n = !1), (this.fn = t), (this.context = e), (this.once = n)
            },
            o = function (t, e, n, i, r) {
              if ('function' != typeof n) throw new TypeError('The listener must be a function')
              var o = new s(n, i || t, r)
              return (
                t._events.has(e)
                  ? t._events.get(e).fn
                    ? t._events.set(e, [t._events.get(e), o])
                    : t._events.get(e).push(o)
                  : (t._events.set(e, o), t._eventsCount++),
                t
              )
            },
            a = function (t, e) {
              0 == --t._eventsCount ? (t._events = new Map()) : t._events.delete(e)
            },
            l = (function () {
              function t() {
                ;(this._events = new Map()), (this._eventsCount = 0)
              }
              return (
                Object.defineProperty(t, 'VERSION', {
                  get: function () {
                    return r.VERSION
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                (t.prototype.eventNames = function () {
                  return Array.from(this._events.keys())
                }),
                (t.prototype.listeners = function (t) {
                  var e = this._events.get(t)
                  if (!e) return []
                  if (e.fn) return [e.fn]
                  for (var n = 0, i = e.length, r = new Array(i); n < i; n++) r[n] = e[n].fn
                  return r
                }),
                (t.prototype.listenerCount = function (t) {
                  var e = this._events.get(t)
                  return e ? (e.fn ? 1 : e.length) : 0
                }),
                (t.prototype.emit = function (t) {
                  for (var e, n, r = [], s = 1; s < arguments.length; s++) r[s - 1] = arguments[s]
                  if (!this._events.has(t)) return !1
                  var o,
                    a = this._events.get(t)
                  if (a.fn)
                    return (
                      a.once && this.removeListener(t, a.fn, void 0, !0),
                      (e = a.fn).call.apply(e, i([a.context], r)),
                      !0
                    )
                  var l = a.length
                  for (o = 0; o < l; o++)
                    a[o].once && this.removeListener(t, a[o].fn, void 0, !0),
                      (n = a[o].fn).call.apply(n, i([a[o].context], r))
                  return !0
                }),
                (t.prototype.on = function (t, e, n) {
                  return o(this, t, e, n, !1)
                }),
                (t.prototype.once = function (t, e, n) {
                  return o(this, t, e, n, !0)
                }),
                (t.prototype.removeListener = function (t, e, n, i) {
                  if (!this._events.has(t)) return this
                  if (!e) return a(this, t), this
                  var r = this._events.get(t)
                  if (r.fn) r.fn !== e || (i && !r.once) || (n && r.context !== n) || a(this, t)
                  else {
                    for (var s = 0, o = [], l = r.length; s < l; s++)
                      (r[s].fn !== e || (i && !r[s].once) || (n && r[s].context !== n)) && o.push(r[s])
                    o.length ? this._events.set(t, 1 === o.length ? o[0] : o) : a(this, t)
                  }
                  return this
                }),
                (t.prototype.removeAllListeners = function (t) {
                  return (
                    t ? this._events.delete(t) && a(this, t) : ((this._events = new Map()), (this._eventsCount = 0)),
                    this
                  )
                }),
                Object.defineProperty(t.prototype, 'off', {
                  get: function () {
                    return this.removeListener
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(t.prototype, 'addListener', {
                  get: function () {
                    return this.on
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                t
              )
            })()
          e.Events = l
        },
        406: (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.VERSION = void 0), (e.VERSION = '0.0.5')
        },
        197: function (t, e, n) {
          var i =
            (this && this.__spreadArray) ||
            function (t, e) {
              for (var n = 0, i = e.length, r = t.length; n < i; n++, r++) t[r] = e[n]
              return t
            }
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.Events = void 0)
          var r = n(789),
            s = function (t, e, n) {
              void 0 === n && (n = !1), (this.fn = t), (this.context = e), (this.once = n)
            },
            o = function (t, e, n, i, r) {
              if ('function' != typeof n) throw new TypeError('The listener must be a function')
              var o = new s(n, i || t, r)
              return (
                t._events.has(e)
                  ? t._events.get(e).fn
                    ? t._events.set(e, [t._events.get(e), o])
                    : t._events.get(e).push(o)
                  : (t._events.set(e, o), t._eventsCount++),
                t
              )
            },
            a = function (t, e) {
              0 == --t._eventsCount ? (t._events = new Map()) : t._events.delete(e)
            },
            l = (function () {
              function t() {
                ;(this._events = new Map()), (this._eventsCount = 0)
              }
              return (
                Object.defineProperty(t, 'VERSION', {
                  get: function () {
                    return r.VERSION
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                (t.prototype.eventNames = function () {
                  return Array.from(this._events.keys())
                }),
                (t.prototype.listeners = function (t) {
                  var e = this._events.get(t)
                  if (!e) return []
                  if (e.fn) return [e.fn]
                  for (var n = 0, i = e.length, r = new Array(i); n < i; n++) r[n] = e[n].fn
                  return r
                }),
                (t.prototype.listenerCount = function (t) {
                  var e = this._events.get(t)
                  return e ? (e.fn ? 1 : e.length) : 0
                }),
                (t.prototype.emit = function (t) {
                  for (var e, n, r = [], s = 1; s < arguments.length; s++) r[s - 1] = arguments[s]
                  if (!this._events.has(t)) return !1
                  var o,
                    a = this._events.get(t)
                  if (a.fn)
                    return (
                      a.once && this.removeListener(t, a.fn, void 0, !0),
                      (e = a.fn).call.apply(e, i([a.context], r)),
                      !0
                    )
                  var l = a.length
                  for (o = 0; o < l; o++)
                    a[o].once && this.removeListener(t, a[o].fn, void 0, !0),
                      (n = a[o].fn).call.apply(n, i([a[o].context], r))
                  return !0
                }),
                (t.prototype.on = function (t, e, n) {
                  return o(this, t, e, n, !1)
                }),
                (t.prototype.once = function (t, e, n) {
                  return o(this, t, e, n, !0)
                }),
                (t.prototype.removeListener = function (t, e, n, i) {
                  if (!this._events.has(t)) return this
                  if (!e) return a(this, t), this
                  var r = this._events.get(t)
                  if (r.fn) r.fn !== e || (i && !r.once) || (n && r.context !== n) || a(this, t)
                  else {
                    for (var s = 0, o = [], l = r.length; s < l; s++)
                      (r[s].fn !== e || (i && !r[s].once) || (n && r[s].context !== n)) && o.push(r[s])
                    o.length ? this._events.set(t, 1 === o.length ? o[0] : o) : a(this, t)
                  }
                  return this
                }),
                (t.prototype.removeAllListeners = function (t) {
                  return (
                    t ? this._events.delete(t) && a(this, t) : ((this._events = new Map()), (this._eventsCount = 0)),
                    this
                  )
                }),
                Object.defineProperty(t.prototype, 'off', {
                  get: function () {
                    return this.removeListener
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(t.prototype, 'addListener', {
                  get: function () {
                    return this.on
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                t
              )
            })()
          e.Events = l
        },
        789: (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.VERSION = void 0), (e.VERSION = '0.0.5')
        },
        613: function (t, e, n) {
          var i =
            (this && this.__spreadArray) ||
            function (t, e) {
              for (var n = 0, i = e.length, r = t.length; n < i; n++, r++) t[r] = e[n]
              return t
            }
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.Events = void 0)
          var r = n(547),
            s = function (t, e, n) {
              void 0 === n && (n = !1), (this.fn = t), (this.context = e), (this.once = n)
            },
            o = function (t, e, n, i, r) {
              if ('function' != typeof n) throw new TypeError('The listener must be a function')
              var o = new s(n, i || t, r)
              return (
                t._events.has(e)
                  ? t._events.get(e).fn
                    ? t._events.set(e, [t._events.get(e), o])
                    : t._events.get(e).push(o)
                  : (t._events.set(e, o), t._eventsCount++),
                t
              )
            },
            a = function (t, e) {
              0 == --t._eventsCount ? (t._events = new Map()) : t._events.delete(e)
            },
            l = (function () {
              function t() {
                ;(this._events = new Map()), (this._eventsCount = 0)
              }
              return (
                Object.defineProperty(t, 'VERSION', {
                  get: function () {
                    return r.VERSION
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                (t.prototype.eventNames = function () {
                  return Array.from(this._events.keys())
                }),
                (t.prototype.listeners = function (t) {
                  var e = this._events.get(t)
                  if (!e) return []
                  if (e.fn) return [e.fn]
                  for (var n = 0, i = e.length, r = new Array(i); n < i; n++) r[n] = e[n].fn
                  return r
                }),
                (t.prototype.listenerCount = function (t) {
                  var e = this._events.get(t)
                  return e ? (e.fn ? 1 : e.length) : 0
                }),
                (t.prototype.emit = function (t) {
                  for (var e, n, r = [], s = 1; s < arguments.length; s++) r[s - 1] = arguments[s]
                  if (!this._events.has(t)) return !1
                  var o,
                    a = this._events.get(t)
                  if (a.fn)
                    return (
                      a.once && this.removeListener(t, a.fn, void 0, !0),
                      (e = a.fn).call.apply(e, i([a.context], r)),
                      !0
                    )
                  var l = a.length
                  for (o = 0; o < l; o++)
                    a[o].once && this.removeListener(t, a[o].fn, void 0, !0),
                      (n = a[o].fn).call.apply(n, i([a[o].context], r))
                  return !0
                }),
                (t.prototype.on = function (t, e, n) {
                  return o(this, t, e, n, !1)
                }),
                (t.prototype.once = function (t, e, n) {
                  return o(this, t, e, n, !0)
                }),
                (t.prototype.removeListener = function (t, e, n, i) {
                  if (!this._events.has(t)) return this
                  if (!e) return a(this, t), this
                  var r = this._events.get(t)
                  if (r.fn) r.fn !== e || (i && !r.once) || (n && r.context !== n) || a(this, t)
                  else {
                    for (var s = 0, o = [], l = r.length; s < l; s++)
                      (r[s].fn !== e || (i && !r[s].once) || (n && r[s].context !== n)) && o.push(r[s])
                    o.length ? this._events.set(t, 1 === o.length ? o[0] : o) : a(this, t)
                  }
                  return this
                }),
                (t.prototype.removeAllListeners = function (t) {
                  return (
                    t ? this._events.delete(t) && a(this, t) : ((this._events = new Map()), (this._eventsCount = 0)),
                    this
                  )
                }),
                Object.defineProperty(t.prototype, 'off', {
                  get: function () {
                    return this.removeListener
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(t.prototype, 'addListener', {
                  get: function () {
                    return this.on
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                t
              )
            })()
          e.Events = l
        },
        547: (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 }), (e.VERSION = void 0), (e.VERSION = '0.0.5')
        },
        626: t => {
          t.exports = e
        },
        298: e => {
          e.exports = t
        }
      },
      i = {}
    function r(t) {
      var e = i[t]
      if (void 0 !== e) return e.exports
      var s = (i[t] = { exports: {} })
      return n[t].call(s.exports, s, s.exports, r), s.exports
    }
    ;(r.d = (t, e) => {
      for (var n in e) r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] })
    }),
      (r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
      (r.r = t => {
        'undefined' != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(t, '__esModule', { value: !0 })
      })
    var s = {}
    return (
      (() => {
        r.r(s),
          r.d(s, {
            Canvas: () => zy,
            DotScreenShader: () => Ux,
            EffectComposer: () => Nx,
            ExtendedGroup: () => Uy,
            ExtendedMesh: () => Hm,
            ExtendedObject3D: () => ky,
            FLAT: () => i,
            FirstPersonControls: () => Ax,
            GlitchPass: () => kx,
            JoyStick: () => Sx,
            PhysicsLoader: () => $m,
            PointerDrag: () => Rx,
            PointerLock: () => Lx,
            RenderPass: () => Fx,
            Scene3D: () => By,
            ShaderPass: () => Ix,
            THREE: () => t,
            ThirdPersonControls: () => Ex,
            Types: () => o,
            enable3d: () => Fy
          })
        var t = {}
        r.r(t),
          r.d(t, {
            ACESFilmicToneMapping: () => ot,
            AddEquation: () => R,
            AddOperation: () => et,
            AdditiveAnimationBlendMode: () => Je,
            AdditiveBlending: () => S,
            AlphaFormat: () => Ut,
            AlwaysDepth: () => q,
            AlwaysStencilFunc: () => Ln,
            AmbientLight: () => Su,
            AmbientLightProbe: () => Xu,
            AnimationClip: () => Eh,
            AnimationLoader: () => Oh,
            AnimationMixer: () => Sd,
            AnimationObjectGroup: () => Md,
            AnimationUtils: () => ph,
            ArcCurve: () => Gh,
            ArrayCamera: () => Ga,
            ArrowHelper: () => fp,
            Audio: () => rd,
            AudioAnalyser: () => hd,
            AudioContext: () => Wu,
            AudioListener: () => id,
            AudioLoader: () => ju,
            AxesHelper: () => gp,
            AxisHelper: () => pm,
            BackSide: () => x,
            BasicDepthPacking: () => cn,
            BasicShadowMap: () => m,
            BinaryTextureLoader: () => ym,
            Bone: () => El,
            BooleanKeyframeTrack: () => xh,
            BoundingBoxHelper: () => mm,
            Box2: () => Nd,
            Box3: () => ri,
            Box3Helper: () => hp,
            BoxBufferGeometry: () => ys,
            BoxGeometry: () => ys,
            BoxHelper: () => cp,
            BufferAttribute: () => Cr,
            BufferGeometry: () => Qr,
            BufferGeometryLoader: () => Du,
            ByteType: () => Rt,
            Cache: () => Lh,
            Camera: () => Ms,
            CameraHelper: () => op,
            CanvasRenderer: () => bm,
            CanvasTexture: () => ec,
            CatmullRomCurve3: () => Yh,
            CineonToneMapping: () => st,
            CircleBufferGeometry: () => ic,
            CircleGeometry: () => ic,
            ClampToEdgeWrapping: () => gt,
            Clock: () => Ku,
            Color: () => Ar,
            ColorKeyframeTrack: () => bh,
            CompressedTexture: () => tc,
            CompressedTextureLoader: () => Nh,
            ConeBufferGeometry: () => sc,
            ConeGeometry: () => sc,
            CubeCamera: () => Es,
            CubeReflectionMapping: () => ct,
            CubeRefractionMapping: () => ht,
            CubeTexture: () => As,
            CubeTextureLoader: () => Fh,
            CubeUVReflectionMapping: () => pt,
            CubeUVRefractionMapping: () => mt,
            CubicBezierCurve: () => Qh,
            CubicBezierCurve3: () => $h,
            CubicInterpolant: () => fh,
            CullFaceBack: () => u,
            CullFaceFront: () => d,
            CullFaceFrontBack: () => p,
            CullFaceNone: () => h,
            Curve: () => Uh,
            CurvePath: () => ou,
            CustomBlending: () => L,
            CustomToneMapping: () => at,
            CylinderBufferGeometry: () => rc,
            CylinderGeometry: () => rc,
            Cylindrical: () => Dd,
            DataTexture: () => Rs,
            DataTexture2DArray: () => $s,
            DataTexture3D: () => to,
            DataTextureLoader: () => zh,
            DataUtils: () => xp,
            DecrementStencilOp: () => vn,
            DecrementWrapStencilOp: () => xn,
            DefaultLoadingManager: () => Ph,
            DepthFormat: () => qt,
            DepthStencilFormat: () => Xt,
            DepthTexture: () => nc,
            DirectionalLight: () => Tu,
            DirectionalLightHelper: () => ip,
            DiscreteInterpolant: () => vh,
            DodecahedronBufferGeometry: () => ac,
            DodecahedronGeometry: () => ac,
            DoubleSide: () => b,
            DstAlphaFactor: () => U,
            DstColorFactor: () => G,
            DynamicBufferAttribute: () => im,
            DynamicCopyUsage: () => Bn,
            DynamicDrawUsage: () => Pn,
            DynamicReadUsage: () => Dn,
            EdgesGeometry: () => dc,
            EdgesHelper: () => fm,
            EllipseCurve: () => Hh,
            EqualDepth: () => Z,
            EqualStencilFunc: () => Mn,
            EquirectangularReflectionMapping: () => ut,
            EquirectangularRefractionMapping: () => dt,
            Euler: () => Gi,
            EventDispatcher: () => Un,
            ExtrudeBufferGeometry: () => Uc,
            ExtrudeGeometry: () => Uc,
            FaceColors: () => qp,
            FileLoader: () => Dh,
            FlatShading: () => w,
            Float16BufferAttribute: () => kr,
            Float32Attribute: () => um,
            Float32BufferAttribute: () => Ur,
            Float64Attribute: () => dm,
            Float64BufferAttribute: () => Hr,
            FloatType: () => Ot,
            Fog: () => Ja,
            FogExp2: () => Za,
            Font: () => Uu,
            FontLoader: () => Gu,
            FrontSide: () => y,
            Frustum: () => Is,
            GLBufferAttribute: () => Ld,
            GLSL1: () => zn,
            GLSL3: () => kn,
            GammaEncoding: () => nn,
            GreaterDepth: () => K,
            GreaterEqualDepth: () => J,
            GreaterEqualStencilFunc: () => An,
            GreaterStencilFunc: () => Sn,
            GridHelper: () => Qd,
            Group: () => Va,
            HalfFloatType: () => Nt,
            HemisphereLight: () => hu,
            HemisphereLightHelper: () => Kd,
            HemisphereLightProbe: () => qu,
            IcosahedronBufferGeometry: () => Gc,
            IcosahedronGeometry: () => Gc,
            ImageBitmapLoader: () => zu,
            ImageLoader: () => Bh,
            ImageUtils: () => Xn,
            ImmediateRenderObject: () => kd,
            IncrementStencilOp: () => gn,
            IncrementWrapStencilOp: () => yn,
            InstancedBufferAttribute: () => Iu,
            InstancedBufferGeometry: () => Cu,
            InstancedInterleavedBuffer: () => Ad,
            InstancedMesh: () => Ol,
            Int16Attribute: () => am,
            Int16BufferAttribute: () => Nr,
            Int32Attribute: () => cm,
            Int32BufferAttribute: () => Fr,
            Int8Attribute: () => rm,
            Int8BufferAttribute: () => Ir,
            IntType: () => It,
            InterleavedBuffer: () => Qa,
            InterleavedBufferAttribute: () => tl,
            Interpolant: () => mh,
            InterpolateDiscrete: () => Ve,
            InterpolateLinear: () => We,
            InterpolateSmooth: () => je,
            InvertStencilOp: () => bn,
            JSONLoader: () => wm,
            KeepStencilOp: () => mn,
            KeyframeTrack: () => yh,
            LOD: () => xl,
            LatheBufferGeometry: () => Vc,
            LatheGeometry: () => Vc,
            Layers: () => Vi,
            LensFlare: () => Mm,
            LessDepth: () => X,
            LessEqualDepth: () => Y,
            LessEqualStencilFunc: () => Tn,
            LessStencilFunc: () => _n,
            Light: () => cu,
            LightProbe: () => Lu,
            Line: () => Hl,
            Line3: () => zd,
            LineBasicMaterial: () => Nl,
            LineCurve: () => tu,
            LineCurve3: () => eu,
            LineDashedMaterial: () => uh,
            LineLoop: () => jl,
            LinePieces: () => Wp,
            LineSegments: () => Wl,
            LineStrip: () => Vp,
            LinearEncoding: () => tn,
            LinearFilter: () => Mt,
            LinearInterpolant: () => gh,
            LinearMipMapLinearFilter: () => At,
            LinearMipMapNearestFilter: () => St,
            LinearMipmapLinearFilter: () => Et,
            LinearMipmapNearestFilter: () => Tt,
            LinearToneMapping: () => it,
            Loader: () => Ch,
            LoaderUtils: () => Pu,
            LoadingManager: () => Rh,
            LogLuvEncoding: () => sn,
            LoopOnce: () => Ue,
            LoopPingPong: () => Ge,
            LoopRepeat: () => He,
            LuminanceAlphaFormat: () => Wt,
            LuminanceFormat: () => Vt,
            MOUSE: () => l,
            Material: () => br,
            MaterialLoader: () => Ru,
            Math: () => Vn,
            MathUtils: () => Vn,
            Matrix3: () => jn,
            Matrix4: () => Ii,
            MaxEquation: () => D,
            Mesh: () => gs,
            MeshBasicMaterial: () => Lr,
            MeshDepthMaterial: () => Ba,
            MeshDistanceMaterial: () => Fa,
            MeshFaceMaterial: () => Yp,
            MeshLambertMaterial: () => ch,
            MeshMatcapMaterial: () => hh,
            MeshNormalMaterial: () => lh,
            MeshPhongMaterial: () => oh,
            MeshPhysicalMaterial: () => sh,
            MeshStandardMaterial: () => rh,
            MeshToonMaterial: () => ah,
            MinEquation: () => I,
            MirroredRepeatWrapping: () => vt,
            MixOperation: () => tt,
            MultiMaterial: () => Zp,
            MultiplyBlending: () => A,
            MultiplyOperation: () => $,
            NearestFilter: () => yt,
            NearestMipMapLinearFilter: () => _t,
            NearestMipMapNearestFilter: () => bt,
            NearestMipmapLinearFilter: () => wt,
            NearestMipmapNearestFilter: () => xt,
            NeverDepth: () => j,
            NeverStencilFunc: () => wn,
            NoBlending: () => M,
            NoColors: () => jp,
            NoToneMapping: () => nt,
            NormalAnimationBlendMode: () => Ze,
            NormalBlending: () => T,
            NotEqualDepth: () => Q,
            NotEqualStencilFunc: () => En,
            NumberKeyframeTrack: () => wh,
            Object3D: () => ir,
            ObjectLoader: () => Ou,
            ObjectSpaceNormalMap: () => dn,
            OctahedronBufferGeometry: () => Wc,
            OctahedronGeometry: () => Wc,
            OneFactor: () => N,
            OneMinusDstAlphaFactor: () => H,
            OneMinusDstColorFactor: () => V,
            OneMinusSrcAlphaFactor: () => k,
            OneMinusSrcColorFactor: () => F,
            OrthographicCamera: () => _u,
            PCFShadowMap: () => f,
            PCFSoftShadowMap: () => g,
            PMREMGenerator: () => Bp,
            ParametricBufferGeometry: () => jc,
            ParametricGeometry: () => jc,
            Particle: () => Kp,
            ParticleBasicMaterial: () => tm,
            ParticleSystem: () => Qp,
            ParticleSystemMaterial: () => em,
            Path: () => au,
            PerspectiveCamera: () => Ts,
            Plane: () => ar,
            PlaneBufferGeometry: () => Ns,
            PlaneGeometry: () => Ns,
            PlaneHelper: () => up,
            PointCloud: () => Jp,
            PointCloudMaterial: () => $p,
            PointLight: () => wu,
            PointLightHelper: () => Xd,
            Points: () => Kl,
            PointsMaterial: () => ql,
            PolarGridHelper: () => $d,
            PolyhedronBufferGeometry: () => oc,
            PolyhedronGeometry: () => oc,
            PositionalAudio: () => cd,
            PropertyBinding: () => _d,
            PropertyMixer: () => ud,
            QuadraticBezierCurve: () => nu,
            QuadraticBezierCurve3: () => iu,
            Quaternion: () => ti,
            QuaternionKeyframeTrack: () => Mh,
            QuaternionLinearInterpolant: () => _h,
            REVISION: () => a,
            RGBADepthPacking: () => hn,
            RGBAFormat: () => Gt,
            RGBAIntegerFormat: () => $t,
            RGBA_ASTC_10x10_Format: () => _e,
            RGBA_ASTC_10x5_Format: () => xe,
            RGBA_ASTC_10x6_Format: () => be,
            RGBA_ASTC_10x8_Format: () => we,
            RGBA_ASTC_12x10_Format: () => Me,
            RGBA_ASTC_12x12_Format: () => Te,
            RGBA_ASTC_4x4_Format: () => ue,
            RGBA_ASTC_5x4_Format: () => de,
            RGBA_ASTC_5x5_Format: () => pe,
            RGBA_ASTC_6x5_Format: () => me,
            RGBA_ASTC_6x6_Format: () => fe,
            RGBA_ASTC_8x5_Format: () => ge,
            RGBA_ASTC_8x6_Format: () => ve,
            RGBA_ASTC_8x8_Format: () => ye,
            RGBA_BPTC_Format: () => Se,
            RGBA_ETC2_EAC_Format: () => he,
            RGBA_PVRTC_2BPPV1_Format: () => ae,
            RGBA_PVRTC_4BPPV1_Format: () => oe,
            RGBA_S3TC_DXT1_Format: () => ee,
            RGBA_S3TC_DXT3_Format: () => ne,
            RGBA_S3TC_DXT5_Format: () => ie,
            RGBDEncoding: () => ln,
            RGBEEncoding: () => rn,
            RGBEFormat: () => jt,
            RGBFormat: () => Ht,
            RGBIntegerFormat: () => Qt,
            RGBM16Encoding: () => an,
            RGBM7Encoding: () => on,
            RGB_ETC1_Format: () => le,
            RGB_ETC2_Format: () => ce,
            RGB_PVRTC_2BPPV1_Format: () => se,
            RGB_PVRTC_4BPPV1_Format: () => re,
            RGB_S3TC_DXT1_Format: () => te,
            RGFormat: () => Jt,
            RGIntegerFormat: () => Kt,
            RawShaderMaterial: () => ih,
            Ray: () => Ci,
            Raycaster: () => Rd,
            RectAreaLight: () => Eu,
            RedFormat: () => Yt,
            RedIntegerFormat: () => Zt,
            ReinhardToneMapping: () => rt,
            RepeatWrapping: () => ft,
            ReplaceStencilOp: () => fn,
            ReverseSubtractEquation: () => C,
            RingBufferGeometry: () => qc,
            RingGeometry: () => qc,
            SRGB8_ALPHA8_ASTC_10x10_Format: () => Fe,
            SRGB8_ALPHA8_ASTC_10x5_Format: () => Oe,
            SRGB8_ALPHA8_ASTC_10x6_Format: () => Ne,
            SRGB8_ALPHA8_ASTC_10x8_Format: () => Be,
            SRGB8_ALPHA8_ASTC_12x10_Format: () => ze,
            SRGB8_ALPHA8_ASTC_12x12_Format: () => ke,
            SRGB8_ALPHA8_ASTC_4x4_Format: () => Ee,
            SRGB8_ALPHA8_ASTC_5x4_Format: () => Ae,
            SRGB8_ALPHA8_ASTC_5x5_Format: () => Le,
            SRGB8_ALPHA8_ASTC_6x5_Format: () => Re,
            SRGB8_ALPHA8_ASTC_6x6_Format: () => Pe,
            SRGB8_ALPHA8_ASTC_8x5_Format: () => Ce,
            SRGB8_ALPHA8_ASTC_8x6_Format: () => Ie,
            SRGB8_ALPHA8_ASTC_8x8_Format: () => De,
            Scene: () => Ka,
            SceneUtils: () => _m,
            ShaderChunk: () => Bs,
            ShaderLib: () => zs,
            ShaderMaterial: () => _s,
            ShadowMaterial: () => nh,
            Shape: () => lu,
            ShapeBufferGeometry: () => Xc,
            ShapeGeometry: () => Xc,
            ShapePath: () => ku,
            ShapeUtils: () => Fc,
            ShortType: () => Pt,
            Skeleton: () => Rl,
            SkeletonHelper: () => jd,
            SkinnedMesh: () => Sl,
            SmoothShading: () => _,
            Sphere: () => Mi,
            SphereBufferGeometry: () => Yc,
            SphereGeometry: () => Yc,
            Spherical: () => Id,
            SphericalHarmonics3: () => Au,
            SplineCurve: () => ru,
            SpotLight: () => gu,
            SpotLightHelper: () => Hd,
            Sprite: () => fl,
            SpriteMaterial: () => el,
            SrcAlphaFactor: () => z,
            SrcAlphaSaturateFactor: () => W,
            SrcColorFactor: () => B,
            StaticCopyUsage: () => Nn,
            StaticDrawUsage: () => Rn,
            StaticReadUsage: () => In,
            StereoCamera: () => Ju,
            StreamCopyUsage: () => Fn,
            StreamDrawUsage: () => Cn,
            StreamReadUsage: () => On,
            StringKeyframeTrack: () => Th,
            SubtractEquation: () => P,
            SubtractiveBlending: () => E,
            TOUCH: () => c,
            TangentSpaceNormalMap: () => un,
            TetrahedronBufferGeometry: () => Zc,
            TetrahedronGeometry: () => Zc,
            TextBufferGeometry: () => Jc,
            TextGeometry: () => Jc,
            Texture: () => Zn,
            TextureLoader: () => kh,
            TorusBufferGeometry: () => Kc,
            TorusGeometry: () => Kc,
            TorusKnotBufferGeometry: () => Qc,
            TorusKnotGeometry: () => Qc,
            Triangle: () => yr,
            TriangleFanDrawMode: () => $e,
            TriangleStripDrawMode: () => Qe,
            TrianglesDrawMode: () => Ke,
            TubeBufferGeometry: () => $c,
            TubeGeometry: () => $c,
            UVMapping: () => lt,
            Uint16Attribute: () => lm,
            Uint16BufferAttribute: () => Br,
            Uint32Attribute: () => hm,
            Uint32BufferAttribute: () => zr,
            Uint8Attribute: () => sm,
            Uint8BufferAttribute: () => Dr,
            Uint8ClampedAttribute: () => om,
            Uint8ClampedBufferAttribute: () => Or,
            Uniform: () => Ed,
            UniformsLib: () => Fs,
            UniformsUtils: () => ws,
            UnsignedByteType: () => Lt,
            UnsignedInt248Type: () => kt,
            UnsignedIntType: () => Dt,
            UnsignedShort4444Type: () => Bt,
            UnsignedShort5551Type: () => Ft,
            UnsignedShort565Type: () => zt,
            UnsignedShortType: () => Ct,
            VSMShadowMap: () => v,
            Vector2: () => Wn,
            Vector3: () => ei,
            Vector4: () => Kn,
            VectorKeyframeTrack: () => Sh,
            Vertex: () => nm,
            VertexColors: () => Xp,
            VideoTexture: () => $l,
            WebGL1Renderer: () => Ya,
            WebGLCubeRenderTarget: () => Ls,
            WebGLMultisampleRenderTarget: () => $n,
            WebGLRenderTarget: () => Qn,
            WebGLRenderTargetCube: () => xm,
            WebGLRenderer: () => Xa,
            WebGLUtils: () => Ha,
            WireframeGeometry: () => th,
            WireframeHelper: () => gm,
            WrapAroundEnding: () => Ye,
            XHRLoader: () => vm,
            ZeroCurvatureEnding: () => qe,
            ZeroFactor: () => O,
            ZeroSlopeEnding: () => Xe,
            ZeroStencilOp: () => pn,
            sRGBEncoding: () => en
          })
        var e = {}
        r.r(e),
          r.d(e, {
            AsyncCompress: () => Ig,
            AsyncDecompress: () => Yg,
            AsyncDeflate: () => Tg,
            AsyncGunzip: () => Bg,
            AsyncGzip: () => Ig,
            AsyncInflate: () => Lg,
            AsyncUnzipInflate: () => wv,
            AsyncUnzlib: () => Wg,
            AsyncZipDeflate: () => fv,
            AsyncZlib: () => Ug,
            Compress: () => Cg,
            DecodeUTF8: () => nv,
            Decompress: () => Xg,
            Deflate: () => Mg,
            EncodeUTF8: () => iv,
            Gunzip: () => Ng,
            Gzip: () => Cg,
            Inflate: () => Ag,
            Unzip: () => _v,
            UnzipInflate: () => bv,
            UnzipPassThrough: () => xv,
            Unzlib: () => Vg,
            Zip: () => gv,
            ZipDeflate: () => mv,
            ZipPassThrough: () => pv,
            Zlib: () => kg,
            compress: () => Dg,
            compressSync: () => Og,
            decompress: () => Zg,
            decompressSync: () => Jg,
            default: () => Sv,
            deflate: () => Sg,
            deflateSync: () => Eg,
            gunzip: () => Fg,
            gunzipSync: () => zg,
            gzip: () => Dg,
            gzipSync: () => Og,
            inflate: () => Rg,
            inflateSync: () => Pg,
            strFromU8: () => sv,
            strToU8: () => rv,
            unzip: () => Mv,
            unzipSync: () => Tv,
            unzlib: () => jg,
            unzlibSync: () => qg,
            zip: () => vv,
            zipSync: () => yv,
            zlib: () => Hg,
            zlibSync: () => Gg
          })
        var n = {}
        r.r(n)
        var i = {}
        r.r(i),
          r.d(i, {
            ActionSprite: () => ux,
            Button: () => px,
            DrawSprite: () => fx,
            DrawTexture: () => mx,
            SimpleSprite: () => hx,
            SpriteSheet: () => dx,
            TextSprite: () => yx,
            TextTexture: () => vx,
            TextureAtlas: () => bx,
            destroy: () => ax,
            getParent: () => ox,
            initEvents: () => gx,
            physics: () => Tx,
            setSize: () => sx,
            updateEvents: () => cx
          })
        var o = {}
        r.r(o)
        const a = '127',
          l = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
          c = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
          h = 0,
          u = 1,
          d = 2,
          p = 3,
          m = 0,
          f = 1,
          g = 2,
          v = 3,
          y = 0,
          x = 1,
          b = 2,
          w = 1,
          _ = 2,
          M = 0,
          T = 1,
          S = 2,
          E = 3,
          A = 4,
          L = 5,
          R = 100,
          P = 101,
          C = 102,
          I = 103,
          D = 104,
          O = 200,
          N = 201,
          B = 202,
          F = 203,
          z = 204,
          k = 205,
          U = 206,
          H = 207,
          G = 208,
          V = 209,
          W = 210,
          j = 0,
          q = 1,
          X = 2,
          Y = 3,
          Z = 4,
          J = 5,
          K = 6,
          Q = 7,
          $ = 0,
          tt = 1,
          et = 2,
          nt = 0,
          it = 1,
          rt = 2,
          st = 3,
          ot = 4,
          at = 5,
          lt = 300,
          ct = 301,
          ht = 302,
          ut = 303,
          dt = 304,
          pt = 306,
          mt = 307,
          ft = 1e3,
          gt = 1001,
          vt = 1002,
          yt = 1003,
          xt = 1004,
          bt = 1004,
          wt = 1005,
          _t = 1005,
          Mt = 1006,
          Tt = 1007,
          St = 1007,
          Et = 1008,
          At = 1008,
          Lt = 1009,
          Rt = 1010,
          Pt = 1011,
          Ct = 1012,
          It = 1013,
          Dt = 1014,
          Ot = 1015,
          Nt = 1016,
          Bt = 1017,
          Ft = 1018,
          zt = 1019,
          kt = 1020,
          Ut = 1021,
          Ht = 1022,
          Gt = 1023,
          Vt = 1024,
          Wt = 1025,
          jt = Gt,
          qt = 1026,
          Xt = 1027,
          Yt = 1028,
          Zt = 1029,
          Jt = 1030,
          Kt = 1031,
          Qt = 1032,
          $t = 1033,
          te = 33776,
          ee = 33777,
          ne = 33778,
          ie = 33779,
          re = 35840,
          se = 35841,
          oe = 35842,
          ae = 35843,
          le = 36196,
          ce = 37492,
          he = 37496,
          ue = 37808,
          de = 37809,
          pe = 37810,
          me = 37811,
          fe = 37812,
          ge = 37813,
          ve = 37814,
          ye = 37815,
          xe = 37816,
          be = 37817,
          we = 37818,
          _e = 37819,
          Me = 37820,
          Te = 37821,
          Se = 36492,
          Ee = 37840,
          Ae = 37841,
          Le = 37842,
          Re = 37843,
          Pe = 37844,
          Ce = 37845,
          Ie = 37846,
          De = 37847,
          Oe = 37848,
          Ne = 37849,
          Be = 37850,
          Fe = 37851,
          ze = 37852,
          ke = 37853,
          Ue = 2200,
          He = 2201,
          Ge = 2202,
          Ve = 2300,
          We = 2301,
          je = 2302,
          qe = 2400,
          Xe = 2401,
          Ye = 2402,
          Ze = 2500,
          Je = 2501,
          Ke = 0,
          Qe = 1,
          $e = 2,
          tn = 3e3,
          en = 3001,
          nn = 3007,
          rn = 3002,
          sn = 3003,
          on = 3004,
          an = 3005,
          ln = 3006,
          cn = 3200,
          hn = 3201,
          un = 0,
          dn = 1,
          pn = 0,
          mn = 7680,
          fn = 7681,
          gn = 7682,
          vn = 7683,
          yn = 34055,
          xn = 34056,
          bn = 5386,
          wn = 512,
          _n = 513,
          Mn = 514,
          Tn = 515,
          Sn = 516,
          En = 517,
          An = 518,
          Ln = 519,
          Rn = 35044,
          Pn = 35048,
          Cn = 35040,
          In = 35045,
          Dn = 35049,
          On = 35041,
          Nn = 35046,
          Bn = 35050,
          Fn = 35042,
          zn = '100',
          kn = '300 es'
        function Un() {}
        Object.assign(Un.prototype, {
          addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {})
            const n = this._listeners
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
          },
          hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1
            const n = this._listeners
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
          },
          removeEventListener: function (t, e) {
            if (void 0 === this._listeners) return
            const n = this._listeners[t]
            if (void 0 !== n) {
              const t = n.indexOf(e)
              ;-1 !== t && n.splice(t, 1)
            }
          },
          dispatchEvent: function (t) {
            if (void 0 === this._listeners) return
            const e = this._listeners[t.type]
            if (void 0 !== e) {
              t.target = this
              const n = e.slice(0)
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
              t.target = null
            }
          }
        })
        const Hn = []
        for (let t = 0; t < 256; t++) Hn[t] = (t < 16 ? '0' : '') + t.toString(16)
        let Gn = 1234567
        const Vn = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: function () {
            const t = (4294967295 * Math.random()) | 0,
              e = (4294967295 * Math.random()) | 0,
              n = (4294967295 * Math.random()) | 0,
              i = (4294967295 * Math.random()) | 0
            return (
              Hn[255 & t] +
              Hn[(t >> 8) & 255] +
              Hn[(t >> 16) & 255] +
              Hn[(t >> 24) & 255] +
              '-' +
              Hn[255 & e] +
              Hn[(e >> 8) & 255] +
              '-' +
              Hn[((e >> 16) & 15) | 64] +
              Hn[(e >> 24) & 255] +
              '-' +
              Hn[(63 & n) | 128] +
              Hn[(n >> 8) & 255] +
              '-' +
              Hn[(n >> 16) & 255] +
              Hn[(n >> 24) & 255] +
              Hn[255 & i] +
              Hn[(i >> 8) & 255] +
              Hn[(i >> 16) & 255] +
              Hn[(i >> 24) & 255]
            ).toUpperCase()
          },
          clamp: function (t, e, n) {
            return Math.max(e, Math.min(n, t))
          },
          euclideanModulo: function (t, e) {
            return ((t % e) + e) % e
          },
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e)
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0
          },
          lerp: function (t, e, n) {
            return (1 - n) * t + n * e
          },
          damp: function (t, e, n, i) {
            return Vn.lerp(t, e, 1 - Math.exp(-n * i))
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(Vn.euclideanModulo(t, 2 * e) - e)
          },
          smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
          },
          smootherstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t)
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random())
          },
          seededRandom: function (t) {
            return void 0 !== t && (Gn = t % 2147483647), (Gn = (16807 * Gn) % 2147483647), (Gn - 1) / 2147483646
          },
          degToRad: function (t) {
            return t * Vn.DEG2RAD
          },
          radToDeg: function (t) {
            return t * Vn.RAD2DEG
          },
          isPowerOfTwo: function (t) {
            return 0 == (t & (t - 1)) && 0 !== t
          },
          ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
          },
          floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
          },
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
              o = Math.sin,
              a = s(n / 2),
              l = o(n / 2),
              c = s((e + i) / 2),
              h = o((e + i) / 2),
              u = s((e - i) / 2),
              d = o((e - i) / 2),
              p = s((i - e) / 2),
              m = o((i - e) / 2)
            switch (r) {
              case 'XYX':
                t.set(a * h, l * u, l * d, a * c)
                break
              case 'YZY':
                t.set(l * d, a * h, l * u, a * c)
                break
              case 'ZXZ':
                t.set(l * u, l * d, a * h, a * c)
                break
              case 'XZX':
                t.set(a * h, l * m, l * p, a * c)
                break
              case 'YXY':
                t.set(l * p, a * h, l * m, a * c)
                break
              case 'ZYZ':
                t.set(l * m, l * p, a * h, a * c)
                break
              default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + r)
            }
          }
        }
        class Wn {
          constructor(t = 0, e = 0) {
            ;(this.x = t), (this.y = e)
          }
          get width() {
            return this.x
          }
          set width(t) {
            this.x = t
          }
          get height() {
            return this.y
          }
          set height(t) {
            this.y = t
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this
          }
          setX(t) {
            return (this.x = t), this
          }
          setY(t) {
            return (this.y = t), this
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e
                break
              case 1:
                this.y = e
                break
              default:
                throw new Error('index is out of range: ' + t)
            }
            return this
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x
              case 1:
                return this.y
              default:
                throw new Error('index is out of range: ' + t)
            }
          }
          clone() {
            return new this.constructor(this.x, this.y)
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this)
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this)
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t)
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements
            return (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this
          }
          min(t) {
            return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
          }
          max(t) {
            return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), this
            )
          }
          clampScalar(t, e) {
            return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this
          }
          clampLength(t, e) {
            const n = this.length()
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
          }
          floor() {
            return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          }
          ceil() {
            return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          }
          round() {
            return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            )
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this
          }
          dot(t) {
            return this.x * t.x + this.y * t.y
          }
          cross(t) {
            return this.x * t.y - this.y * t.x
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y
            return e * e + n * n
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t)
          }
          lerp(t, e) {
            return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          }
          lerpVectors(t, e, n) {
            return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
          }
          equals(t) {
            return t.x === this.x && t.y === this.y
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n && console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            )
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              s = this.y - t.y
            return (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this
          }
        }
        Wn.prototype.isVector2 = !0
        class jn {
          constructor() {
            ;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.')
          }
          set(t, e, n, i, r, s, o, a, l) {
            const c = this.elements
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = o),
              (c[3] = e),
              (c[4] = r),
              (c[5] = a),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            )
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
          }
          copy(t) {
            const e = this.elements,
              n = t.elements
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            )
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            )
          }
          setFromMatrix4(t) {
            const e = t.elements
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
          }
          multiply(t) {
            return this.multiplyMatrices(this, t)
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this)
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              o = n[3],
              a = n[6],
              l = n[1],
              c = n[4],
              h = n[7],
              u = n[2],
              d = n[5],
              p = n[8],
              m = i[0],
              f = i[3],
              g = i[6],
              v = i[1],
              y = i[4],
              x = i[7],
              b = i[2],
              w = i[5],
              _ = i[8]
            return (
              (r[0] = s * m + o * v + a * b),
              (r[3] = s * f + o * y + a * w),
              (r[6] = s * g + o * x + a * _),
              (r[1] = l * m + c * v + h * b),
              (r[4] = l * f + c * y + h * w),
              (r[7] = l * g + c * x + h * _),
              (r[2] = u * m + d * v + p * b),
              (r[5] = u * f + d * y + p * w),
              (r[8] = u * g + d * x + p * _),
              this
            )
          }
          multiplyScalar(t) {
            const e = this.elements
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            )
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8]
            return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              h = c * s - o * l,
              u = o * a - c * r,
              d = l * r - s * a,
              p = e * h + n * u + i * d
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
            const m = 1 / p
            return (
              (t[0] = h * m),
              (t[1] = (i * l - c * n) * m),
              (t[2] = (o * n - i * s) * m),
              (t[3] = u * m),
              (t[4] = (c * e - i * a) * m),
              (t[5] = (i * r - o * e) * m),
              (t[6] = d * m),
              (t[7] = (n * a - l * e) * m),
              (t[8] = (s * e - n * r) * m),
              this
            )
          }
          transpose() {
            let t
            const e = this.elements
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            )
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose()
          }
          transposeIntoArray(t) {
            const e = this.elements
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            )
          }
          setUvTransform(t, e, n, i, r, s, o) {
            const a = Math.cos(r),
              l = Math.sin(r)
            return (
              this.set(
                n * a,
                n * l,
                -n * (a * s + l * o) + s + t,
                -i * l,
                i * a,
                -i * (-l * s + a * o) + o + e,
                0,
                0,
                1
              ),
              this
            )
          }
          scale(t, e) {
            const n = this.elements
            return (n[0] *= t), (n[3] *= t), (n[6] *= t), (n[1] *= e), (n[4] *= e), (n[7] *= e), this
          }
          rotate(t) {
            const e = Math.cos(t),
              n = Math.sin(t),
              i = this.elements,
              r = i[0],
              s = i[3],
              o = i[6],
              a = i[1],
              l = i[4],
              c = i[7]
            return (
              (i[0] = e * r + n * a),
              (i[3] = e * s + n * l),
              (i[6] = e * o + n * c),
              (i[1] = -n * r + e * a),
              (i[4] = -n * s + e * l),
              (i[7] = -n * o + e * c),
              this
            )
          }
          translate(t, e) {
            const n = this.elements
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            )
          }
          equals(t) {
            const e = this.elements,
              n = t.elements
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1
            return !0
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]
            return this
          }
          toArray(t = [], e = 0) {
            const n = this.elements
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            )
          }
          clone() {
            return new this.constructor().fromArray(this.elements)
          }
        }
        let qn
        jn.prototype.isMatrix3 = !0
        const Xn = {
          getDataURL: function (t) {
            if (/^data:/i.test(t.src)) return t.src
            if ('undefined' == typeof HTMLCanvasElement) return t.src
            let e
            if (t instanceof HTMLCanvasElement) e = t
            else {
              void 0 === qn && (qn = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')),
                (qn.width = t.width),
                (qn.height = t.height)
              const n = qn.getContext('2d')
              t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), (e = qn)
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', t),
                e.toDataURL('image/jpeg', 0.6))
              : e.toDataURL('image/png')
          }
        }
        let Yn = 0
        class Zn extends Un {
          constructor(
            t = Zn.DEFAULT_IMAGE,
            e = Zn.DEFAULT_MAPPING,
            n = gt,
            i = gt,
            r = Mt,
            s = Et,
            o = Gt,
            a = Lt,
            l = 1,
            c = tn
          ) {
            super(),
              Object.defineProperty(this, 'id', { value: Yn++ }),
              (this.uuid = Vn.generateUUID()),
              (this.name = ''),
              (this.image = t),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = o),
              (this.internalFormat = null),
              (this.type = a),
              (this.offset = new Wn(0, 0)),
              (this.repeat = new Wn(1, 1)),
              (this.center = new Wn(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new jn()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = c),
              (this.version = 0),
              (this.onUpdate = null)
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            )
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              this
            )
          }
          toJSON(t) {
            const e = void 0 === t || 'string' == typeof t
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]
            const n = {
              metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment
            }
            if (void 0 !== this.image) {
              const i = this.image
              if ((void 0 === i.uuid && (i.uuid = Vn.generateUUID()), !e && void 0 === t.images[i.uuid])) {
                let e
                if (Array.isArray(i)) {
                  e = []
                  for (let t = 0, n = i.length; t < n; t++)
                    i[t].isDataTexture ? e.push(Jn(i[t].image)) : e.push(Jn(i[t]))
                } else e = Jn(i)
                t.images[i.uuid] = { uuid: i.uuid, url: e }
              }
              n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n), n
          }
          dispose() {
            this.dispatchEvent({ type: 'dispose' })
          }
          transformUv(t) {
            if (this.mapping !== lt) return t
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case ft:
                  t.x = t.x - Math.floor(t.x)
                  break
                case gt:
                  t.x = t.x < 0 ? 0 : 1
                  break
                case vt:
                  1 === Math.abs(Math.floor(t.x) % 2) ? (t.x = Math.ceil(t.x) - t.x) : (t.x = t.x - Math.floor(t.x))
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case ft:
                  t.y = t.y - Math.floor(t.y)
                  break
                case gt:
                  t.y = t.y < 0 ? 0 : 1
                  break
                case vt:
                  1 === Math.abs(Math.floor(t.y) % 2) ? (t.y = Math.ceil(t.y) - t.y) : (t.y = t.y - Math.floor(t.y))
              }
            return this.flipY && (t.y = 1 - t.y), t
          }
          set needsUpdate(t) {
            !0 === t && this.version++
          }
        }
        function Jn(t) {
          return ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
            ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
            ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
            ? Xn.getDataURL(t)
            : t.data
            ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
              }
            : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
        }
        ;(Zn.DEFAULT_IMAGE = void 0), (Zn.DEFAULT_MAPPING = lt), (Zn.prototype.isTexture = !0)
        class Kn {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            ;(this.x = t), (this.y = e), (this.z = n), (this.w = i)
          }
          get width() {
            return this.z
          }
          set width(t) {
            this.z = t
          }
          get height() {
            return this.w
          }
          set height(t) {
            this.w = t
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
          }
          setX(t) {
            return (this.x = t), this
          }
          setY(t) {
            return (this.y = t), this
          }
          setZ(t) {
            return (this.z = t), this
          }
          setW(t) {
            return (this.w = t), this
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e
                break
              case 1:
                this.y = e
                break
              case 2:
                this.z = e
                break
              case 3:
                this.w = e
                break
              default:
                throw new Error('index is out of range: ' + t)
            }
            return this
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x
              case 1:
                return this.y
              case 2:
                return this.z
              case 3:
                return this.w
              default:
                throw new Error('index is out of range: ' + t)
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this)
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this)
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              s = t.elements
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
              (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
              (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
              (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
              this
            )
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t)
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w)
            const e = Math.sqrt(1 - t.w * t.w)
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            )
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r
            const s = 0.01,
              o = 0.1,
              a = t.elements,
              l = a[0],
              c = a[4],
              h = a[8],
              u = a[1],
              d = a[5],
              p = a[9],
              m = a[2],
              f = a[6],
              g = a[10]
            if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
              if (Math.abs(c + u) < o && Math.abs(h + m) < o && Math.abs(p + f) < o && Math.abs(l + d + g - 3) < o)
                return this.set(1, 0, 0, 0), this
              e = Math.PI
              const t = (l + 1) / 2,
                a = (d + 1) / 2,
                v = (g + 1) / 2,
                y = (c + u) / 4,
                x = (h + m) / 4,
                b = (p + f) / 4
              return (
                t > a && t > v
                  ? t < s
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
                  : a > v
                  ? a < s
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(a)), (n = y / i), (r = b / i))
                  : v < s
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(v)), (n = x / r), (i = b / r)),
                this.set(n, i, r, e),
                this
              )
            }
            let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c))
            return (
              Math.abs(v) < 0.001 && (v = 1),
              (this.x = (f - p) / v),
              (this.y = (h - m) / v),
              (this.z = (u - c) / v),
              (this.w = Math.acos((l + d + g - 1) / 2)),
              this
            )
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            )
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            )
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            )
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            )
          }
          clampLength(t, e) {
            const n = this.length()
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            )
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            )
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            )
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            )
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t)
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            )
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            )
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n && console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            )
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            )
          }
        }
        Kn.prototype.isVector4 = !0
        class Qn extends Un {
          constructor(t, e, n) {
            super(),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new Kn(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new Kn(0, 0, t, e)),
              (n = n || {}),
              (this.texture = new Zn(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
              )),
              (this.texture.image = {}),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = 1),
              (this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null)
          }
          setTexture(t) {
            ;(t.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = t)
          }
          setSize(t, e, n = 1) {
            ;(this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e)
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            )
          }
          dispose() {
            this.dispatchEvent({ type: 'dispose' })
          }
        }
        Qn.prototype.isWebGLRenderTarget = !0
        class $n extends Qn {
          constructor(t, e, n) {
            super(t, e, n), (this.samples = 4)
          }
          copy(t) {
            return super.copy.call(this, t), (this.samples = t.samples), this
          }
        }
        $n.prototype.isWebGLMultisampleRenderTarget = !0
        class ti {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            ;(this._x = t), (this._y = e), (this._z = n), (this._w = i)
          }
          static slerp(t, e, n, i) {
            return (
              console.warn(
                'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.'
              ),
              n.slerpQuaternions(t, e, i)
            )
          }
          static slerpFlat(t, e, n, i, r, s, o) {
            let a = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              h = n[i + 3]
            const u = r[s + 0],
              d = r[s + 1],
              p = r[s + 2],
              m = r[s + 3]
            if (0 === o) return (t[e + 0] = a), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)
            if (1 === o) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = m)
            if (h !== m || a !== u || l !== d || c !== p) {
              let t = 1 - o
              const e = a * u + l * d + c * p + h * m,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  s = Math.atan2(r, e * n)
                ;(t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r)
              }
              const r = o * n
              if (((a = a * t + u * r), (l = l * t + d * r), (c = c * t + p * r), (h = h * t + m * r), t === 1 - o)) {
                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h)
                ;(a *= t), (l *= t), (c *= t), (h *= t)
              }
            }
            ;(t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h)
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const o = n[i],
              a = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              h = r[s],
              u = r[s + 1],
              d = r[s + 2],
              p = r[s + 3]
            return (
              (t[e] = o * p + c * h + a * d - l * u),
              (t[e + 1] = a * p + c * u + l * h - o * d),
              (t[e + 2] = l * p + c * d + o * u - a * h),
              (t[e + 3] = c * p - o * h - a * u - l * d),
              t
            )
          }
          get x() {
            return this._x
          }
          set x(t) {
            ;(this._x = t), this._onChangeCallback()
          }
          get y() {
            return this._y
          }
          set y(t) {
            ;(this._y = t), this._onChangeCallback()
          }
          get z() {
            return this._z
          }
          set z(t) {
            ;(this._z = t), this._onChangeCallback()
          }
          get w() {
            return this._w
          }
          set w(t) {
            ;(this._w = t), this._onChangeCallback()
          }
          set(t, e, n, i) {
            return (this._x = t), (this._y = e), (this._z = n), (this._w = i), this._onChangeCallback(), this
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
          }
          copy(t) {
            return (this._x = t.x), (this._y = t.y), (this._z = t.z), (this._w = t.w), this._onChangeCallback(), this
          }
          setFromEuler(t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
              )
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._order,
              o = Math.cos,
              a = Math.sin,
              l = o(n / 2),
              c = o(i / 2),
              h = o(r / 2),
              u = a(n / 2),
              d = a(i / 2),
              p = a(r / 2)
            switch (s) {
              case 'XYZ':
                ;(this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p)
                break
              case 'YXZ':
                ;(this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p)
                break
              case 'ZXY':
                ;(this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p)
                break
              case 'ZYX':
                ;(this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p)
                break
              case 'YZX':
                ;(this._x = u * c * h + l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h - u * d * p)
                break
              case 'XZY':
                ;(this._x = u * c * h - l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h + u * d * p)
                break
              default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + s)
            }
            return !1 !== e && this._onChangeCallback(), this
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n)
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            )
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              s = e[1],
              o = e[5],
              a = e[9],
              l = e[2],
              c = e[6],
              h = e[10],
              u = n + o + h
            if (u > 0) {
              const t = 0.5 / Math.sqrt(u + 1)
              ;(this._w = 0.25 / t), (this._x = (c - a) * t), (this._y = (r - l) * t), (this._z = (s - i) * t)
            } else if (n > o && n > h) {
              const t = 2 * Math.sqrt(1 + n - o - h)
              ;(this._w = (c - a) / t), (this._x = 0.25 * t), (this._y = (i + s) / t), (this._z = (r + l) / t)
            } else if (o > h) {
              const t = 2 * Math.sqrt(1 + o - n - h)
              ;(this._w = (r - l) / t), (this._x = (i + s) / t), (this._y = 0.25 * t), (this._z = (a + c) / t)
            } else {
              const t = 2 * Math.sqrt(1 + h - n - o)
              ;(this._w = (s - i) / t), (this._x = (r + l) / t), (this._y = (a + c) / t), (this._z = 0.25 * t)
            }
            return this._onChangeCallback(), this
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
                    : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            )
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(Vn.clamp(this.dot(t), -1, 1)))
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t)
            if (0 === n) return this
            const i = Math.min(1, e / n)
            return this.slerp(t, i), this
          }
          identity() {
            return this.set(0, 0, 0, 1)
          }
          invert() {
            return this.conjugate()
          }
          conjugate() {
            return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
          }
          dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          }
          lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
          }
          length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
          }
          normalize() {
            let t = this.length()
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            )
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
                ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t)
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this)
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._w,
              o = e._x,
              a = e._y,
              l = e._z,
              c = e._w
            return (
              (this._x = n * c + s * o + i * l - r * a),
              (this._y = i * c + s * a + r * o - n * l),
              (this._z = r * c + s * l + n * a - i * o),
              (this._w = s * c - n * o - i * a - r * l),
              this._onChangeCallback(),
              this
            )
          }
          slerp(t, e) {
            if (0 === e) return this
            if (1 === e) return this.copy(t)
            const n = this._x,
              i = this._y,
              r = this._z,
              s = this._w
            let o = s * t._w + n * t._x + i * t._y + r * t._z
            if (
              (o < 0
                ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (o = -o))
                : this.copy(t),
              o >= 1)
            )
              return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            const a = 1 - o * o
            if (a <= Number.EPSILON) {
              const t = 1 - e
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              )
            }
            const l = Math.sqrt(a),
              c = Math.atan2(l, o),
              h = Math.sin((1 - e) * c) / l,
              u = Math.sin(e * c) / l
            return (
              (this._w = s * h + this._w * u),
              (this._x = n * h + this._x * u),
              (this._y = i * h + this._y * u),
              (this._z = r * h + this._z * u),
              this._onChangeCallback(),
              this
            )
          }
          slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n)
          }
          equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            )
          }
          toArray(t = [], e = 0) {
            return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t
          }
          fromBufferAttribute(t, e) {
            return (this._x = t.getX(e)), (this._y = t.getY(e)), (this._z = t.getZ(e)), (this._w = t.getW(e)), this
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this
          }
          _onChangeCallback() {}
        }
        ti.prototype.isQuaternion = !0
        class ei {
          constructor(t = 0, e = 0, n = 0) {
            ;(this.x = t), (this.y = e), (this.z = n)
          }
          set(t, e, n) {
            return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this
          }
          setX(t) {
            return (this.x = t), this
          }
          setY(t) {
            return (this.y = t), this
          }
          setZ(t) {
            return (this.z = t), this
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e
                break
              case 1:
                this.y = e
                break
              case 2:
                this.z = e
                break
              default:
                throw new Error('index is out of range: ' + t)
            }
            return this
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x
              case 1:
                return this.y
              case 2:
                return this.z
              default:
                throw new Error('index is out of range: ' + t)
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z)
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this)
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this)
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
                ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this)
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this
          }
          multiplyVectors(t, e) {
            return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
          }
          applyEuler(t) {
            return (
              (t && t.isEuler) ||
                console.error(
                  'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
                ),
              this.applyQuaternion(ii.setFromEuler(t))
            )
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(ii.setFromAxisAngle(t, e))
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            )
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15])
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
              this
            )
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              o = t.z,
              a = t.w,
              l = a * e + s * i - o * n,
              c = a * n + o * e - r * i,
              h = a * i + r * n - s * e,
              u = -r * e - s * n - o * i
            return (
              (this.x = l * a + u * -r + c * -o - h * -s),
              (this.y = c * a + u * -s + h * -r - l * -o),
              (this.z = h * a + u * -o + l * -s - c * -r),
              this
            )
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            )
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t)
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), this
            )
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), this
            )
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            )
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            )
          }
          clampLength(t, e) {
            const n = this.length()
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
          }
          floor() {
            return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this
          }
          ceil() {
            return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
          }
          round() {
            return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            )
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t)
          }
          lerp(t, e) {
            return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), this
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), (this.z = t.z + (e.z - t.z) * n), this
            )
          }
          cross(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
                ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t)
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = e.x,
              o = e.y,
              a = e.z
            return (this.x = i * a - r * o), (this.y = r * s - n * a), (this.z = n * o - i * s), this
          }
          projectOnVector(t) {
            const e = t.lengthSq()
            if (0 === e) return this.set(0, 0, 0)
            const n = t.dot(this) / e
            return this.copy(t).multiplyScalar(n)
          }
          projectOnPlane(t) {
            return ni.copy(this).projectOnVector(t), this.sub(ni)
          }
          reflect(t) {
            return this.sub(ni.copy(t).multiplyScalar(2 * this.dot(t)))
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq())
            if (0 === e) return Math.PI / 2
            const n = this.dot(t) / e
            return Math.acos(Vn.clamp(n, -1, 1))
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z
            return e * e + n * n + i * i
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t
            return (this.x = i * Math.sin(n)), (this.y = Math.cos(e) * t), (this.z = i * Math.cos(n)), this
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
          }
          setFromCylindricalCoords(t, e, n) {
            return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
          }
          setFromMatrixPosition(t) {
            const e = t.elements
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length()
            return (this.x = e), (this.y = n), (this.z = i), this
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n && console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            )
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
          }
        }
        ei.prototype.isVector3 = !0
        const ni = new ei(),
          ii = new ti()
        class ri {
          constructor(t = new ei(1 / 0, 1 / 0, 1 / 0), e = new ei(-1 / 0, -1 / 0, -1 / 0)) {
            ;(this.min = t), (this.max = e)
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this
          }
          setFromArray(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              s = -1 / 0,
              o = -1 / 0
            for (let a = 0, l = t.length; a < l; a += 3) {
              const l = t[a],
                c = t[a + 1],
                h = t[a + 2]
              l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
            }
            return this.min.set(e, n, i), this.max.set(r, s, o), this
          }
          setFromBufferAttribute(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              s = -1 / 0,
              o = -1 / 0
            for (let a = 0, l = t.count; a < l; a++) {
              const l = t.getX(a),
                c = t.getY(a),
                h = t.getZ(a)
              l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
            }
            return this.min.set(e, n, i), this.max.set(r, s, o), this
          }
          setFromPoints(t) {
            this.makeEmpty()
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
            return this
          }
          setFromCenterAndSize(t, e) {
            const n = oi.copy(e).multiplyScalar(0.5)
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
          }
          setFromObject(t) {
            return this.makeEmpty(), this.expandByObject(t)
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
          }
          makeEmpty() {
            return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
          }
          getCenter(t) {
            return (
              void 0 === t && (console.warn('THREE.Box3: .getCenter() target is now required'), (t = new ei())),
              this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            )
          }
          getSize(t) {
            return (
              void 0 === t && (console.warn('THREE.Box3: .getSize() target is now required'), (t = new ei())),
              this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            )
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
          }
          expandByObject(t) {
            t.updateWorldMatrix(!1, !1)
            const e = t.geometry
            void 0 !== e &&
              (null === e.boundingBox && e.computeBoundingBox(),
              ai.copy(e.boundingBox),
              ai.applyMatrix4(t.matrixWorld),
              this.union(ai))
            const n = t.children
            for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t])
            return this
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            )
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            )
          }
          getParameter(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Box3: .getParameter() target is now required'), (e = new ei())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
                (t.z - this.min.z) / (this.max.z - this.min.z)
              )
            )
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            )
          }
          intersectsSphere(t) {
            return this.clampPoint(t.center, oi), oi.distanceToSquared(t.center) <= t.radius * t.radius
          }
          intersectsPlane(t) {
            let e, n
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            )
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1
            this.getCenter(mi),
              fi.subVectors(this.max, mi),
              li.subVectors(t.a, mi),
              ci.subVectors(t.b, mi),
              hi.subVectors(t.c, mi),
              ui.subVectors(ci, li),
              di.subVectors(hi, ci),
              pi.subVectors(li, hi)
            let e = [
              0,
              -ui.z,
              ui.y,
              0,
              -di.z,
              di.y,
              0,
              -pi.z,
              pi.y,
              ui.z,
              0,
              -ui.x,
              di.z,
              0,
              -di.x,
              pi.z,
              0,
              -pi.x,
              -ui.y,
              ui.x,
              0,
              -di.y,
              di.x,
              0,
              -pi.y,
              pi.x,
              0
            ]
            return (
              !!yi(e, li, ci, hi, fi) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!yi(e, li, ci, hi, fi) && (gi.crossVectors(ui, di), (e = [gi.x, gi.y, gi.z]), yi(e, li, ci, hi, fi)))
            )
          }
          clampPoint(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Box3: .clampPoint() target is now required'), (e = new ei())),
              e.copy(t).clamp(this.min, this.max)
            )
          }
          distanceToPoint(t) {
            return oi.copy(t).clamp(this.min, this.max).sub(t).length()
          }
          getBoundingSphere(t) {
            return (
              void 0 === t && console.error('THREE.Box3: .getBoundingSphere() target is now required'),
              this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(oi).length()),
              t
            )
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (si[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                si[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                si[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                si[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                si[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                si[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                si[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                si[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(si)),
              this
            )
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
          }
        }
        ri.prototype.isBox3 = !0
        const si = [new ei(), new ei(), new ei(), new ei(), new ei(), new ei(), new ei(), new ei()],
          oi = new ei(),
          ai = new ri(),
          li = new ei(),
          ci = new ei(),
          hi = new ei(),
          ui = new ei(),
          di = new ei(),
          pi = new ei(),
          mi = new ei(),
          fi = new ei(),
          gi = new ei(),
          vi = new ei()
        function yi(t, e, n, i, r) {
          for (let s = 0, o = t.length - 3; s <= o; s += 3) {
            vi.fromArray(t, s)
            const o = r.x * Math.abs(vi.x) + r.y * Math.abs(vi.y) + r.z * Math.abs(vi.z),
              a = e.dot(vi),
              l = n.dot(vi),
              c = i.dot(vi)
            if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
          }
          return !0
        }
        const xi = new ri(),
          bi = new ei(),
          wi = new ei(),
          _i = new ei()
        class Mi {
          constructor(t = new ei(), e = -1) {
            ;(this.center = t), (this.radius = e)
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this
          }
          setFromPoints(t, e) {
            const n = this.center
            void 0 !== e ? n.copy(e) : xi.setFromPoints(t).getCenter(n)
            let i = 0
            for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]))
            return (this.radius = Math.sqrt(i)), this
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this
          }
          isEmpty() {
            return this.radius < 0
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this
          }
          containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius
            return t.center.distanceToSquared(this.center) <= e * e
          }
          intersectsBox(t) {
            return t.intersectsSphere(this)
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t)
            return (
              void 0 === e && (console.warn('THREE.Sphere: .clampPoint() target is now required'), (e = new ei())),
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
              e
            )
          }
          getBoundingBox(t) {
            return (
              void 0 === t && (console.warn('THREE.Sphere: .getBoundingBox() target is now required'), (t = new ri())),
              this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            )
          }
          applyMatrix4(t) {
            return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this
          }
          translate(t) {
            return this.center.add(t), this
          }
          expandByPoint(t) {
            _i.subVectors(t, this.center)
            const e = _i.lengthSq()
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius)
              this.center.add(_i.multiplyScalar(n / t)), (this.radius += n)
            }
            return this
          }
          union(t) {
            return (
              wi.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
              this.expandByPoint(bi.copy(t.center).add(wi)),
              this.expandByPoint(bi.copy(t.center).sub(wi)),
              this
            )
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        const Ti = new ei(),
          Si = new ei(),
          Ei = new ei(),
          Ai = new ei(),
          Li = new ei(),
          Ri = new ei(),
          Pi = new ei()
        class Ci {
          constructor(t = new ei(), e = new ei(0, 0, -1)) {
            ;(this.origin = t), (this.direction = e)
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
          }
          copy(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
          }
          at(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Ray: .at() target is now required'), (e = new ei())),
              e.copy(this.direction).multiplyScalar(t).add(this.origin)
            )
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
          }
          recast(t) {
            return this.origin.copy(this.at(t, Ti)), this
          }
          closestPointToPoint(t, e) {
            void 0 === e && (console.warn('THREE.Ray: .closestPointToPoint() target is now required'), (e = new ei())),
              e.subVectors(t, this.origin)
            const n = e.dot(this.direction)
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
          }
          distanceSqToPoint(t) {
            const e = Ti.subVectors(t, this.origin).dot(this.direction)
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (Ti.copy(this.direction).multiplyScalar(e).add(this.origin), Ti.distanceToSquared(t))
          }
          distanceSqToSegment(t, e, n, i) {
            Si.copy(t).add(e).multiplyScalar(0.5), Ei.copy(e).sub(t).normalize(), Ai.copy(this.origin).sub(Si)
            const r = 0.5 * t.distanceTo(e),
              s = -this.direction.dot(Ei),
              o = Ai.dot(this.direction),
              a = -Ai.dot(Ei),
              l = Ai.lengthSq(),
              c = Math.abs(1 - s * s)
            let h, u, d, p
            if (c > 0)
              if (((h = s * a - o), (u = s * o - a), (p = r * c), h >= 0))
                if (u >= -p)
                  if (u <= p) {
                    const t = 1 / c
                    ;(h *= t), (u *= t), (d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l)
                  } else (u = r), (h = Math.max(0, -(s * u + o))), (d = -h * h + u * (u + 2 * a) + l)
                else (u = -r), (h = Math.max(0, -(s * u + o))), (d = -h * h + u * (u + 2 * a) + l)
              else
                u <= -p
                  ? ((h = Math.max(0, -(-s * r + o))),
                    (u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                    (d = -h * h + u * (u + 2 * a) + l))
                  : u <= p
                  ? ((h = 0), (u = Math.min(Math.max(-r, -a), r)), (d = u * (u + 2 * a) + l))
                  : ((h = Math.max(0, -(s * r + o))),
                    (u = h > 0 ? r : Math.min(Math.max(-r, -a), r)),
                    (d = -h * h + u * (u + 2 * a) + l))
            else (u = s > 0 ? -r : r), (h = Math.max(0, -(s * u + o))), (d = -h * h + u * (u + 2 * a) + l)
            return (
              n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
              i && i.copy(Ei).multiplyScalar(u).add(Si),
              d
            )
          }
          intersectSphere(t, e) {
            Ti.subVectors(t.center, this.origin)
            const n = Ti.dot(this.direction),
              i = Ti.dot(Ti) - n * n,
              r = t.radius * t.radius
            if (i > r) return null
            const s = Math.sqrt(r - i),
              o = n - s,
              a = n + s
            return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction)
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null
            const n = -(this.origin.dot(t.normal) + t.constant) / e
            return n >= 0 ? n : null
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t)
            return null === n ? null : this.at(n, e)
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin)
            return 0 === e || t.normal.dot(this.direction) * e < 0
          }
          intersectBox(t, e) {
            let n, i, r, s, o, a
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin
            return (
              l >= 0
                ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
                : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
              c >= 0
                ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
              n > s || r > i
                ? null
                : ((r > n || n != n) && (n = r),
                  (s < i || i != i) && (i = s),
                  h >= 0
                    ? ((o = (t.min.z - u.z) * h), (a = (t.max.z - u.z) * h))
                    : ((o = (t.max.z - u.z) * h), (a = (t.min.z - u.z) * h)),
                  n > a || o > i
                    ? null
                    : ((o > n || n != n) && (n = o),
                      (a < i || i != i) && (i = a),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            )
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, Ti)
          }
          intersectTriangle(t, e, n, i, r) {
            Li.subVectors(e, t), Ri.subVectors(n, t), Pi.crossVectors(Li, Ri)
            let s,
              o = this.direction.dot(Pi)
            if (o > 0) {
              if (i) return null
              s = 1
            } else {
              if (!(o < 0)) return null
              ;(s = -1), (o = -o)
            }
            Ai.subVectors(this.origin, t)
            const a = s * this.direction.dot(Ri.crossVectors(Ai, Ri))
            if (a < 0) return null
            const l = s * this.direction.dot(Li.cross(Ai))
            if (l < 0) return null
            if (a + l > o) return null
            const c = -s * Ai.dot(Pi)
            return c < 0 ? null : this.at(c / o, r)
          }
          applyMatrix4(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
          }
          equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        class Ii {
          constructor() {
            ;(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.')
          }
          set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, m, f) {
            const g = this.elements
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = s),
              (g[9] = o),
              (g[13] = a),
              (g[2] = l),
              (g[6] = c),
              (g[10] = h),
              (g[14] = u),
              (g[3] = d),
              (g[7] = p),
              (g[11] = m),
              (g[15] = f),
              this
            )
          }
          identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          }
          clone() {
            return new Ii().fromArray(this.elements)
          }
          copy(t) {
            const e = this.elements,
              n = t.elements
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            )
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
          }
          setFromMatrix3(t) {
            const e = t.elements
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
          }
          extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
          }
          makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / Di.setFromMatrixColumn(t, 0).length(),
              r = 1 / Di.setFromMatrixColumn(t, 1).length(),
              s = 1 / Di.setFromMatrixColumn(t, 2).length()
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            )
          }
          makeRotationFromEuler(t) {
            ;(t && t.isEuler) ||
              console.error(
                'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
              )
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              s = Math.cos(n),
              o = Math.sin(n),
              a = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              h = Math.sin(r)
            if ('XYZ' === t.order) {
              const t = s * c,
                n = s * h,
                i = o * c,
                r = o * h
              ;(e[0] = a * c),
                (e[4] = -a * h),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -o * a),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = s * a)
            } else if ('YXZ' === t.order) {
              const t = a * c,
                n = a * h,
                i = l * c,
                r = l * h
              ;(e[0] = t + r * o),
                (e[4] = i * o - n),
                (e[8] = s * l),
                (e[1] = s * h),
                (e[5] = s * c),
                (e[9] = -o),
                (e[2] = n * o - i),
                (e[6] = r + t * o),
                (e[10] = s * a)
            } else if ('ZXY' === t.order) {
              const t = a * c,
                n = a * h,
                i = l * c,
                r = l * h
              ;(e[0] = t - r * o),
                (e[4] = -s * h),
                (e[8] = i + n * o),
                (e[1] = n + i * o),
                (e[5] = s * c),
                (e[9] = r - t * o),
                (e[2] = -s * l),
                (e[6] = o),
                (e[10] = s * a)
            } else if ('ZYX' === t.order) {
              const t = s * c,
                n = s * h,
                i = o * c,
                r = o * h
              ;(e[0] = a * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = a * h),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = o * a),
                (e[10] = s * a)
            } else if ('YZX' === t.order) {
              const t = s * a,
                n = s * l,
                i = o * a,
                r = o * l
              ;(e[0] = a * c),
                (e[4] = r - t * h),
                (e[8] = i * h + n),
                (e[1] = h),
                (e[5] = s * c),
                (e[9] = -o * c),
                (e[2] = -l * c),
                (e[6] = n * h + i),
                (e[10] = t - r * h)
            } else if ('XZY' === t.order) {
              const t = s * a,
                n = s * l,
                i = o * a,
                r = o * l
              ;(e[0] = a * c),
                (e[4] = -h),
                (e[8] = l * c),
                (e[1] = t * h + r),
                (e[5] = s * c),
                (e[9] = n * h - i),
                (e[2] = i * h - n),
                (e[6] = o * c),
                (e[10] = r * h + t)
            }
            return (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
          }
          makeRotationFromQuaternion(t) {
            return this.compose(Ni, t, Bi)
          }
          lookAt(t, e, n) {
            const i = this.elements
            return (
              ki.subVectors(t, e),
              0 === ki.lengthSq() && (ki.z = 1),
              ki.normalize(),
              Fi.crossVectors(n, ki),
              0 === Fi.lengthSq() &&
                (1 === Math.abs(n.z) ? (ki.x += 1e-4) : (ki.z += 1e-4), ki.normalize(), Fi.crossVectors(n, ki)),
              Fi.normalize(),
              zi.crossVectors(ki, Fi),
              (i[0] = Fi.x),
              (i[4] = zi.x),
              (i[8] = ki.x),
              (i[1] = Fi.y),
              (i[5] = zi.y),
              (i[9] = ki.y),
              (i[2] = Fi.z),
              (i[6] = zi.z),
              (i[10] = ki.z),
              this
            )
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
                ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t)
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this)
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              o = n[4],
              a = n[8],
              l = n[12],
              c = n[1],
              h = n[5],
              u = n[9],
              d = n[13],
              p = n[2],
              m = n[6],
              f = n[10],
              g = n[14],
              v = n[3],
              y = n[7],
              x = n[11],
              b = n[15],
              w = i[0],
              _ = i[4],
              M = i[8],
              T = i[12],
              S = i[1],
              E = i[5],
              A = i[9],
              L = i[13],
              R = i[2],
              P = i[6],
              C = i[10],
              I = i[14],
              D = i[3],
              O = i[7],
              N = i[11],
              B = i[15]
            return (
              (r[0] = s * w + o * S + a * R + l * D),
              (r[4] = s * _ + o * E + a * P + l * O),
              (r[8] = s * M + o * A + a * C + l * N),
              (r[12] = s * T + o * L + a * I + l * B),
              (r[1] = c * w + h * S + u * R + d * D),
              (r[5] = c * _ + h * E + u * P + d * O),
              (r[9] = c * M + h * A + u * C + d * N),
              (r[13] = c * T + h * L + u * I + d * B),
              (r[2] = p * w + m * S + f * R + g * D),
              (r[6] = p * _ + m * E + f * P + g * O),
              (r[10] = p * M + m * A + f * C + g * N),
              (r[14] = p * T + m * L + f * I + g * B),
              (r[3] = v * w + y * S + x * R + b * D),
              (r[7] = v * _ + y * E + x * P + b * O),
              (r[11] = v * M + y * A + x * C + b * N),
              (r[15] = v * T + y * L + x * I + b * B),
              this
            )
          }
          multiplyScalar(t) {
            const e = this.elements
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            )
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              s = t[1],
              o = t[5],
              a = t[9],
              l = t[13],
              c = t[2],
              h = t[6],
              u = t[10],
              d = t[14]
            return (
              t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) +
              t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) +
              t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) +
              t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
            )
          }
          transpose() {
            const t = this.elements
            let e
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            )
          }
          setPosition(t, e, n) {
            const i = this.elements
            return (
              t.isVector3 ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z)) : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            )
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              h = t[9],
              u = t[10],
              d = t[11],
              p = t[12],
              m = t[13],
              f = t[14],
              g = t[15],
              v = h * f * l - m * u * l + m * a * d - o * f * d - h * a * g + o * u * g,
              y = p * u * l - c * f * l - p * a * d + s * f * d + c * a * g - s * u * g,
              x = c * m * l - p * h * l + p * o * d - s * m * d - c * o * g + s * h * g,
              b = p * h * a - c * m * a - p * o * u + s * m * u + c * o * f - s * h * f,
              w = e * v + n * y + i * x + r * b
            if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            const _ = 1 / w
            return (
              (t[0] = v * _),
              (t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * _),
              (t[2] = (o * f * r - m * a * r + m * i * l - n * f * l - o * i * g + n * a * g) * _),
              (t[3] = (h * a * r - o * u * r - h * i * l + n * u * l + o * i * d - n * a * d) * _),
              (t[4] = y * _),
              (t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * _),
              (t[6] = (p * a * r - s * f * r - p * i * l + e * f * l + s * i * g - e * a * g) * _),
              (t[7] = (s * u * r - c * a * r + c * i * l - e * u * l - s * i * d + e * a * d) * _),
              (t[8] = x * _),
              (t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * _),
              (t[10] = (s * m * r - p * o * r + p * n * l - e * m * l - s * n * g + e * o * g) * _),
              (t[11] = (c * o * r - s * h * r - c * n * l + e * h * l + s * n * d - e * o * d) * _),
              (t[12] = b * _),
              (t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * _),
              (t[14] = (p * o * i - s * m * i - p * n * a + e * m * a + s * n * f - e * o * f) * _),
              (t[15] = (s * h * i - c * o * i + c * n * a - e * h * a - s * n * u + e * o * u) * _),
              this
            )
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            )
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
            return Math.sqrt(Math.max(e, n, i))
          }
          makeTranslation(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t)
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t)
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t)
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              s = t.x,
              o = t.y,
              a = t.z,
              l = r * s,
              c = r * o
            return (
              this.set(
                l * s + n,
                l * o - i * a,
                l * a + i * o,
                0,
                l * o + i * a,
                c * o + n,
                c * a - i * s,
                0,
                l * a - i * o,
                c * a + i * s,
                r * a * a + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            )
          }
          makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
          }
          makeShear(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              s = e._y,
              o = e._z,
              a = e._w,
              l = r + r,
              c = s + s,
              h = o + o,
              u = r * l,
              d = r * c,
              p = r * h,
              m = s * c,
              f = s * h,
              g = o * h,
              v = a * l,
              y = a * c,
              x = a * h,
              b = n.x,
              w = n.y,
              _ = n.z
            return (
              (i[0] = (1 - (m + g)) * b),
              (i[1] = (d + x) * b),
              (i[2] = (p - y) * b),
              (i[3] = 0),
              (i[4] = (d - x) * w),
              (i[5] = (1 - (u + g)) * w),
              (i[6] = (f + v) * w),
              (i[7] = 0),
              (i[8] = (p + y) * _),
              (i[9] = (f - v) * _),
              (i[10] = (1 - (u + m)) * _),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            )
          }
          decompose(t, e, n) {
            const i = this.elements
            let r = Di.set(i[0], i[1], i[2]).length()
            const s = Di.set(i[4], i[5], i[6]).length(),
              o = Di.set(i[8], i[9], i[10]).length()
            this.determinant() < 0 && (r = -r), (t.x = i[12]), (t.y = i[13]), (t.z = i[14]), Oi.copy(this)
            const a = 1 / r,
              l = 1 / s,
              c = 1 / o
            return (
              (Oi.elements[0] *= a),
              (Oi.elements[1] *= a),
              (Oi.elements[2] *= a),
              (Oi.elements[4] *= l),
              (Oi.elements[5] *= l),
              (Oi.elements[6] *= l),
              (Oi.elements[8] *= c),
              (Oi.elements[9] *= c),
              (Oi.elements[10] *= c),
              e.setFromRotationMatrix(Oi),
              (n.x = r),
              (n.y = s),
              (n.z = o),
              this
            )
          }
          makePerspective(t, e, n, i, r, s) {
            void 0 === s &&
              console.warn(
                'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
              )
            const o = this.elements,
              a = (2 * r) / (e - t),
              l = (2 * r) / (n - i),
              c = (e + t) / (e - t),
              h = (n + i) / (n - i),
              u = -(s + r) / (s - r),
              d = (-2 * s * r) / (s - r)
            return (
              (o[0] = a),
              (o[4] = 0),
              (o[8] = c),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = l),
              (o[9] = h),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = u),
              (o[14] = d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            )
          }
          makeOrthographic(t, e, n, i, r, s) {
            const o = this.elements,
              a = 1 / (e - t),
              l = 1 / (n - i),
              c = 1 / (s - r),
              h = (e + t) * a,
              u = (n + i) * l,
              d = (s + r) * c
            return (
              (o[0] = 2 * a),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -h),
              (o[1] = 0),
              (o[5] = 2 * l),
              (o[9] = 0),
              (o[13] = -u),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * c),
              (o[14] = -d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            )
          }
          equals(t) {
            const e = this.elements,
              n = t.elements
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1
            return !0
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]
            return this
          }
          toArray(t = [], e = 0) {
            const n = this.elements
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            )
          }
        }
        Ii.prototype.isMatrix4 = !0
        const Di = new ei(),
          Oi = new Ii(),
          Ni = new ei(0, 0, 0),
          Bi = new ei(1, 1, 1),
          Fi = new ei(),
          zi = new ei(),
          ki = new ei(),
          Ui = new Ii(),
          Hi = new ti()
        class Gi {
          constructor(t = 0, e = 0, n = 0, i = Gi.DefaultOrder) {
            ;(this._x = t), (this._y = e), (this._z = n), (this._order = i)
          }
          get x() {
            return this._x
          }
          set x(t) {
            ;(this._x = t), this._onChangeCallback()
          }
          get y() {
            return this._y
          }
          set y(t) {
            ;(this._y = t), this._onChangeCallback()
          }
          get z() {
            return this._z
          }
          set z(t) {
            ;(this._z = t), this._onChangeCallback()
          }
          get order() {
            return this._order
          }
          set order(t) {
            ;(this._order = t), this._onChangeCallback()
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i || this._order),
              this._onChangeCallback(),
              this
            )
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            )
          }
          setFromRotationMatrix(t, e, n) {
            const i = Vn.clamp,
              r = t.elements,
              s = r[0],
              o = r[4],
              a = r[8],
              l = r[1],
              c = r[5],
              h = r[9],
              u = r[2],
              d = r[6],
              p = r[10]
            switch ((e = e || this._order)) {
              case 'XYZ':
                ;(this._y = Math.asin(i(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-o, s)))
                    : ((this._x = Math.atan2(d, c)), (this._z = 0))
                break
              case 'YXZ':
                ;(this._x = Math.asin(-i(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(l, c)))
                    : ((this._y = Math.atan2(-u, s)), (this._z = 0))
                break
              case 'ZXY':
                ;(this._x = Math.asin(i(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._y = Math.atan2(-u, p)), (this._z = Math.atan2(-o, c)))
                    : ((this._y = 0), (this._z = Math.atan2(l, s)))
                break
              case 'ZYX':
                ;(this._y = Math.asin(-i(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(l, s)))
                    : ((this._x = 0), (this._z = Math.atan2(-o, c)))
                break
              case 'YZX':
                ;(this._z = Math.asin(i(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-u, s)))
                    : ((this._x = 0), (this._y = Math.atan2(a, p)))
                break
              case 'XZY':
                ;(this._z = Math.asin(-i(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, s)))
                    : ((this._x = Math.atan2(-h, p)), (this._y = 0))
                break
              default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + e)
            }
            return (this._order = e), !1 !== n && this._onChangeCallback(), this
          }
          setFromQuaternion(t, e, n) {
            return Ui.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ui, e, n)
          }
          setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
          }
          reorder(t) {
            return Hi.setFromEuler(this), this.setFromQuaternion(Hi, t)
          }
          equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            )
          }
          toArray(t = [], e = 0) {
            return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t
          }
          toVector3(t) {
            return t ? t.set(this._x, this._y, this._z) : new ei(this._x, this._y, this._z)
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this
          }
          _onChangeCallback() {}
        }
        ;(Gi.prototype.isEuler = !0),
          (Gi.DefaultOrder = 'XYZ'),
          (Gi.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'])
        class Vi {
          constructor() {
            this.mask = 1
          }
          set(t) {
            this.mask = (1 << t) | 0
          }
          enable(t) {
            this.mask |= (1 << t) | 0
          }
          enableAll() {
            this.mask = -1
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0)
          }
          disableAll() {
            this.mask = 0
          }
          test(t) {
            return 0 != (this.mask & t.mask)
          }
        }
        let Wi = 0
        const ji = new ei(),
          qi = new ti(),
          Xi = new Ii(),
          Yi = new ei(),
          Zi = new ei(),
          Ji = new ei(),
          Ki = new ti(),
          Qi = new ei(1, 0, 0),
          $i = new ei(0, 1, 0),
          tr = new ei(0, 0, 1),
          er = { type: 'added' },
          nr = { type: 'removed' }
        function ir() {
          Object.defineProperty(this, 'id', { value: Wi++ }),
            (this.uuid = Vn.generateUUID()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = ir.DefaultUp.clone())
          const t = new ei(),
            e = new Gi(),
            n = new ti(),
            i = new ei(1, 1, 1)
          e._onChange(function () {
            n.setFromEuler(e, !1)
          }),
            n._onChange(function () {
              e.setFromQuaternion(n, void 0, !1)
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Ii() },
              normalMatrix: { value: new jn() }
            }),
            (this.matrix = new Ii()),
            (this.matrixWorld = new Ii()),
            (this.matrixAutoUpdate = ir.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Vi()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {})
        }
        ;(ir.DefaultUp = new ei(0, 1, 0)),
          (ir.DefaultMatrixAutoUpdate = !0),
          (ir.prototype = Object.assign(Object.create(Un.prototype), {
            constructor: ir,
            isObject3D: !0,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix4: function (t) {
              this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function (t) {
              return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function (t, e) {
              this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function (t) {
              this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function (t) {
              this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function (t) {
              this.quaternion.copy(t)
            },
            rotateOnAxis: function (t, e) {
              return qi.setFromAxisAngle(t, e), this.quaternion.multiply(qi), this
            },
            rotateOnWorldAxis: function (t, e) {
              return qi.setFromAxisAngle(t, e), this.quaternion.premultiply(qi), this
            },
            rotateX: function (t) {
              return this.rotateOnAxis(Qi, t)
            },
            rotateY: function (t) {
              return this.rotateOnAxis($i, t)
            },
            rotateZ: function (t) {
              return this.rotateOnAxis(tr, t)
            },
            translateOnAxis: function (t, e) {
              return ji.copy(t).applyQuaternion(this.quaternion), this.position.add(ji.multiplyScalar(e)), this
            },
            translateX: function (t) {
              return this.translateOnAxis(Qi, t)
            },
            translateY: function (t) {
              return this.translateOnAxis($i, t)
            },
            translateZ: function (t) {
              return this.translateOnAxis(tr, t)
            },
            localToWorld: function (t) {
              return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function (t) {
              return t.applyMatrix4(Xi.copy(this.matrixWorld).invert())
            },
            lookAt: function (t, e, n) {
              t.isVector3 ? Yi.copy(t) : Yi.set(t, e, n)
              const i = this.parent
              this.updateWorldMatrix(!0, !1),
                Zi.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Xi.lookAt(Zi, Yi, this.up) : Xi.lookAt(Yi, Zi, this.up),
                this.quaternion.setFromRotationMatrix(Xi),
                i &&
                  (Xi.extractRotation(i.matrixWorld),
                  qi.setFromRotationMatrix(Xi),
                  this.quaternion.premultiply(qi.invert()))
            },
            add: function (t) {
              if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
                return this
              }
              return t === this
                ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
                : (t && t.isObject3D
                    ? (null !== t.parent && t.parent.remove(t),
                      (t.parent = this),
                      this.children.push(t),
                      t.dispatchEvent(er))
                    : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', t),
                  this)
            },
            remove: function (t) {
              if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.remove(arguments[t])
                return this
              }
              const e = this.children.indexOf(t)
              return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(nr)), this
            },
            clear: function () {
              for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t]
                ;(e.parent = null), e.dispatchEvent(nr)
              }
              return (this.children.length = 0), this
            },
            attach: function (t) {
              return (
                this.updateWorldMatrix(!0, !1),
                Xi.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Xi.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(Xi),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
              )
            },
            getObjectById: function (t) {
              return this.getObjectByProperty('id', t)
            },
            getObjectByName: function (t) {
              return this.getObjectByProperty('name', t)
            },
            getObjectByProperty: function (t, e) {
              if (this[t] === e) return this
              for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e)
                if (void 0 !== i) return i
              }
            },
            getWorldPosition: function (t) {
              return (
                void 0 === t &&
                  (console.warn('THREE.Object3D: .getWorldPosition() target is now required'), (t = new ei())),
                this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
              )
            },
            getWorldQuaternion: function (t) {
              return (
                void 0 === t &&
                  (console.warn('THREE.Object3D: .getWorldQuaternion() target is now required'), (t = new ti())),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Zi, t, Ji),
                t
              )
            },
            getWorldScale: function (t) {
              return (
                void 0 === t &&
                  (console.warn('THREE.Object3D: .getWorldScale() target is now required'), (t = new ei())),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Zi, Ki, t),
                t
              )
            },
            getWorldDirection: function (t) {
              void 0 === t &&
                (console.warn('THREE.Object3D: .getWorldDirection() target is now required'), (t = new ei())),
                this.updateWorldMatrix(!0, !1)
              const e = this.matrixWorld.elements
              return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function () {},
            traverse: function (t) {
              t(this)
              const e = this.children
              for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            },
            traverseVisible: function (t) {
              if (!1 === this.visible) return
              t(this)
              const e = this.children
              for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            },
            traverseAncestors: function (t) {
              const e = this.parent
              null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function () {
              this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0)
            },
            updateMatrixWorld: function (t) {
              this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) &&
                  (null === this.parent
                    ? this.matrixWorld.copy(this.matrix)
                    : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                  (this.matrixWorldNeedsUpdate = !1),
                  (t = !0))
              const e = this.children
              for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
            },
            updateWorldMatrix: function (t, e) {
              const n = this.parent
              if (
                (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e)
              ) {
                const t = this.children
                for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
              }
            },
            toJSON: function (t) {
              const e = void 0 === t || 'string' == typeof t,
                n = {}
              e &&
                ((t = {
                  geometries: {},
                  materials: {},
                  textures: {},
                  images: {},
                  shapes: {},
                  skeletons: {},
                  animations: {}
                }),
                (n.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }))
              const i = {}
              function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
              }
              if (
                ((i.uuid = this.uuid),
                (i.type = this.type),
                '' !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
                (i.layers = this.layers.mask),
                (i.matrix = this.matrix.toArray()),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh &&
                  ((i.type = 'InstancedMesh'),
                  (i.count = this.count),
                  (i.instanceMatrix = this.instanceMatrix.toJSON()),
                  null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isMesh || this.isLine || this.isPoints)
              ) {
                i.geometry = r(t.geometries, this.geometry)
                const e = this.geometry.parameters
                if (void 0 !== e && void 0 !== e.shapes) {
                  const n = e.shapes
                  if (Array.isArray(n))
                    for (let e = 0, i = n.length; e < i; e++) {
                      const i = n[e]
                      r(t.shapes, i)
                    }
                  else r(t.shapes, n)
                }
              }
              if (
                (this.isSkinnedMesh &&
                  ((i.bindMode = this.bindMode),
                  (i.bindMatrix = this.bindMatrix.toArray()),
                  void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
                void 0 !== this.material)
              )
                if (Array.isArray(this.material)) {
                  const e = []
                  for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]))
                  i.material = e
                } else i.material = r(t.materials, this.material)
              if (this.children.length > 0) {
                i.children = []
                for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
              }
              if (this.animations.length > 0) {
                i.animations = []
                for (let e = 0; e < this.animations.length; e++) {
                  const n = this.animations[e]
                  i.animations.push(r(t.animations, n))
                }
              }
              if (e) {
                const e = s(t.geometries),
                  i = s(t.materials),
                  r = s(t.textures),
                  o = s(t.images),
                  a = s(t.shapes),
                  l = s(t.skeletons),
                  c = s(t.animations)
                e.length > 0 && (n.geometries = e),
                  i.length > 0 && (n.materials = i),
                  r.length > 0 && (n.textures = r),
                  o.length > 0 && (n.images = o),
                  a.length > 0 && (n.shapes = a),
                  l.length > 0 && (n.skeletons = l),
                  c.length > 0 && (n.animations = c)
              }
              return (n.object = i), n
              function s(t) {
                const e = []
                for (const n in t) {
                  const i = t[n]
                  delete i.metadata, e.push(i)
                }
                return e
              }
            },
            clone: function (t) {
              return new this.constructor().copy(this, t)
            },
            copy: function (t, e = !0) {
              if (
                ((this.name = t.name),
                this.up.copy(t.up),
                this.position.copy(t.position),
                (this.rotation.order = t.rotation.order),
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                (this.matrixAutoUpdate = t.matrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                (this.layers.mask = t.layers.mask),
                (this.visible = t.visible),
                (this.castShadow = t.castShadow),
                (this.receiveShadow = t.receiveShadow),
                (this.frustumCulled = t.frustumCulled),
                (this.renderOrder = t.renderOrder),
                (this.userData = JSON.parse(JSON.stringify(t.userData))),
                !0 === e)
              )
                for (let e = 0; e < t.children.length; e++) {
                  const n = t.children[e]
                  this.add(n.clone())
                }
              return this
            }
          }))
        const rr = new ei(),
          sr = new ei(),
          or = new jn()
        class ar {
          constructor(t = new ei(1, 0, 0), e = 0) {
            ;(this.normal = t), (this.constant = e)
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          }
          setFromCoplanarPoints(t, e, n) {
            const i = rr.subVectors(n, e).cross(sr.subVectors(t, e)).normalize()
            return this.setFromNormalAndCoplanarPoint(i, t), this
          }
          copy(t) {
            return this.normal.copy(t.normal), (this.constant = t.constant), this
          }
          normalize() {
            const t = 1 / this.normal.length()
            return this.normal.multiplyScalar(t), (this.constant *= t), this
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius
          }
          projectPoint(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Plane: .projectPoint() target is now required'), (e = new ei())),
              e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            )
          }
          intersectLine(t, e) {
            void 0 === e && (console.warn('THREE.Plane: .intersectLine() target is now required'), (e = new ei()))
            const n = t.delta(rr),
              i = this.normal.dot(n)
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null
            const r = -(t.start.dot(this.normal) + this.constant) / i
            return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end)
            return (e < 0 && n > 0) || (n < 0 && e > 0)
          }
          intersectsBox(t) {
            return t.intersectsPlane(this)
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this)
          }
          coplanarPoint(t) {
            return (
              void 0 === t && (console.warn('THREE.Plane: .coplanarPoint() target is now required'), (t = new ei())),
              t.copy(this.normal).multiplyScalar(-this.constant)
            )
          }
          applyMatrix4(t, e) {
            const n = e || or.getNormalMatrix(t),
              i = this.coplanarPoint(rr).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize()
            return (this.constant = -i.dot(r)), this
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        ar.prototype.isPlane = !0
        const lr = new ei(),
          cr = new ei(),
          hr = new ei(),
          ur = new ei(),
          dr = new ei(),
          pr = new ei(),
          mr = new ei(),
          fr = new ei(),
          gr = new ei(),
          vr = new ei()
        class yr {
          constructor(t = new ei(), e = new ei(), n = new ei()) {
            ;(this.a = t), (this.b = e), (this.c = n)
          }
          static getNormal(t, e, n, i) {
            void 0 === i && (console.warn('THREE.Triangle: .getNormal() target is now required'), (i = new ei())),
              i.subVectors(n, e),
              lr.subVectors(t, e),
              i.cross(lr)
            const r = i.lengthSq()
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
          }
          static getBarycoord(t, e, n, i, r) {
            lr.subVectors(i, e), cr.subVectors(n, e), hr.subVectors(t, e)
            const s = lr.dot(lr),
              o = lr.dot(cr),
              a = lr.dot(hr),
              l = cr.dot(cr),
              c = cr.dot(hr),
              h = s * l - o * o
            if (
              (void 0 === r && (console.warn('THREE.Triangle: .getBarycoord() target is now required'), (r = new ei())),
              0 === h)
            )
              return r.set(-2, -1, -1)
            const u = 1 / h,
              d = (l * a - o * c) * u,
              p = (s * c - o * a) * u
            return r.set(1 - d - p, p, d)
          }
          static containsPoint(t, e, n, i) {
            return this.getBarycoord(t, e, n, i, ur), ur.x >= 0 && ur.y >= 0 && ur.x + ur.y <= 1
          }
          static getUV(t, e, n, i, r, s, o, a) {
            return (
              this.getBarycoord(t, e, n, i, ur),
              a.set(0, 0),
              a.addScaledVector(r, ur.x),
              a.addScaledVector(s, ur.y),
              a.addScaledVector(o, ur.z),
              a
            )
          }
          static isFrontFacing(t, e, n, i) {
            return lr.subVectors(n, e), cr.subVectors(t, e), lr.cross(cr).dot(i) < 0
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
          }
          setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
          }
          getArea() {
            return lr.subVectors(this.c, this.b), cr.subVectors(this.a, this.b), 0.5 * lr.cross(cr).length()
          }
          getMidpoint(t) {
            return (
              void 0 === t && (console.warn('THREE.Triangle: .getMidpoint() target is now required'), (t = new ei())),
              t
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            )
          }
          getNormal(t) {
            return yr.getNormal(this.a, this.b, this.c, t)
          }
          getPlane(t) {
            return (
              void 0 === t && (console.warn('THREE.Triangle: .getPlane() target is now required'), (t = new ar())),
              t.setFromCoplanarPoints(this.a, this.b, this.c)
            )
          }
          getBarycoord(t, e) {
            return yr.getBarycoord(t, this.a, this.b, this.c, e)
          }
          getUV(t, e, n, i, r) {
            return yr.getUV(t, this.a, this.b, this.c, e, n, i, r)
          }
          containsPoint(t) {
            return yr.containsPoint(t, this.a, this.b, this.c)
          }
          isFrontFacing(t) {
            return yr.isFrontFacing(this.a, this.b, this.c, t)
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this)
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn('THREE.Triangle: .closestPointToPoint() target is now required'), (e = new ei()))
            const n = this.a,
              i = this.b,
              r = this.c
            let s, o
            dr.subVectors(i, n), pr.subVectors(r, n), fr.subVectors(t, n)
            const a = dr.dot(fr),
              l = pr.dot(fr)
            if (a <= 0 && l <= 0) return e.copy(n)
            gr.subVectors(t, i)
            const c = dr.dot(gr),
              h = pr.dot(gr)
            if (c >= 0 && h <= c) return e.copy(i)
            const u = a * h - c * l
            if (u <= 0 && a >= 0 && c <= 0) return (s = a / (a - c)), e.copy(n).addScaledVector(dr, s)
            vr.subVectors(t, r)
            const d = dr.dot(vr),
              p = pr.dot(vr)
            if (p >= 0 && d <= p) return e.copy(r)
            const m = d * l - a * p
            if (m <= 0 && l >= 0 && p <= 0) return (o = l / (l - p)), e.copy(n).addScaledVector(pr, o)
            const f = c * p - d * h
            if (f <= 0 && h - c >= 0 && d - p >= 0)
              return mr.subVectors(r, i), (o = (h - c) / (h - c + (d - p))), e.copy(i).addScaledVector(mr, o)
            const g = 1 / (f + m + u)
            return (s = m * g), (o = u * g), e.copy(n).addScaledVector(dr, s).addScaledVector(pr, o)
          }
          equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
          }
        }
        let xr = 0
        function br() {
          Object.defineProperty(this, 'id', { value: xr++ }),
            (this.uuid = Vn.generateUUID()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.fog = !0),
            (this.blending = T),
            (this.side = y),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = z),
            (this.blendDst = k),
            (this.blendEquation = R),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = Y),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Ln),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = mn),
            (this.stencilZFail = mn),
            (this.stencilZPass = mn),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0)
        }
        ;(br.prototype = Object.assign(Object.create(Un.prototype), {
          constructor: br,
          isMaterial: !0,
          onBeforeCompile: function () {},
          customProgramCacheKey: function () {
            return this.onBeforeCompile.toString()
          },
          setValues: function (t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e]
                if (void 0 === n) {
                  console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                  continue
                }
                if ('shading' === e) {
                  console.warn(
                    'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.'
                  ),
                    (this.flatShading = n === w)
                  continue
                }
                const i = this[e]
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn('THREE.' + this.type + ": '" + e + "' is not a property of this material.")
              }
          },
          toJSON: function (t) {
            const e = void 0 === t || 'string' == typeof t
            e && (t = { textures: {}, images: {} })
            const n = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } }
            function i(t) {
              const e = []
              for (const n in t) {
                const i = t[n]
                delete i.metadata, e.push(i)
              }
              return e
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              '' !== this.name && (n.name = this.name),
              this.color && this.color.isColor && (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
              this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
              this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
              this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid), (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                (n.reflectivity = this.reflectivity),
                (n.refractionRatio = this.refractionRatio),
                void 0 !== this.combine && (n.combine = this.combine),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
              this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
              this.blending !== T && (n.blending = this.blending),
              this.side !== y && (n.side = this.side),
              this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = this.transparent),
              (n.depthFunc = this.depthFunc),
              (n.depthTest = this.depthTest),
              (n.depthWrite = this.depthWrite),
              (n.colorWrite = this.colorWrite),
              (n.stencilWrite = this.stencilWrite),
              (n.stencilWriteMask = this.stencilWriteMask),
              (n.stencilFunc = this.stencilFunc),
              (n.stencilRef = this.stencilRef),
              (n.stencilFuncMask = this.stencilFuncMask),
              (n.stencilFail = this.stencilFail),
              (n.stencilZFail = this.stencilZFail),
              (n.stencilZPass = this.stencilZPass),
              this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
              this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.wireframe && (n.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
              'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
              'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.morphTargets && (n.morphTargets = !0),
              !0 === this.morphNormals && (n.morphNormals = !0),
              !0 === this.skinning && (n.skinning = !0),
              !0 === this.flatShading && (n.flatShading = this.flatShading),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images)
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
            }
            return n
          },
          clone: function () {
            return new this.constructor().copy(this)
          },
          copy: function (t) {
            ;(this.name = t.name),
              (this.fog = t.fog),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite)
            const e = t.clippingPlanes
            let n = null
            if (null !== e) {
              const t = e.length
              n = new Array(t)
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            )
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' })
          }
        })),
          Object.defineProperty(br.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++
            }
          })
        const wr = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
          },
          _r = { h: 0, s: 0, l: 0 },
          Mr = { h: 0, s: 0, l: 0 }
        function Tr(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < 0.5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
          )
        }
        function Sr(t) {
          return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
        }
        function Er(t) {
          return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
        }
        class Ar {
          constructor(t, e, n) {
            return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
          }
          set(t) {
            return (
              t && t.isColor
                ? this.copy(t)
                : 'number' == typeof t
                ? this.setHex(t)
                : 'string' == typeof t && this.setStyle(t),
              this
            )
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this
          }
          setHex(t) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              this
            )
          }
          setRGB(t, e, n) {
            return (this.r = t), (this.g = e), (this.b = n), this
          }
          setHSL(t, e, n) {
            if (((t = Vn.euclideanModulo(t, 1)), (e = Vn.clamp(e, 0, 1)), (n = Vn.clamp(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i
              ;(this.r = Tr(r, i, t + 1 / 3)), (this.g = Tr(r, i, t)), (this.b = Tr(r, i, t - 1 / 3))
            }
            return this
          }
          setStyle(t) {
            function e(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn('THREE.Color: Alpha component of ' + t + ' will be ignored.')
            }
            let n
            if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
              let t
              const i = n[1],
                r = n[2]
              switch (i) {
                case 'rgb':
                case 'rgba':
                  if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                    return (
                      (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                      e(t[4]),
                      this
                    )
                  if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)))
                    return (
                      (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                      e(t[4]),
                      this
                    )
                  break
                case 'hsl':
                case 'hsla':
                  if ((t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))) {
                    const n = parseFloat(t[1]) / 360,
                      i = parseInt(t[2], 10) / 100,
                      r = parseInt(t[3], 10) / 100
                    return e(t[4]), this.setHSL(n, i, r)
                  }
              }
            } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const t = n[1],
                e = t.length
              if (3 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                  (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                  (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                  this
                )
              if (6 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                  (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                  (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                  this
                )
            }
            return t && t.length > 0 ? this.setColorName(t) : this
          }
          setColorName(t) {
            const e = wr[t]
            return void 0 !== e ? this.setHex(e) : console.warn('THREE.Color: Unknown color ' + t), this
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b)
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
          }
          copyGammaToLinear(t, e = 2) {
            return (this.r = Math.pow(t.r, e)), (this.g = Math.pow(t.g, e)), (this.b = Math.pow(t.b, e)), this
          }
          copyLinearToGamma(t, e = 2) {
            const n = e > 0 ? 1 / e : 1
            return (this.r = Math.pow(t.r, n)), (this.g = Math.pow(t.g, n)), (this.b = Math.pow(t.b, n)), this
          }
          convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t), this
          }
          convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t), this
          }
          copySRGBToLinear(t) {
            return (this.r = Sr(t.r)), (this.g = Sr(t.g)), (this.b = Sr(t.b)), this
          }
          copyLinearToSRGB(t) {
            return (this.r = Er(t.r)), (this.g = Er(t.g)), (this.b = Er(t.b)), this
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
          }
          getHex() {
            return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
          }
          getHexString() {
            return ('000000' + this.getHex().toString(16)).slice(-6)
          }
          getHSL(t) {
            void 0 === t && (console.warn('THREE.Color: .getHSL() target is now required'), (t = { h: 0, s: 0, l: 0 }))
            const e = this.r,
              n = this.g,
              i = this.b,
              r = Math.max(e, n, i),
              s = Math.min(e, n, i)
            let o, a
            const l = (s + r) / 2
            if (s === r) (o = 0), (a = 0)
            else {
              const t = r - s
              switch (((a = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
                case e:
                  o = (n - i) / t + (n < i ? 6 : 0)
                  break
                case n:
                  o = (i - e) / t + 2
                  break
                case i:
                  o = (e - n) / t + 4
              }
              o /= 6
            }
            return (t.h = o), (t.s = a), (t.l = l), t
          }
          getStyle() {
            return 'rgb(' + ((255 * this.r) | 0) + ',' + ((255 * this.g) | 0) + ',' + ((255 * this.b) | 0) + ')'
          }
          offsetHSL(t, e, n) {
            return this.getHSL(_r), (_r.h += t), (_r.s += e), (_r.l += n), this.setHSL(_r.h, _r.s, _r.l), this
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
          }
          addColors(t, e) {
            return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            )
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this
          }
          lerp(t, e) {
            return (this.r += (t.r - this.r) * e), (this.g += (t.g - this.g) * e), (this.b += (t.b - this.b) * e), this
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n), (this.g = t.g + (e.g - t.g) * n), (this.b = t.b + (e.b - t.b) * n), this
            )
          }
          lerpHSL(t, e) {
            this.getHSL(_r), t.getHSL(Mr)
            const n = Vn.lerp(_r.h, Mr.h, e),
              i = Vn.lerp(_r.s, Mr.s, e),
              r = Vn.lerp(_r.l, Mr.l, e)
            return this.setHSL(n, i, r), this
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
          }
          fromArray(t, e = 0) {
            return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
              this
            )
          }
          toJSON() {
            return this.getHex()
          }
        }
        ;(Ar.NAMES = wr), (Ar.prototype.isColor = !0), (Ar.prototype.r = 1), (Ar.prototype.g = 1), (Ar.prototype.b = 1)
        class Lr extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshBasicMaterial'),
              (this.color = new Ar(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              this
            )
          }
        }
        Lr.prototype.isMeshBasicMaterial = !0
        const Rr = new ei(),
          Pr = new Wn()
        function Cr(t, e, n) {
          if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')
          ;(this.name = ''),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === n),
            (this.usage = Rn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0)
        }
        function Ir(t, e, n) {
          Cr.call(this, new Int8Array(t), e, n)
        }
        function Dr(t, e, n) {
          Cr.call(this, new Uint8Array(t), e, n)
        }
        function Or(t, e, n) {
          Cr.call(this, new Uint8ClampedArray(t), e, n)
        }
        function Nr(t, e, n) {
          Cr.call(this, new Int16Array(t), e, n)
        }
        function Br(t, e, n) {
          Cr.call(this, new Uint16Array(t), e, n)
        }
        function Fr(t, e, n) {
          Cr.call(this, new Int32Array(t), e, n)
        }
        function zr(t, e, n) {
          Cr.call(this, new Uint32Array(t), e, n)
        }
        function kr(t, e, n) {
          Cr.call(this, new Uint16Array(t), e, n)
        }
        function Ur(t, e, n) {
          Cr.call(this, new Float32Array(t), e, n)
        }
        function Hr(t, e, n) {
          Cr.call(this, new Float64Array(t), e, n)
        }
        function Gr(t) {
          if (0 === t.length) return -1 / 0
          let e = t[0]
          for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n])
          return e
        }
        Object.defineProperty(Cr.prototype, 'needsUpdate', {
          set: function (t) {
            !0 === t && this.version++
          }
        }),
          Object.assign(Cr.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
              return (this.usage = t), this
            },
            copy: function (t) {
              return (
                (this.name = t.name),
                (this.array = new t.array.constructor(t.array)),
                (this.itemSize = t.itemSize),
                (this.count = t.count),
                (this.normalized = t.normalized),
                (this.usage = t.usage),
                this
              )
            },
            copyAt: function (t, e, n) {
              ;(t *= this.itemSize), (n *= e.itemSize)
              for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i]
              return this
            },
            copyArray: function (t) {
              return this.array.set(t), this
            },
            copyColorsArray: function (t) {
              const e = this.array
              let n = 0
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i]
                void 0 === r &&
                  (console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i), (r = new Ar())),
                  (e[n++] = r.r),
                  (e[n++] = r.g),
                  (e[n++] = r.b)
              }
              return this
            },
            copyVector2sArray: function (t) {
              const e = this.array
              let n = 0
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i]
                void 0 === r &&
                  (console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i), (r = new Wn())),
                  (e[n++] = r.x),
                  (e[n++] = r.y)
              }
              return this
            },
            copyVector3sArray: function (t) {
              const e = this.array
              let n = 0
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i]
                void 0 === r &&
                  (console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i), (r = new ei())),
                  (e[n++] = r.x),
                  (e[n++] = r.y),
                  (e[n++] = r.z)
              }
              return this
            },
            copyVector4sArray: function (t) {
              const e = this.array
              let n = 0
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i]
                void 0 === r &&
                  (console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i), (r = new Kn())),
                  (e[n++] = r.x),
                  (e[n++] = r.y),
                  (e[n++] = r.z),
                  (e[n++] = r.w)
              }
              return this
            },
            applyMatrix3: function (t) {
              if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                  Pr.fromBufferAttribute(this, e), Pr.applyMatrix3(t), this.setXY(e, Pr.x, Pr.y)
              else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                  Rr.fromBufferAttribute(this, e), Rr.applyMatrix3(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z)
              return this
            },
            applyMatrix4: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Rr.x = this.getX(e)),
                  (Rr.y = this.getY(e)),
                  (Rr.z = this.getZ(e)),
                  Rr.applyMatrix4(t),
                  this.setXYZ(e, Rr.x, Rr.y, Rr.z)
              return this
            },
            applyNormalMatrix: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Rr.x = this.getX(e)),
                  (Rr.y = this.getY(e)),
                  (Rr.z = this.getZ(e)),
                  Rr.applyNormalMatrix(t),
                  this.setXYZ(e, Rr.x, Rr.y, Rr.z)
              return this
            },
            transformDirection: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Rr.x = this.getX(e)),
                  (Rr.y = this.getY(e)),
                  (Rr.z = this.getZ(e)),
                  Rr.transformDirection(t),
                  this.setXYZ(e, Rr.x, Rr.y, Rr.z)
              return this
            },
            set: function (t, e = 0) {
              return this.array.set(t, e), this
            },
            getX: function (t) {
              return this.array[t * this.itemSize]
            },
            setX: function (t, e) {
              return (this.array[t * this.itemSize] = e), this
            },
            getY: function (t) {
              return this.array[t * this.itemSize + 1]
            },
            setY: function (t, e) {
              return (this.array[t * this.itemSize + 1] = e), this
            },
            getZ: function (t) {
              return this.array[t * this.itemSize + 2]
            },
            setZ: function (t, e) {
              return (this.array[t * this.itemSize + 2] = e), this
            },
            getW: function (t) {
              return this.array[t * this.itemSize + 3]
            },
            setW: function (t, e) {
              return (this.array[t * this.itemSize + 3] = e), this
            },
            setXY: function (t, e, n) {
              return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), this
            },
            setXYZ: function (t, e, n, i) {
              return (
                (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), (this.array[t + 2] = i), this
              )
            },
            setXYZW: function (t, e, n, i, r) {
              return (
                (t *= this.itemSize),
                (this.array[t + 0] = e),
                (this.array[t + 1] = n),
                (this.array[t + 2] = i),
                (this.array[t + 3] = r),
                this
              )
            },
            onUpload: function (t) {
              return (this.onUploadCallback = t), this
            },
            clone: function () {
              return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function () {
              const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
              }
              return (
                '' !== this.name && (t.name = this.name),
                this.usage !== Rn && (t.usage = this.usage),
                (0 === this.updateRange.offset && -1 === this.updateRange.count) || (t.updateRange = this.updateRange),
                t
              )
            }
          }),
          (Ir.prototype = Object.create(Cr.prototype)),
          (Ir.prototype.constructor = Ir),
          (Dr.prototype = Object.create(Cr.prototype)),
          (Dr.prototype.constructor = Dr),
          (Or.prototype = Object.create(Cr.prototype)),
          (Or.prototype.constructor = Or),
          (Nr.prototype = Object.create(Cr.prototype)),
          (Nr.prototype.constructor = Nr),
          (Br.prototype = Object.create(Cr.prototype)),
          (Br.prototype.constructor = Br),
          (Fr.prototype = Object.create(Cr.prototype)),
          (Fr.prototype.constructor = Fr),
          (zr.prototype = Object.create(Cr.prototype)),
          (zr.prototype.constructor = zr),
          (kr.prototype = Object.create(Cr.prototype)),
          (kr.prototype.constructor = kr),
          (kr.prototype.isFloat16BufferAttribute = !0),
          (Ur.prototype = Object.create(Cr.prototype)),
          (Ur.prototype.constructor = Ur),
          (Hr.prototype = Object.create(Cr.prototype)),
          (Hr.prototype.constructor = Hr)
        const Vr = {
          Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array
        }
        function Wr(t, e) {
          return new Vr[t](e)
        }
        let jr = 0
        const qr = new Ii(),
          Xr = new ir(),
          Yr = new ei(),
          Zr = new ri(),
          Jr = new ri(),
          Kr = new ei()
        function Qr() {
          Object.defineProperty(this, 'id', { value: jr++ }),
            (this.uuid = Vn.generateUUID()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {})
        }
        Qr.prototype = Object.assign(Object.create(Un.prototype), {
          constructor: Qr,
          isBufferGeometry: !0,
          getIndex: function () {
            return this.index
          },
          setIndex: function (t) {
            return Array.isArray(t) ? (this.index = new (Gr(t) > 65535 ? zr : Br)(t, 1)) : (this.index = t), this
          },
          getAttribute: function (t) {
            return this.attributes[t]
          },
          setAttribute: function (t, e) {
            return (this.attributes[t] = e), this
          },
          deleteAttribute: function (t) {
            return delete this.attributes[t], this
          },
          hasAttribute: function (t) {
            return void 0 !== this.attributes[t]
          },
          addGroup: function (t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n })
          },
          clearGroups: function () {
            this.groups = []
          },
          setDrawRange: function (t, e) {
            ;(this.drawRange.start = t), (this.drawRange.count = e)
          },
          applyMatrix4: function (t) {
            const e = this.attributes.position
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
            const n = this.attributes.normal
            if (void 0 !== n) {
              const e = new jn().getNormalMatrix(t)
              n.applyNormalMatrix(e), (n.needsUpdate = !0)
            }
            const i = this.attributes.tangent
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            )
          },
          rotateX: function (t) {
            return qr.makeRotationX(t), this.applyMatrix4(qr), this
          },
          rotateY: function (t) {
            return qr.makeRotationY(t), this.applyMatrix4(qr), this
          },
          rotateZ: function (t) {
            return qr.makeRotationZ(t), this.applyMatrix4(qr), this
          },
          translate: function (t, e, n) {
            return qr.makeTranslation(t, e, n), this.applyMatrix4(qr), this
          },
          scale: function (t, e, n) {
            return qr.makeScale(t, e, n), this.applyMatrix4(qr), this
          },
          lookAt: function (t) {
            return Xr.lookAt(t), Xr.updateMatrix(), this.applyMatrix4(Xr.matrix), this
          },
          center: function () {
            return (
              this.computeBoundingBox(), this.boundingBox.getCenter(Yr).negate(), this.translate(Yr.x, Yr.y, Yr.z), this
            )
          },
          setFromPoints: function (t) {
            const e = []
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n]
              e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute('position', new Ur(e, 3)), this
          },
          computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ri())
            const t = this.attributes.position,
              e = this.morphAttributes.position
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(new ei(-1 / 0, -1 / 0, -1 / 0), new ei(1 / 0, 1 / 0, 1 / 0))
              )
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t]
                  Zr.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Kr.addVectors(this.boundingBox.min, Zr.min),
                        this.boundingBox.expandByPoint(Kr),
                        Kr.addVectors(this.boundingBox.max, Zr.max),
                        this.boundingBox.expandByPoint(Kr))
                      : (this.boundingBox.expandByPoint(Zr.min), this.boundingBox.expandByPoint(Zr.max))
                }
            } else this.boundingBox.makeEmpty()
            ;(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              )
          },
          computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Mi())
            const t = this.attributes.position,
              e = this.morphAttributes.position
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new ei(), 1 / 0)
              )
            if (t) {
              const n = this.boundingSphere.center
              if ((Zr.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t]
                  Jr.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Kr.addVectors(Zr.min, Jr.min),
                        Zr.expandByPoint(Kr),
                        Kr.addVectors(Zr.max, Jr.max),
                        Zr.expandByPoint(Kr))
                      : (Zr.expandByPoint(Jr.min), Zr.expandByPoint(Jr.max))
                }
              Zr.getCenter(n)
              let i = 0
              for (let e = 0, r = t.count; e < r; e++)
                Kr.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(Kr)))
              if (e)
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r],
                    o = this.morphTargetsRelative
                  for (let e = 0, r = s.count; e < r; e++)
                    Kr.fromBufferAttribute(s, e),
                      o && (Yr.fromBufferAttribute(t, e), Kr.add(Yr)),
                      (i = Math.max(i, n.distanceToSquared(Kr)))
                }
              ;(this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  )
            }
          },
          computeFaceNormals: function () {},
          computeTangents: function () {
            const t = this.index,
              e = this.attributes
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
              return void console.error(
                'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
              )
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              s = e.uv.array,
              o = i.length / 3
            void 0 === e.tangent && this.setAttribute('tangent', new Cr(new Float32Array(4 * o), 4))
            const a = e.tangent.array,
              l = [],
              c = []
            for (let t = 0; t < o; t++) (l[t] = new ei()), (c[t] = new ei())
            const h = new ei(),
              u = new ei(),
              d = new ei(),
              p = new Wn(),
              m = new Wn(),
              f = new Wn(),
              g = new ei(),
              v = new ei()
            function y(t, e, n) {
              h.fromArray(i, 3 * t),
                u.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                m.fromArray(s, 2 * e),
                f.fromArray(s, 2 * n),
                u.sub(h),
                d.sub(h),
                m.sub(p),
                f.sub(p)
              const r = 1 / (m.x * f.y - f.x * m.y)
              isFinite(r) &&
                (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r),
                v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(v),
                c[e].add(v),
                c[n].add(v))
            }
            let x = this.groups
            0 === x.length && (x = [{ start: 0, count: n.length }])
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start
              for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
            }
            const b = new ei(),
              w = new ei(),
              _ = new ei(),
              M = new ei()
            function T(t) {
              _.fromArray(r, 3 * t), M.copy(_)
              const e = l[t]
              b.copy(e), b.sub(_.multiplyScalar(_.dot(e))).normalize(), w.crossVectors(M, e)
              const n = w.dot(c[t]) < 0 ? -1 : 1
              ;(a[4 * t] = b.x), (a[4 * t + 1] = b.y), (a[4 * t + 2] = b.z), (a[4 * t + 3] = n)
            }
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start
              for (let t = i, r = i + e.count; t < r; t += 3) T(n[t + 0]), T(n[t + 1]), T(n[t + 2])
            }
          },
          computeVertexNormals: function () {
            const t = this.index,
              e = this.getAttribute('position')
            if (void 0 !== e) {
              let n = this.getAttribute('normal')
              if (void 0 === n) (n = new Cr(new Float32Array(3 * e.count), 3)), this.setAttribute('normal', n)
              else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0)
              const i = new ei(),
                r = new ei(),
                s = new ei(),
                o = new ei(),
                a = new ei(),
                l = new ei(),
                c = new ei(),
                h = new ei()
              if (t)
                for (let u = 0, d = t.count; u < d; u += 3) {
                  const d = t.getX(u + 0),
                    p = t.getX(u + 1),
                    m = t.getX(u + 2)
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    s.fromBufferAttribute(e, m),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    o.fromBufferAttribute(n, d),
                    a.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, m),
                    o.add(c),
                    a.add(c),
                    l.add(c),
                    n.setXYZ(d, o.x, o.y, o.z),
                    n.setXYZ(p, a.x, a.y, a.z),
                    n.setXYZ(m, l.x, l.y, l.z)
                }
              else
                for (let t = 0, o = e.count; t < o; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z)
              this.normalizeNormals(), (n.needsUpdate = !0)
            }
          },
          merge: function (t, e) {
            if (!t || !t.isBufferGeometry)
              return void console.error(
                'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
                t
              )
            void 0 === e &&
              ((e = 0),
              console.warn(
                'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
              ))
            const n = this.attributes
            for (const i in n) {
              if (void 0 === t.attributes[i]) continue
              const r = n[i].array,
                s = t.attributes[i],
                o = s.array,
                a = s.itemSize * e,
                l = Math.min(o.length, r.length - a)
              for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
            }
            return this
          },
          normalizeNormals: function () {
            const t = this.attributes.normal
            for (let e = 0, n = t.count; e < n; e++)
              Kr.fromBufferAttribute(t, e), Kr.normalize(), t.setXYZ(e, Kr.x, Kr.y, Kr.z)
          },
          toNonIndexed: function () {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                s = new n.constructor(e.length * i)
              let o = 0,
                a = 0
              for (let t = 0, r = e.length; t < r; t++) {
                o = e[t] * i
                for (let t = 0; t < i; t++) s[a++] = n[o++]
              }
              return new Cr(s, i, r)
            }
            if (null === this.index)
              return console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'), this
            const e = new Qr(),
              n = this.index.array,
              i = this.attributes
            for (const r in i) {
              const s = t(i[r], n)
              e.setAttribute(r, s)
            }
            const r = this.morphAttributes
            for (const i in r) {
              const s = [],
                o = r[i]
              for (let e = 0, i = o.length; e < i; e++) {
                const i = t(o[e], n)
                s.push(i)
              }
              e.morphAttributes[i] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative
            const s = this.groups
            for (let t = 0, n = s.length; t < n; t++) {
              const n = s[t]
              e.addGroup(n.start, n.count, n.materialIndex)
            }
            return e
          },
          toJSON: function () {
            const t = { metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } }
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              '' !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 && (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters
              for (const n in e) void 0 !== e[n] && (t[n] = e[n])
              return t
            }
            t.data = { attributes: {} }
            const e = this.index
            null !== e &&
              (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) })
            const n = this.attributes
            for (const e in n) {
              const i = n[e]
              t.data.attributes[e] = i.toJSON(t.data)
            }
            const i = {}
            let r = !1
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                s = []
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e]
                s.push(i.toJSON(t.data))
              }
              s.length > 0 && ((i[e] = s), (r = !0))
            }
            r && ((t.data.morphAttributes = i), (t.data.morphTargetsRelative = this.morphTargetsRelative))
            const s = this.groups
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)))
            const o = this.boundingSphere
            return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t
          },
          clone: function () {
            return new Qr().copy(this)
          },
          copy: function (t) {
            ;(this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null)
            const e = {}
            this.name = t.name
            const n = t.index
            null !== n && this.setIndex(n.clone(e))
            const i = t.attributes
            for (const t in i) {
              const n = i[t]
              this.setAttribute(t, n.clone(e))
            }
            const r = t.morphAttributes
            for (const t in r) {
              const n = [],
                i = r[t]
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e))
              this.morphAttributes[t] = n
            }
            this.morphTargetsRelative = t.morphTargetsRelative
            const s = t.groups
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t]
              this.addGroup(e.start, e.count, e.materialIndex)
            }
            const o = t.boundingBox
            null !== o && (this.boundingBox = o.clone())
            const a = t.boundingSphere
            return (
              null !== a && (this.boundingSphere = a.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            )
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' })
          }
        })
        const $r = new Ii(),
          ts = new Ci(),
          es = new Mi(),
          ns = new ei(),
          is = new ei(),
          rs = new ei(),
          ss = new ei(),
          os = new ei(),
          as = new ei(),
          ls = new ei(),
          cs = new ei(),
          hs = new ei(),
          us = new Wn(),
          ds = new Wn(),
          ps = new Wn(),
          ms = new ei(),
          fs = new ei()
        function gs(t = new Qr(), e = new Lr()) {
          ir.call(this), (this.type = 'Mesh'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        function vs(t, e, n, i, r, s, o, a, l, c, h, u) {
          ns.fromBufferAttribute(r, c), is.fromBufferAttribute(r, h), rs.fromBufferAttribute(r, u)
          const d = t.morphTargetInfluences
          if (e.morphTargets && s && d) {
            ls.set(0, 0, 0), cs.set(0, 0, 0), hs.set(0, 0, 0)
            for (let t = 0, e = s.length; t < e; t++) {
              const e = d[t],
                n = s[t]
              0 !== e &&
                (ss.fromBufferAttribute(n, c),
                os.fromBufferAttribute(n, h),
                as.fromBufferAttribute(n, u),
                o
                  ? (ls.addScaledVector(ss, e), cs.addScaledVector(os, e), hs.addScaledVector(as, e))
                  : (ls.addScaledVector(ss.sub(ns), e),
                    cs.addScaledVector(os.sub(is), e),
                    hs.addScaledVector(as.sub(rs), e)))
            }
            ns.add(ls), is.add(cs), rs.add(hs)
          }
          t.isSkinnedMesh && e.skinning && (t.boneTransform(c, ns), t.boneTransform(h, is), t.boneTransform(u, rs))
          const p = (function (t, e, n, i, r, s, o, a) {
            let l
            if (
              ((l = e.side === x ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side !== b, a)),
              null === l)
            )
              return null
            fs.copy(a), fs.applyMatrix4(t.matrixWorld)
            const c = n.ray.origin.distanceTo(fs)
            return c < n.near || c > n.far ? null : { distance: c, point: fs.clone(), object: t }
          })(t, e, n, i, ns, is, rs, ms)
          if (p) {
            a &&
              (us.fromBufferAttribute(a, c),
              ds.fromBufferAttribute(a, h),
              ps.fromBufferAttribute(a, u),
              (p.uv = yr.getUV(ms, ns, is, rs, us, ds, ps, new Wn()))),
              l &&
                (us.fromBufferAttribute(l, c),
                ds.fromBufferAttribute(l, h),
                ps.fromBufferAttribute(l, u),
                (p.uv2 = yr.getUV(ms, ns, is, rs, us, ds, ps, new Wn())))
            const t = { a: c, b: h, c: u, normal: new ei(), materialIndex: 0 }
            yr.getNormal(ns, is, rs, t.normal), (p.face = t)
          }
          return p
        }
        gs.prototype = Object.assign(Object.create(ir.prototype), {
          constructor: gs,
          isMesh: !0,
          copy: function (t) {
            return (
              ir.prototype.copy.call(this, t),
              void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            )
          },
          updateMorphTargets: function () {
            const t = this.geometry
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e)
              if (n.length > 0) {
                const t = e[n[0]]
                if (void 0 !== t) {
                  ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e)
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
                  }
                }
              }
            } else {
              const e = t.morphTargets
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
            }
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld
            if (void 0 === i) return
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              es.copy(n.boundingSphere),
              es.applyMatrix4(r),
              !1 === t.ray.intersectsSphere(es))
            )
              return
            if (
              ($r.copy(r).invert(),
              ts.copy(t.ray).applyMatrix4($r),
              null !== n.boundingBox && !1 === ts.intersectsBox(n.boundingBox))
            )
              return
            let s
            if (n.isBufferGeometry) {
              const r = n.index,
                o = n.attributes.position,
                a = n.morphAttributes.position,
                l = n.morphTargetsRelative,
                c = n.attributes.uv,
                h = n.attributes.uv2,
                u = n.groups,
                d = n.drawRange
              if (null !== r)
                if (Array.isArray(i))
                  for (let n = 0, p = u.length; n < p; n++) {
                    const p = u[n],
                      m = i[p.materialIndex]
                    for (
                      let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count);
                      n < i;
                      n += 3
                    ) {
                      const i = r.getX(n),
                        u = r.getX(n + 1),
                        d = r.getX(n + 2)
                      ;(s = vs(this, m, t, ts, o, a, l, c, h, i, u, d)),
                        s && ((s.faceIndex = Math.floor(n / 3)), (s.face.materialIndex = p.materialIndex), e.push(s))
                    }
                  }
                else
                  for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                    const u = r.getX(n),
                      d = r.getX(n + 1),
                      p = r.getX(n + 2)
                    ;(s = vs(this, i, t, ts, o, a, l, c, h, u, d, p)),
                      s && ((s.faceIndex = Math.floor(n / 3)), e.push(s))
                  }
              else if (void 0 !== o)
                if (Array.isArray(i))
                  for (let n = 0, r = u.length; n < r; n++) {
                    const r = u[n],
                      p = i[r.materialIndex]
                    for (
                      let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count);
                      n < i;
                      n += 3
                    )
                      (s = vs(this, p, t, ts, o, a, l, c, h, n, n + 1, n + 2)),
                        s && ((s.faceIndex = Math.floor(n / 3)), (s.face.materialIndex = r.materialIndex), e.push(s))
                  }
                else
                  for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3)
                    (s = vs(this, i, t, ts, o, a, l, c, h, n, n + 1, n + 2)),
                      s && ((s.faceIndex = Math.floor(n / 3)), e.push(s))
            } else
              n.isGeometry &&
                console.error(
                  'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
          }
        })
        class ys extends Qr {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(),
              (this.type = 'BoxGeometry'),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s
              })
            const o = this
            ;(i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s))
            const a = [],
              l = [],
              c = [],
              h = []
            let u = 0,
              d = 0
            function p(t, e, n, i, r, s, p, m, f, g, v) {
              const y = s / f,
                x = p / g,
                b = s / 2,
                w = p / 2,
                _ = m / 2,
                M = f + 1,
                T = g + 1
              let S = 0,
                E = 0
              const A = new ei()
              for (let s = 0; s < T; s++) {
                const o = s * x - w
                for (let a = 0; a < M; a++) {
                  const u = a * y - b
                  ;(A[t] = u * i),
                    (A[e] = o * r),
                    (A[n] = _),
                    l.push(A.x, A.y, A.z),
                    (A[t] = 0),
                    (A[e] = 0),
                    (A[n] = m > 0 ? 1 : -1),
                    c.push(A.x, A.y, A.z),
                    h.push(a / f),
                    h.push(1 - s / g),
                    (S += 1)
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < f; e++) {
                  const n = u + e + M * t,
                    i = u + e + M * (t + 1),
                    r = u + (e + 1) + M * (t + 1),
                    s = u + (e + 1) + M * t
                  a.push(n, i, s), a.push(i, r, s), (E += 6)
                }
              o.addGroup(d, E, v), (d += E), (u += S)
            }
            p('z', 'y', 'x', -1, -1, n, e, t, s, r, 0),
              p('z', 'y', 'x', 1, -1, n, e, -t, s, r, 1),
              p('x', 'z', 'y', 1, 1, t, n, e, i, s, 2),
              p('x', 'z', 'y', 1, -1, t, n, -e, i, s, 3),
              p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
              p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
              this.setIndex(a),
              this.setAttribute('position', new Ur(l, 3)),
              this.setAttribute('normal', new Ur(c, 3)),
              this.setAttribute('uv', new Ur(h, 2))
          }
        }
        function xs(t) {
          const e = {}
          for (const n in t) {
            e[n] = {}
            for (const i in t[n]) {
              const r = t[n][i]
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r)
            }
          }
          return e
        }
        function bs(t) {
          const e = {}
          for (let n = 0; n < t.length; n++) {
            const i = xs(t[n])
            for (const t in i) e[t] = i[t]
          }
          return e
        }
        const ws = { clone: xs, merge: bs }
        function _s(t) {
          br.call(this),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
            (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.skinning = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
            (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
                ),
              this.setValues(t))
        }
        function Ms() {
          ir.call(this),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new Ii()),
            (this.projectionMatrix = new Ii()),
            (this.projectionMatrixInverse = new Ii())
        }
        function Ts(t = 50, e = 1, n = 0.1, i = 2e3) {
          Ms.call(this),
            (this.type = 'PerspectiveCamera'),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix()
        }
        ;(_s.prototype = Object.create(br.prototype)),
          (_s.prototype.constructor = _s),
          (_s.prototype.isShaderMaterial = !0),
          (_s.prototype.copy = function (t) {
            return (
              br.prototype.copy.call(this, t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = xs(t.uniforms)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            )
          }),
          (_s.prototype.toJSON = function (t) {
            const e = br.prototype.toJSON.call(this, t)
            ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value
              i && i.isTexture
                ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
                : i && i.isColor
                ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
                : i && i.isVector2
                ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
                : i && i.isVector3
                ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
                : i && i.isVector4
                ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
                : i && i.isMatrix3
                ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
                : i && i.isMatrix4
                ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
                : (e.uniforms[n] = { value: i })
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader)
            const n = {}
            for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0)
            return Object.keys(n).length > 0 && (e.extensions = n), e
          }),
          (Ms.prototype = Object.assign(Object.create(ir.prototype), {
            constructor: Ms,
            isCamera: !0,
            copy: function (t, e) {
              return (
                ir.prototype.copy.call(this, t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
              )
            },
            getWorldDirection: function (t) {
              void 0 === t &&
                (console.warn('THREE.Camera: .getWorldDirection() target is now required'), (t = new ei())),
                this.updateWorldMatrix(!0, !1)
              const e = this.matrixWorld.elements
              return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function (t) {
              ir.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            updateWorldMatrix: function (t, e) {
              ir.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            clone: function () {
              return new this.constructor().copy(this)
            }
          })),
          (Ts.prototype = Object.assign(Object.create(Ms.prototype), {
            constructor: Ts,
            isPerspectiveCamera: !0,
            copy: function (t, e) {
              return (
                Ms.prototype.copy.call(this, t, e),
                (this.fov = t.fov),
                (this.zoom = t.zoom),
                (this.near = t.near),
                (this.far = t.far),
                (this.focus = t.focus),
                (this.aspect = t.aspect),
                (this.view = null === t.view ? null : Object.assign({}, t.view)),
                (this.filmGauge = t.filmGauge),
                (this.filmOffset = t.filmOffset),
                this
              )
            },
            setFocalLength: function (t) {
              const e = (0.5 * this.getFilmHeight()) / t
              ;(this.fov = 2 * Vn.RAD2DEG * Math.atan(e)), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
              const t = Math.tan(0.5 * Vn.DEG2RAD * this.fov)
              return (0.5 * this.getFilmHeight()) / t
            },
            getEffectiveFOV: function () {
              return 2 * Vn.RAD2DEG * Math.atan(Math.tan(0.5 * Vn.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
              return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
              return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (t, e, n, i, r, s) {
              ;(this.aspect = t / e),
                null === this.view &&
                  (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                  }),
                (this.view.enabled = !0),
                (this.view.fullWidth = t),
                (this.view.fullHeight = e),
                (this.view.offsetX = n),
                (this.view.offsetY = i),
                (this.view.width = r),
                (this.view.height = s),
                this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
              null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
              const t = this.near
              let e = (t * Math.tan(0.5 * Vn.DEG2RAD * this.fov)) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -0.5 * i
              const s = this.view
              if (null !== this.view && this.view.enabled) {
                const t = s.fullWidth,
                  o = s.fullHeight
                ;(r += (s.offsetX * i) / t), (e -= (s.offsetY * n) / o), (i *= s.width / t), (n *= s.height / o)
              }
              const o = this.filmOffset
              0 !== o && (r += (t * o) / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            },
            toJSON: function (t) {
              const e = ir.prototype.toJSON.call(this, t)
              return (
                (e.object.fov = this.fov),
                (e.object.zoom = this.zoom),
                (e.object.near = this.near),
                (e.object.far = this.far),
                (e.object.focus = this.focus),
                (e.object.aspect = this.aspect),
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                (e.object.filmGauge = this.filmGauge),
                (e.object.filmOffset = this.filmOffset),
                e
              )
            }
          }))
        const Ss = 90
        class Es extends ir {
          constructor(t, e, n) {
            if ((super(), (this.type = 'CubeCamera'), !0 !== n.isWebGLCubeRenderTarget))
              return void console.error(
                'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.'
              )
            this.renderTarget = n
            const i = new Ts(Ss, 1, t, e)
            ;(i.layers = this.layers), i.up.set(0, -1, 0), i.lookAt(new ei(1, 0, 0)), this.add(i)
            const r = new Ts(Ss, 1, t, e)
            ;(r.layers = this.layers), r.up.set(0, -1, 0), r.lookAt(new ei(-1, 0, 0)), this.add(r)
            const s = new Ts(Ss, 1, t, e)
            ;(s.layers = this.layers), s.up.set(0, 0, 1), s.lookAt(new ei(0, 1, 0)), this.add(s)
            const o = new Ts(Ss, 1, t, e)
            ;(o.layers = this.layers), o.up.set(0, 0, -1), o.lookAt(new ei(0, -1, 0)), this.add(o)
            const a = new Ts(Ss, 1, t, e)
            ;(a.layers = this.layers), a.up.set(0, -1, 0), a.lookAt(new ei(0, 0, 1)), this.add(a)
            const l = new Ts(Ss, 1, t, e)
            ;(l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new ei(0, 0, -1)), this.add(l)
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld()
            const n = this.renderTarget,
              [i, r, s, o, a, l] = this.children,
              c = t.xr.enabled,
              h = t.getRenderTarget()
            t.xr.enabled = !1
            const u = n.texture.generateMipmaps
            ;(n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, i),
              t.setRenderTarget(n, 1),
              t.render(e, r),
              t.setRenderTarget(n, 2),
              t.render(e, s),
              t.setRenderTarget(n, 3),
              t.render(e, o),
              t.setRenderTarget(n, 4),
              t.render(e, a),
              (n.texture.generateMipmaps = u),
              t.setRenderTarget(n, 5),
              t.render(e, l),
              t.setRenderTarget(h),
              (t.xr.enabled = c)
          }
        }
        class As extends Zn {
          constructor(t, e, n, i, r, s, o, a, l, c) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : ct),
              n,
              i,
              r,
              s,
              (o = void 0 !== o ? o : Ht),
              a,
              l,
              c
            ),
              (this._needsFlipEnvMap = !0),
              (this.flipY = !1)
          }
          get images() {
            return this.image
          }
          set images(t) {
            this.image = t
          }
        }
        As.prototype.isCubeTexture = !0
        class Ls extends Qn {
          constructor(t, e, n) {
            Number.isInteger(e) &&
              (console.warn(
                'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )'
              ),
              (e = n)),
              super(t, t, e),
              (e = e || {}),
              (this.texture = new As(
                void 0,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.encoding
              )),
              (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Mt),
              (this.texture._needsFlipEnvMap = !1)
          }
          fromEquirectangularTexture(t, e) {
            ;(this.texture.type = e.type),
              (this.texture.format = Gt),
              (this.texture.encoding = e.encoding),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter)
            const n = { tEquirect: { value: null } },
              i =
                '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
              r =
                '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
              s = new ys(5, 5, 5),
              o = new _s({
                name: 'CubemapFromEquirect',
                uniforms: xs(n),
                vertexShader: i,
                fragmentShader: r,
                side: x,
                blending: M
              })
            o.uniforms.tEquirect.value = e
            const a = new gs(s, o),
              l = e.minFilter
            return (
              e.minFilter === Et && (e.minFilter = Mt),
              new Es(1, 10, this).update(t, a),
              (e.minFilter = l),
              a.geometry.dispose(),
              a.material.dispose(),
              this
            )
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget()
            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i)
            t.setRenderTarget(r)
          }
        }
        Ls.prototype.isWebGLCubeRenderTarget = !0
        class Rs extends Zn {
          constructor(t, e, n, i, r, s, o, a, l, c, h, u) {
            super(null, s, o, a, l, c, i, r, h, u),
              (this.image = { data: t || null, width: e || 1, height: n || 1 }),
              (this.magFilter = void 0 !== l ? l : yt),
              (this.minFilter = void 0 !== c ? c : yt),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0)
          }
        }
        Rs.prototype.isDataTexture = !0
        const Ps = new Mi(),
          Cs = new ei()
        class Is {
          constructor(t = new ar(), e = new ar(), n = new ar(), i = new ar(), r = new ar(), s = new ar()) {
            this.planes = [t, e, n, i, r, s]
          }
          set(t, e, n, i, r, s) {
            const o = this.planes
            return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
          }
          copy(t) {
            const e = this.planes
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n])
            return this
          }
          setFromProjectionMatrix(t) {
            const e = this.planes,
              n = t.elements,
              i = n[0],
              r = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = n[5],
              c = n[6],
              h = n[7],
              u = n[8],
              d = n[9],
              p = n[10],
              m = n[11],
              f = n[12],
              g = n[13],
              v = n[14],
              y = n[15]
            return (
              e[0].setComponents(o - i, h - a, m - u, y - f).normalize(),
              e[1].setComponents(o + i, h + a, m + u, y + f).normalize(),
              e[2].setComponents(o + r, h + l, m + d, y + g).normalize(),
              e[3].setComponents(o - r, h - l, m - d, y - g).normalize(),
              e[4].setComponents(o - s, h - c, m - p, y - v).normalize(),
              e[5].setComponents(o + s, h + c, m + p, y + v).normalize(),
              this
            )
          }
          intersectsObject(t) {
            const e = t.geometry
            return (
              null === e.boundingSphere && e.computeBoundingSphere(),
              Ps.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Ps)
            )
          }
          intersectsSprite(t) {
            return (
              Ps.center.set(0, 0, 0),
              (Ps.radius = 0.7071067811865476),
              Ps.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Ps)
            )
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius
            for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1
            return !0
          }
          intersectsBox(t) {
            const e = this.planes
            for (let n = 0; n < 6; n++) {
              const i = e[n]
              if (
                ((Cs.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (Cs.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (Cs.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(Cs) < 0)
              )
                return !1
            }
            return !0
          }
          containsPoint(t) {
            const e = this.planes
            for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1
            return !0
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        function Ds() {
          let t = null,
            e = !1,
            n = null,
            i = null
          function r(e, s) {
            n(e, s), (i = t.requestAnimationFrame(r))
          }
          return {
            start: function () {
              !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0))
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1)
            },
            setAnimationLoop: function (t) {
              n = t
            },
            setContext: function (e) {
              t = e
            }
          }
        }
        function Os(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap()
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data)
              const n = i.get(e)
              n && (t.deleteBuffer(n.buffer), i.delete(e))
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e)
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })
                )
              }
              e.isInterleavedBufferAttribute && (e = e.data)
              const s = i.get(e)
              void 0 === s
                ? i.set(
                    e,
                    (function (e, i) {
                      const r = e.array,
                        s = e.usage,
                        o = t.createBuffer()
                      t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback()
                      let a = 5126
                      return (
                        r instanceof Float32Array
                          ? (a = 5126)
                          : r instanceof Float64Array
                          ? console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.')
                          : r instanceof Uint16Array
                          ? e.isFloat16BufferAttribute
                            ? n
                              ? (a = 5131)
                              : console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.')
                            : (a = 5123)
                          : r instanceof Int16Array
                          ? (a = 5122)
                          : r instanceof Uint32Array
                          ? (a = 5125)
                          : r instanceof Int32Array
                          ? (a = 5124)
                          : r instanceof Int8Array
                          ? (a = 5120)
                          : r instanceof Uint8Array && (a = 5121),
                        { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version }
                      )
                    })(e, r)
                  )
                : s.version < e.version &&
                  ((function (e, i, r) {
                    const s = i.array,
                      o = i.updateRange
                    t.bindBuffer(r, e),
                      -1 === o.count
                        ? t.bufferSubData(r, 0, s)
                        : (n
                            ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count)
                            : t.bufferSubData(
                                r,
                                o.offset * s.BYTES_PER_ELEMENT,
                                s.subarray(o.offset, o.offset + o.count)
                              ),
                          (o.count = -1))
                  })(s.buffer, e, r),
                  (s.version = e.version))
            }
          }
        }
        class Ns extends Qr {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = 'PlaneGeometry'),
              (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i })
            const r = t / 2,
              s = e / 2,
              o = Math.floor(n),
              a = Math.floor(i),
              l = o + 1,
              c = a + 1,
              h = t / o,
              u = e / a,
              d = [],
              p = [],
              m = [],
              f = []
            for (let t = 0; t < c; t++) {
              const e = t * u - s
              for (let n = 0; n < l; n++) {
                const i = n * h - r
                p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / o), f.push(1 - t / a)
              }
            }
            for (let t = 0; t < a; t++)
              for (let e = 0; e < o; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  s = e + 1 + l * t
                d.push(n, i, s), d.push(i, r, s)
              }
            this.setIndex(d),
              this.setAttribute('position', new Ur(p, 3)),
              this.setAttribute('normal', new Ur(m, 3)),
              this.setAttribute('uv', new Ur(f, 2))
          }
        }
        const Bs = {
            alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
            alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
            alphatest_fragment: '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
            aomap_fragment:
              '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
            aomap_pars_fragment:
              '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
            begin_vertex: 'vec3 transformed = vec3( position );',
            beginnormal_vertex:
              'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
            bsdfs:
              'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
            bumpmap_pars_fragment:
              '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
            clipping_planes_fragment:
              '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
            clipping_planes_pars_fragment:
              '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
            clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
            clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
            color_fragment:
              '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
            color_pars_fragment:
              '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
            color_pars_vertex:
              '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
            color_vertex:
              '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
            common:
              '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
            cube_uv_reflection_fragment:
              '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
            defaultnormal_vertex:
              'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
            displacementmap_pars_vertex:
              '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
            displacementmap_vertex:
              '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
            emissivemap_fragment:
              '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
            emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
            encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
            encodings_pars_fragment:
              '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
            envmap_fragment:
              '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
            envmap_common_pars_fragment:
              '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
            envmap_pars_fragment:
              '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
            envmap_pars_vertex:
              '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
            envmap_physical_pars_fragment:
              '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
            envmap_vertex:
              '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
            fog_vertex: '#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif',
            fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
            fog_fragment:
              '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
            fog_pars_fragment:
              '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
            gradientmap_pars_fragment:
              '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
            lightmap_fragment:
              '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif',
            lightmap_pars_fragment:
              '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
            lights_lambert_vertex:
              'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
            lights_pars_begin:
              'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
            lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
            lights_toon_pars_fragment:
              'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
            lights_phong_fragment:
              'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
            lights_phong_pars_fragment:
              'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
            lights_physical_fragment:
              'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
            lights_physical_pars_fragment:
              'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
            lights_fragment_begin:
              '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
            lights_fragment_maps:
              '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
            lights_fragment_end:
              '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
            logdepthbuf_fragment:
              '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
            logdepthbuf_pars_fragment:
              '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
            logdepthbuf_pars_vertex:
              '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
            logdepthbuf_vertex:
              '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
            map_fragment:
              '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
            map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
            map_particle_fragment:
              '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
            map_particle_pars_fragment:
              '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
            metalnessmap_fragment:
              'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
            metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
            morphnormal_vertex:
              '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
            morphtarget_pars_vertex:
              '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
            morphtarget_vertex:
              '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
            normal_fragment_begin:
              'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
            normal_fragment_maps:
              '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
            normalmap_pars_fragment:
              '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
            clearcoat_normal_fragment_begin: '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
            clearcoat_normal_fragment_maps:
              '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
            clearcoat_pars_fragment:
              '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
            packing:
              'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
            premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
            project_vertex:
              'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
            dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
            dithering_pars_fragment:
              '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
            roughnessmap_fragment:
              'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
            roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
            shadowmap_pars_fragment:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
            shadowmap_pars_vertex:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
            shadowmap_vertex:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
            shadowmask_pars_fragment:
              'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
            skinbase_vertex:
              '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
            skinning_pars_vertex:
              '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
            skinning_vertex:
              '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
            skinnormal_vertex:
              '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
            specularmap_fragment:
              'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
            specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
            tonemapping_fragment:
              '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
            tonemapping_pars_fragment:
              '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
            transmissionmap_fragment:
              '#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif',
            transmissionmap_pars_fragment: '#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif',
            uv_pars_fragment: '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
            uv_pars_vertex:
              '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
            uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
            uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
            uv2_pars_vertex:
              '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
            uv2_vertex:
              '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
            worldpos_vertex:
              '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
            background_frag:
              'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            background_vert:
              'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
            cube_frag:
              '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            cube_vert:
              'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
            depth_frag:
              '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
            depth_vert:
              '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
            distanceRGBA_frag:
              '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
            distanceRGBA_vert:
              '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
            equirect_frag:
              'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            equirect_vert:
              'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
            linedashed_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
            linedashed_vert:
              'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
            meshbasic_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshbasic_vert:
              '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
            meshlambert_frag:
              'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshlambert_vert:
              '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshmatcap_frag:
              '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshmatcap_vert:
              '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
            meshtoon_frag:
              '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshtoon_vert:
              '#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshphong_frag:
              '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshphong_vert:
              '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshphysical_frag:
              '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshphysical_vert:
              '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            normal_frag:
              '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
            normal_vert:
              '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
            points_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
            points_vert:
              'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
            shadow_frag:
              'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
            shadow_vert:
              '#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            sprite_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
            sprite_vert:
              'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}'
          },
          Fs = {
            common: {
              diffuse: { value: new Ar(15658734) },
              opacity: { value: 1 },
              map: { value: null },
              uvTransform: { value: new jn() },
              uv2Transform: { value: new jn() },
              alphaMap: { value: null }
            },
            specularmap: { specularMap: { value: null } },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              refractionRatio: { value: 0.98 },
              maxMipLevel: { value: 0 }
            },
            aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
            lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
            emissivemap: { emissiveMap: { value: null } },
            bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
            normalmap: { normalMap: { value: null }, normalScale: { value: new Wn(1, 1) } },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 }
            },
            roughnessmap: { roughnessMap: { value: null } },
            metalnessmap: { metalnessMap: { value: null } },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new Ar(16777215) }
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: { value: [], properties: { direction: {}, color: {} } },
              directionalLightShadows: {
                value: [],
                properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {}
                }
              },
              spotLightShadows: {
                value: [],
                properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
              },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {}
                }
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
              rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
              ltc_1: { value: null },
              ltc_2: { value: null }
            },
            points: {
              diffuse: { value: new Ar(15658734) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new jn() }
            },
            sprite: {
              diffuse: { value: new Ar(15658734) },
              opacity: { value: 1 },
              center: { value: new Wn(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new jn() }
            }
          },
          zs = {
            basic: {
              uniforms: bs([Fs.common, Fs.specularmap, Fs.envmap, Fs.aomap, Fs.lightmap, Fs.fog]),
              vertexShader: Bs.meshbasic_vert,
              fragmentShader: Bs.meshbasic_frag
            },
            lambert: {
              uniforms: bs([
                Fs.common,
                Fs.specularmap,
                Fs.envmap,
                Fs.aomap,
                Fs.lightmap,
                Fs.emissivemap,
                Fs.fog,
                Fs.lights,
                { emissive: { value: new Ar(0) } }
              ]),
              vertexShader: Bs.meshlambert_vert,
              fragmentShader: Bs.meshlambert_frag
            },
            phong: {
              uniforms: bs([
                Fs.common,
                Fs.specularmap,
                Fs.envmap,
                Fs.aomap,
                Fs.lightmap,
                Fs.emissivemap,
                Fs.bumpmap,
                Fs.normalmap,
                Fs.displacementmap,
                Fs.fog,
                Fs.lights,
                { emissive: { value: new Ar(0) }, specular: { value: new Ar(1118481) }, shininess: { value: 30 } }
              ]),
              vertexShader: Bs.meshphong_vert,
              fragmentShader: Bs.meshphong_frag
            },
            standard: {
              uniforms: bs([
                Fs.common,
                Fs.envmap,
                Fs.aomap,
                Fs.lightmap,
                Fs.emissivemap,
                Fs.bumpmap,
                Fs.normalmap,
                Fs.displacementmap,
                Fs.roughnessmap,
                Fs.metalnessmap,
                Fs.fog,
                Fs.lights,
                {
                  emissive: { value: new Ar(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 }
                }
              ]),
              vertexShader: Bs.meshphysical_vert,
              fragmentShader: Bs.meshphysical_frag
            },
            toon: {
              uniforms: bs([
                Fs.common,
                Fs.aomap,
                Fs.lightmap,
                Fs.emissivemap,
                Fs.bumpmap,
                Fs.normalmap,
                Fs.displacementmap,
                Fs.gradientmap,
                Fs.fog,
                Fs.lights,
                { emissive: { value: new Ar(0) } }
              ]),
              vertexShader: Bs.meshtoon_vert,
              fragmentShader: Bs.meshtoon_frag
            },
            matcap: {
              uniforms: bs([
                Fs.common,
                Fs.bumpmap,
                Fs.normalmap,
                Fs.displacementmap,
                Fs.fog,
                { matcap: { value: null } }
              ]),
              vertexShader: Bs.meshmatcap_vert,
              fragmentShader: Bs.meshmatcap_frag
            },
            points: { uniforms: bs([Fs.points, Fs.fog]), vertexShader: Bs.points_vert, fragmentShader: Bs.points_frag },
            dashed: {
              uniforms: bs([
                Fs.common,
                Fs.fog,
                { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
              ]),
              vertexShader: Bs.linedashed_vert,
              fragmentShader: Bs.linedashed_frag
            },
            depth: {
              uniforms: bs([Fs.common, Fs.displacementmap]),
              vertexShader: Bs.depth_vert,
              fragmentShader: Bs.depth_frag
            },
            normal: {
              uniforms: bs([Fs.common, Fs.bumpmap, Fs.normalmap, Fs.displacementmap, { opacity: { value: 1 } }]),
              vertexShader: Bs.normal_vert,
              fragmentShader: Bs.normal_frag
            },
            sprite: { uniforms: bs([Fs.sprite, Fs.fog]), vertexShader: Bs.sprite_vert, fragmentShader: Bs.sprite_frag },
            background: {
              uniforms: { uvTransform: { value: new jn() }, t2D: { value: null } },
              vertexShader: Bs.background_vert,
              fragmentShader: Bs.background_frag
            },
            cube: {
              uniforms: bs([Fs.envmap, { opacity: { value: 1 } }]),
              vertexShader: Bs.cube_vert,
              fragmentShader: Bs.cube_frag
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: Bs.equirect_vert,
              fragmentShader: Bs.equirect_frag
            },
            distanceRGBA: {
              uniforms: bs([
                Fs.common,
                Fs.displacementmap,
                { referencePosition: { value: new ei() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }
              ]),
              vertexShader: Bs.distanceRGBA_vert,
              fragmentShader: Bs.distanceRGBA_frag
            },
            shadow: {
              uniforms: bs([Fs.lights, Fs.fog, { color: { value: new Ar(0) }, opacity: { value: 1 } }]),
              vertexShader: Bs.shadow_vert,
              fragmentShader: Bs.shadow_frag
            }
          }
        function ks(t, e, n, i, r) {
          const s = new Ar(0)
          let o,
            a,
            l = 0,
            c = null,
            h = 0,
            u = null
          function d(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, r)
          }
          return {
            getClearColor: function () {
              return s
            },
            setClearColor: function (t, e = 1) {
              s.set(t), (l = e), d(s, l)
            },
            getClearAlpha: function () {
              return l
            },
            setClearAlpha: function (t) {
              ;(l = t), d(s, l)
            },
            render: function (n, r, p, m) {
              let f = !0 === r.isScene ? r.background : null
              f && f.isTexture && (f = e.get(f))
              const g = t.xr,
                v = g.getSession && g.getSession()
              v && 'additive' === v.environmentBlendMode && (f = null),
                null === f ? d(s, l) : f && f.isColor && (d(f, 1), (m = !0)),
                (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                f && (f.isCubeTexture || f.mapping === pt)
                  ? (void 0 === a &&
                      ((a = new gs(
                        new ys(1, 1, 1),
                        new _s({
                          name: 'BackgroundCubeMaterial',
                          uniforms: xs(zs.cube.uniforms),
                          vertexShader: zs.cube.vertexShader,
                          fragmentShader: zs.cube.fragmentShader,
                          side: x,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1
                        })
                      )),
                      a.geometry.deleteAttribute('normal'),
                      a.geometry.deleteAttribute('uv'),
                      (a.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                      }),
                      Object.defineProperty(a.material, 'envMap', {
                        get: function () {
                          return this.uniforms.envMap.value
                        }
                      }),
                      i.update(a)),
                    (a.material.uniforms.envMap.value = f),
                    (a.material.uniforms.flipEnvMap.value = f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1),
                    (c === f && h === f.version && u === t.toneMapping) ||
                      ((a.material.needsUpdate = !0), (c = f), (h = f.version), (u = t.toneMapping)),
                    n.unshift(a, a.geometry, a.material, 0, 0, null))
                  : f &&
                    f.isTexture &&
                    (void 0 === o &&
                      ((o = new gs(
                        new Ns(2, 2),
                        new _s({
                          name: 'BackgroundMaterial',
                          uniforms: xs(zs.background.uniforms),
                          vertexShader: zs.background.vertexShader,
                          fragmentShader: zs.background.fragmentShader,
                          side: y,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1
                        })
                      )),
                      o.geometry.deleteAttribute('normal'),
                      Object.defineProperty(o.material, 'map', {
                        get: function () {
                          return this.uniforms.t2D.value
                        }
                      }),
                      i.update(o)),
                    (o.material.uniforms.t2D.value = f),
                    !0 === f.matrixAutoUpdate && f.updateMatrix(),
                    o.material.uniforms.uvTransform.value.copy(f.matrix),
                    (c === f && h === f.version && u === t.toneMapping) ||
                      ((o.material.needsUpdate = !0), (c = f), (h = f.version), (u = t.toneMapping)),
                    n.unshift(o, o.geometry, o.material, 0, 0, null))
            }
          }
        }
        function Us(t, e, n, i) {
          const r = t.getParameter(34921),
            s = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
            o = i.isWebGL2 || null !== s,
            a = {},
            l = d(null)
          let c = l
          function h(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
          }
          function u(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
          }
          function d(t) {
            const e = [],
              n = [],
              i = []
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0)
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null
            }
          }
          function p() {
            const t = c.newAttributes
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0
          }
          function m(t) {
            f(t, 0)
          }
          function f(n, r) {
            const s = c.newAttributes,
              o = c.enabledAttributes,
              a = c.attributeDivisors
            ;(s[n] = 1),
              0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
              a[n] !== r &&
                ((i.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
                  i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
                ](n, r),
                (a[n] = r))
          }
          function g() {
            const e = c.newAttributes,
              n = c.enabledAttributes
            for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0))
          }
          function v(e, n, r, s, o, a) {
            !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
              ? t.vertexAttribPointer(e, n, r, s, o, a)
              : t.vertexAttribIPointer(e, n, r, o, a)
          }
          function y() {
            x(), c !== l && ((c = l), h(c.object))
          }
          function x() {
            ;(l.geometry = null), (l.program = null), (l.wireframe = !1)
          }
          return {
            setup: function (r, l, u, y, x) {
              let b = !1
              if (o) {
                const e = (function (e, n, r) {
                  const o = !0 === r.wireframe
                  let l = a[e.id]
                  void 0 === l && ((l = {}), (a[e.id] = l))
                  let c = l[n.id]
                  void 0 === c && ((c = {}), (l[n.id] = c))
                  let h = c[o]
                  return (
                    void 0 === h &&
                      ((h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES())), (c[o] = h)),
                    h
                  )
                })(y, u, l)
                c !== e && ((c = e), h(c.object)),
                  (b = (function (t, e) {
                    const n = c.attributes,
                      i = t.attributes
                    let r = 0
                    for (const t in i) {
                      const e = n[t],
                        s = i[t]
                      if (void 0 === e) return !0
                      if (e.attribute !== s) return !0
                      if (e.data !== s.data) return !0
                      r++
                    }
                    return c.attributesNum !== r || c.index !== e
                  })(y, x)),
                  b &&
                    (function (t, e) {
                      const n = {},
                        i = t.attributes
                      let r = 0
                      for (const t in i) {
                        const e = i[t],
                          s = {}
                        ;(s.attribute = e), e.data && (s.data = e.data), (n[t] = s), r++
                      }
                      ;(c.attributes = n), (c.attributesNum = r), (c.index = e)
                    })(y, x)
              } else {
                const t = !0 === l.wireframe
                ;(c.geometry === y.id && c.program === u.id && c.wireframe === t) ||
                  ((c.geometry = y.id), (c.program = u.id), (c.wireframe = t), (b = !0))
              }
              !0 === r.isInstancedMesh && (b = !0),
                null !== x && n.update(x, 34963),
                b &&
                  ((function (r, s, o, a) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                      null === e.get('ANGLE_instanced_arrays')
                    )
                      return
                    p()
                    const l = a.attributes,
                      c = o.getAttributes(),
                      h = s.defaultAttributeValues
                    for (const e in c) {
                      const i = c[e]
                      if (i >= 0) {
                        const s = l[e]
                        if (void 0 !== s) {
                          const e = s.normalized,
                            r = s.itemSize,
                            o = n.get(s)
                          if (void 0 === o) continue
                          const l = o.buffer,
                            c = o.type,
                            h = o.bytesPerElement
                          if (s.isInterleavedBufferAttribute) {
                            const n = s.data,
                              o = n.stride,
                              u = s.offset
                            n && n.isInstancedInterleavedBuffer
                              ? (f(i, n.meshPerAttribute),
                                void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count))
                              : m(i),
                              t.bindBuffer(34962, l),
                              v(i, r, c, e, o * h, u * h)
                          } else
                            s.isInstancedBufferAttribute
                              ? (f(i, s.meshPerAttribute),
                                void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count))
                              : m(i),
                              t.bindBuffer(34962, l),
                              v(i, r, c, e, 0, 0)
                        } else if ('instanceMatrix' === e) {
                          const e = n.get(r.instanceMatrix)
                          if (void 0 === e) continue
                          const s = e.buffer,
                            o = e.type
                          f(i + 0, 1),
                            f(i + 1, 1),
                            f(i + 2, 1),
                            f(i + 3, 1),
                            t.bindBuffer(34962, s),
                            t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0),
                            t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16),
                            t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32),
                            t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                        } else if ('instanceColor' === e) {
                          const e = n.get(r.instanceColor)
                          if (void 0 === e) continue
                          const s = e.buffer,
                            o = e.type
                          f(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                        } else if (void 0 !== h) {
                          const n = h[e]
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(i, n)
                                break
                              case 3:
                                t.vertexAttrib3fv(i, n)
                                break
                              case 4:
                                t.vertexAttrib4fv(i, n)
                                break
                              default:
                                t.vertexAttrib1fv(i, n)
                            }
                        }
                      }
                    }
                    g()
                  })(r, l, u, y),
                  null !== x && t.bindBuffer(34963, n.get(x).buffer))
            },
            reset: y,
            resetDefaultState: x,
            dispose: function () {
              y()
              for (const t in a) {
                const e = a[t]
                for (const t in e) {
                  const n = e[t]
                  for (const t in n) u(n[t].object), delete n[t]
                  delete e[t]
                }
                delete a[t]
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === a[t.id]) return
              const e = a[t.id]
              for (const t in e) {
                const n = e[t]
                for (const t in n) u(n[t].object), delete n[t]
                delete e[t]
              }
              delete a[t.id]
            },
            releaseStatesOfProgram: function (t) {
              for (const e in a) {
                const n = a[e]
                if (void 0 === n[t.id]) continue
                const i = n[t.id]
                for (const t in i) u(i[t].object), delete i[t]
                delete n[t.id]
              }
            },
            initAttributes: p,
            enableAttribute: m,
            disableUnusedAttributes: g
          }
        }
        function Hs(t, e, n, i) {
          const r = i.isWebGL2
          let s
          ;(this.setMode = function (t) {
            s = t
          }),
            (this.render = function (e, i) {
              t.drawArrays(s, e, i), n.update(i, s, 1)
            }),
            (this.renderInstances = function (i, o, a) {
              if (0 === a) return
              let l, c
              if (r) (l = t), (c = 'drawArraysInstanced')
              else if (((l = e.get('ANGLE_instanced_arrays')), (c = 'drawArraysInstancedANGLE'), null === l))
                return void console.error(
                  'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                )
              l[c](s, i, o, a), n.update(o, s, a)
            })
        }
        function Gs(t, e, n) {
          let i
          function r(e) {
            if ('highp' === e) {
              if (
                t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                t.getShaderPrecisionFormat(35632, 36338).precision > 0
              )
                return 'highp'
              e = 'mediump'
            }
            return 'mediump' === e &&
              t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36337).precision > 0
              ? 'mediump'
              : 'lowp'
          }
          const s =
            ('undefined' != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) ||
            ('undefined' != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext)
          let o = void 0 !== n.precision ? n.precision : 'highp'
          const a = r(o)
          a !== o && (console.warn('THREE.WebGLRenderer:', o, 'not supported, using', a, 'instead.'), (o = a))
          const l = !0 === n.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            h = t.getParameter(35660),
            u = t.getParameter(3379),
            d = t.getParameter(34076),
            p = t.getParameter(34921),
            m = t.getParameter(36347),
            f = t.getParameter(36348),
            g = t.getParameter(36349),
            v = h > 0,
            y = s || e.has('OES_texture_float')
          return {
            isWebGL2: s,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i
              if (!0 === e.has('EXT_texture_filter_anisotropic')) {
                const n = e.get('EXT_texture_filter_anisotropic')
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
              } else i = 0
              return i
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: m,
            maxVaryings: f,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? t.getParameter(36183) : 0
          }
        }
        function Vs(t) {
          const e = this
          let n = null,
            i = 0,
            r = !1,
            s = !1
          const o = new ar(),
            a = new jn(),
            l = { value: null, needsUpdate: !1 }
          function c() {
            l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)), (e.numPlanes = i), (e.numIntersection = 0)
          }
          function h(t, n, i, r) {
            const s = null !== t ? t.length : 0
            let c = null
            if (0 !== s) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * s,
                  r = n.matrixWorldInverse
                a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e))
                for (let e = 0, n = i; e !== s; ++e, n += 4)
                  o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), (c[n + 3] = o.constant)
              }
              ;(l.value = c), (l.needsUpdate = !0)
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c
          }
          ;(this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e, s) {
              const o = 0 !== t.length || e || 0 !== i || r
              return (r = e), (n = h(t, s, 0)), (i = t.length), o
            }),
            (this.beginShadows = function () {
              ;(s = !0), h(null)
            }),
            (this.endShadows = function () {
              ;(s = !1), c()
            }),
            (this.setState = function (e, o, a) {
              const u = e.clippingPlanes,
                d = e.clipIntersection,
                p = e.clipShadows,
                m = t.get(e)
              if (!r || null === u || 0 === u.length || (s && !p)) s ? h(null) : c()
              else {
                const t = s ? 0 : i,
                  e = 4 * t
                let r = m.clippingState || null
                ;(l.value = r), (r = h(u, o, e, a))
                for (let t = 0; t !== e; ++t) r[t] = n[t]
                ;(m.clippingState = r), (this.numIntersection = d ? this.numPlanes : 0), (this.numPlanes += t)
              }
            })
        }
        function Ws(t) {
          let e = new WeakMap()
          function n(t, e) {
            return e === ut ? (t.mapping = ct) : e === dt && (t.mapping = ht), t
          }
          function i(t) {
            const n = t.target
            n.removeEventListener('dispose', i)
            const r = e.get(n)
            void 0 !== r && (e.delete(n), r.dispose())
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping
                if (s === ut || s === dt) {
                  if (e.has(r)) return n(e.get(r).texture, r.mapping)
                  {
                    const s = r.image
                    if (s && s.height > 0) {
                      const o = t.getRenderTarget(),
                        a = new Ls(s.height / 2)
                      return (
                        a.fromEquirectangularTexture(t, r),
                        e.set(r, a),
                        t.setRenderTarget(o),
                        r.addEventListener('dispose', i),
                        n(a.texture, r.mapping)
                      )
                    }
                    return null
                  }
                }
              }
              return r
            },
            dispose: function () {
              e = new WeakMap()
            }
          }
        }
        function js(t) {
          const e = {}
          function n(n) {
            if (void 0 !== e[n]) return e[n]
            let i
            switch (n) {
              case 'WEBGL_depth_texture':
                i =
                  t.getExtension('WEBGL_depth_texture') ||
                  t.getExtension('MOZ_WEBGL_depth_texture') ||
                  t.getExtension('WEBKIT_WEBGL_depth_texture')
                break
              case 'EXT_texture_filter_anisotropic':
                i =
                  t.getExtension('EXT_texture_filter_anisotropic') ||
                  t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                  t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
                break
              case 'WEBGL_compressed_texture_s3tc':
                i =
                  t.getExtension('WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
                break
              case 'WEBGL_compressed_texture_pvrtc':
                i =
                  t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
                break
              default:
                i = t.getExtension(n)
            }
            return (e[n] = i), i
          }
          return {
            has: function (t) {
              return null !== n(t)
            },
            init: function (t) {
              t.isWebGL2
                ? n('EXT_color_buffer_float')
                : (n('WEBGL_depth_texture'),
                  n('OES_texture_float'),
                  n('OES_texture_half_float'),
                  n('OES_texture_half_float_linear'),
                  n('OES_standard_derivatives'),
                  n('OES_element_index_uint'),
                  n('OES_vertex_array_object'),
                  n('ANGLE_instanced_arrays')),
                n('OES_texture_float_linear'),
                n('EXT_color_buffer_half_float')
            },
            get: function (t) {
              const e = n(t)
              return null === e && console.warn('THREE.WebGLRenderer: ' + t + ' extension not supported.'), e
            }
          }
        }
        function qs(t, e, n, i) {
          const r = {},
            s = new WeakMap()
          function o(t) {
            const a = t.target
            null !== a.index && e.remove(a.index)
            for (const t in a.attributes) e.remove(a.attributes[t])
            a.removeEventListener('dispose', o), delete r[a.id]
            const l = s.get(a)
            l && (e.remove(l), s.delete(a)),
              i.releaseStatesOfGeometry(a),
              !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
              n.memory.geometries--
          }
          function a(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position
            let o = 0
            if (null !== i) {
              const t = i.array
              o = i.version
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  s = t[e + 2]
                n.push(i, r, r, s, s, i)
              }
            } else {
              const t = r.array
              o = r.version
              for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                const t = e + 0,
                  i = e + 1,
                  r = e + 2
                n.push(t, i, i, r, r, t)
              }
            }
            const a = new (Gr(n) > 65535 ? zr : Br)(n, 1)
            a.version = o
            const l = s.get(t)
            l && e.remove(l), s.set(t, a)
          }
          return {
            get: function (t, e) {
              return !0 === r[e.id] || (e.addEventListener('dispose', o), (r[e.id] = !0), n.memory.geometries++), e
            },
            update: function (t) {
              const n = t.attributes
              for (const t in n) e.update(n[t], 34962)
              const i = t.morphAttributes
              for (const t in i) {
                const n = i[t]
                for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t)
              if (e) {
                const n = t.index
                null !== n && e.version < n.version && a(t)
              } else a(t)
              return s.get(t)
            }
          }
        }
        function Xs(t, e, n, i) {
          const r = i.isWebGL2
          let s, o, a
          ;(this.setMode = function (t) {
            s = t
          }),
            (this.setIndex = function (t) {
              ;(o = t.type), (a = t.bytesPerElement)
            }),
            (this.render = function (e, i) {
              t.drawElements(s, i, o, e * a), n.update(i, s, 1)
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return
              let h, u
              if (r) (h = t), (u = 'drawElementsInstanced')
              else if (((h = e.get('ANGLE_instanced_arrays')), (u = 'drawElementsInstancedANGLE'), null === h))
                return void console.error(
                  'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                )
              h[u](s, l, o, i * a, c), n.update(l, s, c)
            })
        }
        function Ys(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0)
            },
            update: function (t, n, i) {
              switch ((e.calls++, n)) {
                case 4:
                  e.triangles += i * (t / 3)
                  break
                case 1:
                  e.lines += i * (t / 2)
                  break
                case 3:
                  e.lines += i * (t - 1)
                  break
                case 2:
                  e.lines += i * t
                  break
                case 0:
                  e.points += i * t
                  break
                default:
                  console.error('THREE.WebGLInfo: Unknown draw mode:', n)
              }
            }
          }
        }
        function Zs(t, e) {
          return t[0] - e[0]
        }
        function Js(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1])
        }
        function Ks(t) {
          const e = {},
            n = new Float32Array(8),
            i = []
          for (let t = 0; t < 8; t++) i[t] = [t, 0]
          return {
            update: function (r, s, o, a) {
              const l = r.morphTargetInfluences,
                c = void 0 === l ? 0 : l.length
              let h = e[s.id]
              if (void 0 === h) {
                h = []
                for (let t = 0; t < c; t++) h[t] = [t, 0]
                e[s.id] = h
              }
              for (let t = 0; t < c; t++) {
                const e = h[t]
                ;(e[0] = t), (e[1] = l[t])
              }
              h.sort(Js)
              for (let t = 0; t < 8; t++)
                t < c && h[t][1]
                  ? ((i[t][0] = h[t][0]), (i[t][1] = h[t][1]))
                  : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0))
              i.sort(Zs)
              const u = o.morphTargets && s.morphAttributes.position,
                d = o.morphNormals && s.morphAttributes.normal
              let p = 0
              for (let t = 0; t < 8; t++) {
                const e = i[t],
                  r = e[0],
                  o = e[1]
                r !== Number.MAX_SAFE_INTEGER && o
                  ? (u && s.getAttribute('morphTarget' + t) !== u[r] && s.setAttribute('morphTarget' + t, u[r]),
                    d && s.getAttribute('morphNormal' + t) !== d[r] && s.setAttribute('morphNormal' + t, d[r]),
                    (n[t] = o),
                    (p += o))
                  : (u && !0 === s.hasAttribute('morphTarget' + t) && s.deleteAttribute('morphTarget' + t),
                    d && !0 === s.hasAttribute('morphNormal' + t) && s.deleteAttribute('morphNormal' + t),
                    (n[t] = 0))
              }
              const m = s.morphTargetsRelative ? 1 : 1 - p
              a.getUniforms().setValue(t, 'morphTargetBaseInfluence', m),
                a.getUniforms().setValue(t, 'morphTargetInfluences', n)
            }
          }
        }
        function Qs(t, e, n, i) {
          let r = new WeakMap()
          function s(t) {
            const e = t.target
            e.removeEventListener('dispose', s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor)
          }
          return {
            update: function (t) {
              const o = i.render.frame,
                a = t.geometry,
                l = e.get(t, a)
              return (
                r.get(l) !== o && (e.update(l), r.set(l, o)),
                t.isInstancedMesh &&
                  (!1 === t.hasEventListener('dispose', s) && t.addEventListener('dispose', s),
                  n.update(t.instanceMatrix, 34962),
                  null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
              )
            },
            dispose: function () {
              r = new WeakMap()
            }
          }
        }
        zs.physical = {
          uniforms: bs([
            zs.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatNormalScale: { value: new Wn(1, 1) },
              clearcoatNormalMap: { value: null },
              sheen: { value: new Ar(0) },
              transmission: { value: 0 },
              transmissionMap: { value: null }
            }
          ]),
          vertexShader: Bs.meshphysical_vert,
          fragmentShader: Bs.meshphysical_frag
        }
        class $s extends Zn {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = yt),
              (this.minFilter = yt),
              (this.wrapR = gt),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.needsUpdate = !0)
          }
        }
        $s.prototype.isDataTexture2DArray = !0
        class to extends Zn {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = yt),
              (this.minFilter = yt),
              (this.wrapR = gt),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.needsUpdate = !0)
          }
        }
        to.prototype.isDataTexture3D = !0
        const eo = new Zn(),
          no = new $s(),
          io = new to(),
          ro = new As(),
          so = [],
          oo = [],
          ao = new Float32Array(16),
          lo = new Float32Array(9),
          co = new Float32Array(4)
        function ho(t, e, n) {
          const i = t[0]
          if (i <= 0 || i > 0) return t
          const r = e * n
          let s = so[r]
          if ((void 0 === s && ((s = new Float32Array(r)), (so[r] = s)), 0 !== e)) {
            i.toArray(s, 0)
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r)
          }
          return s
        }
        function uo(t, e) {
          if (t.length !== e.length) return !1
          for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1
          return !0
        }
        function po(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }
        function mo(t, e) {
          let n = oo[e]
          void 0 === n && ((n = new Int32Array(e)), (oo[e] = n))
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit()
          return n
        }
        function fo(t, e) {
          const n = this.cache
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e))
        }
        function go(t, e) {
          const n = this.cache
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
          else {
            if (uo(n, e)) return
            t.uniform2fv(this.addr, e), po(n, e)
          }
        }
        function vo(t, e) {
          const n = this.cache
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z))
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b))
          else {
            if (uo(n, e)) return
            t.uniform3fv(this.addr, e), po(n, e)
          }
        }
        function yo(t, e) {
          const n = this.cache
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z), (n[3] = e.w))
          else {
            if (uo(n, e)) return
            t.uniform4fv(this.addr, e), po(n, e)
          }
        }
        function xo(t, e) {
          const n = this.cache,
            i = e.elements
          if (void 0 === i) {
            if (uo(n, e)) return
            t.uniformMatrix2fv(this.addr, !1, e), po(n, e)
          } else {
            if (uo(n, i)) return
            co.set(i), t.uniformMatrix2fv(this.addr, !1, co), po(n, i)
          }
        }
        function bo(t, e) {
          const n = this.cache,
            i = e.elements
          if (void 0 === i) {
            if (uo(n, e)) return
            t.uniformMatrix3fv(this.addr, !1, e), po(n, e)
          } else {
            if (uo(n, i)) return
            lo.set(i), t.uniformMatrix3fv(this.addr, !1, lo), po(n, i)
          }
        }
        function wo(t, e) {
          const n = this.cache,
            i = e.elements
          if (void 0 === i) {
            if (uo(n, e)) return
            t.uniformMatrix4fv(this.addr, !1, e), po(n, e)
          } else {
            if (uo(n, i)) return
            ao.set(i), t.uniformMatrix4fv(this.addr, !1, ao), po(n, i)
          }
        }
        function _o(t, e) {
          const n = this.cache
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e))
        }
        function Mo(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform2iv(this.addr, e), po(n, e))
        }
        function To(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform3iv(this.addr, e), po(n, e))
        }
        function So(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform4iv(this.addr, e), po(n, e))
        }
        function Eo(t, e) {
          const n = this.cache
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e))
        }
        function Ao(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform2uiv(this.addr, e), po(n, e))
        }
        function Lo(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform3uiv(this.addr, e), po(n, e))
        }
        function Ro(t, e) {
          const n = this.cache
          uo(n, e) || (t.uniform4uiv(this.addr, e), po(n, e))
        }
        function Po(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit()
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTexture2D(e || eo, r)
        }
        function Co(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit()
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(e || io, r)
        }
        function Io(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit()
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTextureCube(e || ro, r)
        }
        function Do(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit()
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(e || no, r)
        }
        function Oo(t, e) {
          t.uniform1fv(this.addr, e)
        }
        function No(t, e) {
          const n = ho(e, this.size, 2)
          t.uniform2fv(this.addr, n)
        }
        function Bo(t, e) {
          const n = ho(e, this.size, 3)
          t.uniform3fv(this.addr, n)
        }
        function Fo(t, e) {
          const n = ho(e, this.size, 4)
          t.uniform4fv(this.addr, n)
        }
        function zo(t, e) {
          const n = ho(e, this.size, 4)
          t.uniformMatrix2fv(this.addr, !1, n)
        }
        function ko(t, e) {
          const n = ho(e, this.size, 9)
          t.uniformMatrix3fv(this.addr, !1, n)
        }
        function Uo(t, e) {
          const n = ho(e, this.size, 16)
          t.uniformMatrix4fv(this.addr, !1, n)
        }
        function Ho(t, e) {
          t.uniform1iv(this.addr, e)
        }
        function Go(t, e) {
          t.uniform2iv(this.addr, e)
        }
        function Vo(t, e) {
          t.uniform3iv(this.addr, e)
        }
        function Wo(t, e) {
          t.uniform4iv(this.addr, e)
        }
        function jo(t, e) {
          t.uniform1uiv(this.addr, e)
        }
        function qo(t, e) {
          t.uniform2uiv(this.addr, e)
        }
        function Xo(t, e) {
          t.uniform3uiv(this.addr, e)
        }
        function Yo(t, e) {
          t.uniform4uiv(this.addr, e)
        }
        function Zo(t, e, n) {
          const i = e.length,
            r = mo(n, i)
          t.uniform1iv(this.addr, r)
          for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || eo, r[t])
        }
        function Jo(t, e, n) {
          const i = e.length,
            r = mo(n, i)
          t.uniform1iv(this.addr, r)
          for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || ro, r[t])
        }
        function Ko(t, e, n) {
          ;(this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return fo
                case 35664:
                  return go
                case 35665:
                  return vo
                case 35666:
                  return yo
                case 35674:
                  return xo
                case 35675:
                  return bo
                case 35676:
                  return wo
                case 5124:
                case 35670:
                  return _o
                case 35667:
                case 35671:
                  return Mo
                case 35668:
                case 35672:
                  return To
                case 35669:
                case 35673:
                  return So
                case 5125:
                  return Eo
                case 36294:
                  return Ao
                case 36295:
                  return Lo
                case 36296:
                  return Ro
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Po
                case 35679:
                case 36299:
                case 36307:
                  return Co
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Io
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return Do
              }
            })(e.type))
        }
        function Qo(t, e, n) {
          ;(this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return Oo
                case 35664:
                  return No
                case 35665:
                  return Bo
                case 35666:
                  return Fo
                case 35674:
                  return zo
                case 35675:
                  return ko
                case 35676:
                  return Uo
                case 5124:
                case 35670:
                  return Ho
                case 35667:
                case 35671:
                  return Go
                case 35668:
                case 35672:
                  return Vo
                case 35669:
                case 35673:
                  return Wo
                case 5125:
                  return jo
                case 36294:
                  return qo
                case 36295:
                  return Xo
                case 36296:
                  return Yo
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Zo
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Jo
              }
            })(e.type))
        }
        function $o(t) {
          ;(this.id = t), (this.seq = []), (this.map = {})
        }
        ;(Qo.prototype.updateCache = function (t) {
          const e = this.cache
          t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), po(e, t)
        }),
          ($o.prototype.setValue = function (t, e, n) {
            const i = this.seq
            for (let r = 0, s = i.length; r !== s; ++r) {
              const s = i[r]
              s.setValue(t, e[s.id], n)
            }
          })
        const ta = /(\w+)(\])?(\[|\.)?/g
        function ea(t, e) {
          t.seq.push(e), (t.map[e.id] = e)
        }
        function na(t, e, n) {
          const i = t.name,
            r = i.length
          for (ta.lastIndex = 0; ; ) {
            const s = ta.exec(i),
              o = ta.lastIndex
            let a = s[1]
            const l = ']' === s[2],
              c = s[3]
            if ((l && (a |= 0), void 0 === c || ('[' === c && o + 2 === r))) {
              ea(n, void 0 === c ? new Ko(a, t, e) : new Qo(a, t, e))
              break
            }
            {
              let t = n.map[a]
              void 0 === t && ((t = new $o(a)), ea(n, t)), (n = t)
            }
          }
        }
        function ia(t, e) {
          ;(this.seq = []), (this.map = {})
          const n = t.getProgramParameter(e, 35718)
          for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i)
            na(n, t.getUniformLocation(e, n.name), this)
          }
        }
        function ra(t, e, n) {
          const i = t.createShader(e)
          return t.shaderSource(i, n), t.compileShader(i), i
        }
        ;(ia.prototype.setValue = function (t, e, n, i) {
          const r = this.map[e]
          void 0 !== r && r.setValue(t, n, i)
        }),
          (ia.prototype.setOptional = function (t, e, n) {
            const i = e[n]
            void 0 !== i && this.setValue(t, n, i)
          }),
          (ia.upload = function (t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
              const s = e[r],
                o = n[s.id]
              !1 !== o.needsUpdate && s.setValue(t, o.value, i)
            }
          }),
          (ia.seqWithValue = function (t, e) {
            const n = []
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i]
              r.id in e && n.push(r)
            }
            return n
          })
        let sa = 0
        function oa(t) {
          switch (t) {
            case tn:
              return ['Linear', '( value )']
            case en:
              return ['sRGB', '( value )']
            case rn:
              return ['RGBE', '( value )']
            case on:
              return ['RGBM', '( value, 7.0 )']
            case an:
              return ['RGBM', '( value, 16.0 )']
            case ln:
              return ['RGBD', '( value, 256.0 )']
            case nn:
              return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
            case sn:
              return ['LogLuv', '( value )']
            default:
              return console.warn('THREE.WebGLProgram: Unsupported encoding:', t), ['Linear', '( value )']
          }
        }
        function aa(t, e, n) {
          const i = t.getShaderParameter(e, 35713),
            r = t.getShaderInfoLog(e).trim()
          return i && '' === r
            ? ''
            : 'THREE.WebGLShader: gl.getShaderInfoLog() ' +
                n +
                '\n' +
                r +
                (function (t) {
                  const e = t.split('\n')
                  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t]
                  return e.join('\n')
                })(t.getShaderSource(e))
        }
        function la(t, e) {
          const n = oa(e)
          return 'vec4 ' + t + '( vec4 value ) { return ' + n[0] + 'ToLinear' + n[1] + '; }'
        }
        function ca(t, e) {
          const n = oa(e)
          return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }'
        }
        function ha(t, e) {
          let n
          switch (e) {
            case it:
              n = 'Linear'
              break
            case rt:
              n = 'Reinhard'
              break
            case st:
              n = 'OptimizedCineon'
              break
            case ot:
              n = 'ACESFilmic'
              break
            case at:
              n = 'Custom'
              break
            default:
              console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (n = 'Linear')
          }
          return 'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
        }
        function ua(t) {
          return '' !== t
        }
        function da(t, e) {
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function pa(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const ma = /^[ \t]*#include +<([\w\d./]+)>/gm
        function fa(t) {
          return t.replace(ma, ga)
        }
        function ga(t, e) {
          const n = Bs[e]
          if (void 0 === n) throw new Error('Can not resolve #include <' + e + '>')
          return fa(n)
        }
        const va = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          ya = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
        function xa(t) {
          return t.replace(ya, wa).replace(va, ba)
        }
        function ba(t, e, n, i) {
          return (
            console.warn(
              'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.'
            ),
            wa(0, e, n, i)
          )
        }
        function wa(t, e, n, i) {
          let r = ''
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i.replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]').replace(/UNROLLED_LOOP_INDEX/g, t)
          return r
        }
        function _a(t) {
          let e = 'precision ' + t.precision + ' float;\nprecision ' + t.precision + ' int;'
          return (
            'highp' === t.precision
              ? (e += '\n#define HIGH_PRECISION')
              : 'mediump' === t.precision
              ? (e += '\n#define MEDIUM_PRECISION')
              : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
            e
          )
        }
        function Ma(t, e, n, i) {
          const r = t.getContext(),
            s = n.defines
          let o = n.vertexShader,
            a = n.fragmentShader
          const l = (function (t) {
              let e = 'SHADOWMAP_TYPE_BASIC'
              return (
                t.shadowMapType === f
                  ? (e = 'SHADOWMAP_TYPE_PCF')
                  : t.shadowMapType === g
                  ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                  : t.shadowMapType === v && (e = 'SHADOWMAP_TYPE_VSM'),
                e
              )
            })(n),
            c = (function (t) {
              let e = 'ENVMAP_TYPE_CUBE'
              if (t.envMap)
                switch (t.envMapMode) {
                  case ct:
                  case ht:
                    e = 'ENVMAP_TYPE_CUBE'
                    break
                  case pt:
                  case mt:
                    e = 'ENVMAP_TYPE_CUBE_UV'
                }
              return e
            })(n),
            h = (function (t) {
              let e = 'ENVMAP_MODE_REFLECTION'
              if (t.envMap)
                switch (t.envMapMode) {
                  case ht:
                  case mt:
                    e = 'ENVMAP_MODE_REFRACTION'
                }
              return e
            })(n),
            u = (function (t) {
              let e = 'ENVMAP_BLENDING_NONE'
              if (t.envMap)
                switch (t.combine) {
                  case $:
                    e = 'ENVMAP_BLENDING_MULTIPLY'
                    break
                  case tt:
                    e = 'ENVMAP_BLENDING_MIX'
                    break
                  case et:
                    e = 'ENVMAP_BLENDING_ADD'
                }
              return e
            })(n),
            d = t.gammaFactor > 0 ? t.gammaFactor : 1,
            p = n.isWebGL2
              ? ''
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUV ||
                    t.bumpMap ||
                    t.tangentSpaceNormalMap ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    'physical' === t.shaderID
                      ? '#extension GL_OES_standard_derivatives : enable'
                      : '',
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth
                      ? '#extension GL_EXT_frag_depth : enable'
                      : '',
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? '#extension GL_EXT_draw_buffers : require'
                      : '',
                    (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod
                      ? '#extension GL_EXT_shader_texture_lod : enable'
                      : ''
                  ]
                    .filter(ua)
                    .join('\n')
                })(n),
            m = (function (t) {
              const e = []
              for (const n in t) {
                const i = t[n]
                !1 !== i && e.push('#define ' + n + ' ' + i)
              }
              return e.join('\n')
            })(s),
            y = r.createProgram()
          let x,
            b,
            w = n.glslVersion ? '#version ' + n.glslVersion + '\n' : ''
          n.isRawShaderMaterial
            ? ((x = [m].filter(ua).join('\n')),
              x.length > 0 && (x += '\n'),
              (b = [p, m].filter(ua).join('\n')),
              b.length > 0 && (b += '\n'))
            : ((x = [
                _a(n),
                '#define SHADER_NAME ' + n.shaderName,
                m,
                n.instancing ? '#define USE_INSTANCING' : '',
                n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + d,
                '#define MAX_BONES ' + n.maxBones,
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.map ? '#define USE_MAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + h : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.displacementMap && n.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.vertexTangents ? '#define USE_TANGENT' : '',
                n.vertexColors ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUvs ? '#define USE_UV' : '',
                n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.skinning ? '#define USE_SKINNING' : '',
                n.useVertexTexture ? '#define BONE_TEXTURE' : '',
                n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                n.morphNormals && !1 === n.flatShading ? '#define USE_MORPHNORMALS' : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + l : '',
                n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                '#ifdef USE_INSTANCING',
                '\tattribute mat4 instanceMatrix;',
                '#endif',
                '#ifdef USE_INSTANCING_COLOR',
                '\tattribute vec3 instanceColor;',
                '#endif',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_TANGENT',
                '\tattribute vec4 tangent;',
                '#endif',
                '#if defined( USE_COLOR_ALPHA )',
                '\tattribute vec4 color;',
                '#elif defined( USE_COLOR )',
                '\tattribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '\tattribute vec3 morphTarget0;',
                '\tattribute vec3 morphTarget1;',
                '\tattribute vec3 morphTarget2;',
                '\tattribute vec3 morphTarget3;',
                '\t#ifdef USE_MORPHNORMALS',
                '\t\tattribute vec3 morphNormal0;',
                '\t\tattribute vec3 morphNormal1;',
                '\t\tattribute vec3 morphNormal2;',
                '\t\tattribute vec3 morphNormal3;',
                '\t#else',
                '\t\tattribute vec3 morphTarget4;',
                '\t\tattribute vec3 morphTarget5;',
                '\t\tattribute vec3 morphTarget6;',
                '\t\tattribute vec3 morphTarget7;',
                '\t#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '\tattribute vec4 skinIndex;',
                '\tattribute vec4 skinWeight;',
                '#endif',
                '\n'
              ]
                .filter(ua)
                .join('\n')),
              (b = [
                p,
                _a(n),
                '#define SHADER_NAME ' + n.shaderName,
                m,
                n.alphaTest ? '#define ALPHATEST ' + n.alphaTest + (n.alphaTest % 1 ? '' : '.0') : '',
                '#define GAMMA_FACTOR ' + d,
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.map ? '#define USE_MAP' : '',
                n.matcap ? '#define USE_MATCAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + c : '',
                n.envMap ? '#define ' + h : '',
                n.envMap ? '#define ' + u : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.sheen ? '#define USE_SHEEN' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.vertexTangents ? '#define USE_TANGENT' : '',
                n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUvs ? '#define USE_UV' : '',
                n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + l : '',
                n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                n.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod
                  ? '#define TEXTURE_LOD_EXT'
                  : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                n.toneMapping !== nt ? '#define TONE_MAPPING' : '',
                n.toneMapping !== nt ? Bs.tonemapping_pars_fragment : '',
                n.toneMapping !== nt ? ha('toneMapping', n.toneMapping) : '',
                n.dithering ? '#define DITHERING' : '',
                Bs.encodings_pars_fragment,
                n.map ? la('mapTexelToLinear', n.mapEncoding) : '',
                n.matcap ? la('matcapTexelToLinear', n.matcapEncoding) : '',
                n.envMap ? la('envMapTexelToLinear', n.envMapEncoding) : '',
                n.emissiveMap ? la('emissiveMapTexelToLinear', n.emissiveMapEncoding) : '',
                n.lightMap ? la('lightMapTexelToLinear', n.lightMapEncoding) : '',
                ca('linearToOutputTexel', n.outputEncoding),
                n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                '\n'
              ]
                .filter(ua)
                .join('\n'))),
            (o = fa(o)),
            (o = da(o, n)),
            (o = pa(o, n)),
            (a = fa(a)),
            (a = da(a, n)),
            (a = pa(a, n)),
            (o = xa(o)),
            (a = xa(a)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((w = '#version 300 es\n'),
              (x = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + x),
              (b =
                [
                  '#define varying in',
                  n.glslVersion === kn ? '' : 'out highp vec4 pc_fragColor;',
                  n.glslVersion === kn ? '' : '#define gl_FragColor pc_fragColor',
                  '#define gl_FragDepthEXT gl_FragDepth',
                  '#define texture2D texture',
                  '#define textureCube texture',
                  '#define texture2DProj textureProj',
                  '#define texture2DLodEXT textureLod',
                  '#define texture2DProjLodEXT textureProjLod',
                  '#define textureCubeLodEXT textureLod',
                  '#define texture2DGradEXT textureGrad',
                  '#define texture2DProjGradEXT textureProjGrad',
                  '#define textureCubeGradEXT textureGrad'
                ].join('\n') +
                '\n' +
                b))
          const _ = w + b + a,
            M = ra(r, 35633, w + x + o),
            T = ra(r, 35632, _)
          if (
            (r.attachShader(y, M),
            r.attachShader(y, T),
            void 0 !== n.index0AttributeName
              ? r.bindAttribLocation(y, 0, n.index0AttributeName)
              : !0 === n.morphTargets && r.bindAttribLocation(y, 0, 'position'),
            r.linkProgram(y),
            t.debug.checkShaderErrors)
          ) {
            const t = r.getProgramInfoLog(y).trim(),
              e = r.getShaderInfoLog(M).trim(),
              n = r.getShaderInfoLog(T).trim()
            let i = !0,
              s = !0
            if (!1 === r.getProgramParameter(y, 35714)) {
              i = !1
              const e = aa(r, M, 'vertex'),
                n = aa(r, T, 'fragment')
              console.error(
                'THREE.WebGLProgram: shader error: ',
                r.getError(),
                '35715',
                r.getProgramParameter(y, 35715),
                'gl.getProgramInfoLog',
                t,
                e,
                n
              )
            } else
              '' !== t
                ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', t)
                : ('' !== e && '' !== n) || (s = !1)
            s &&
              (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: { log: e, prefix: x },
                fragmentShader: { log: n, prefix: b }
              })
          }
          let S, E
          return (
            r.deleteShader(M),
            r.deleteShader(T),
            (this.getUniforms = function () {
              return void 0 === S && (S = new ia(r, y)), S
            }),
            (this.getAttributes = function () {
              return (
                void 0 === E &&
                  (E = (function (t, e) {
                    const n = {},
                      i = t.getProgramParameter(e, 35721)
                    for (let r = 0; r < i; r++) {
                      const i = t.getActiveAttrib(e, r).name
                      n[i] = t.getAttribLocation(e, i)
                    }
                    return n
                  })(r, y)),
                E
              )
            }),
            (this.destroy = function () {
              i.releaseStatesOfProgram(this), r.deleteProgram(y), (this.program = void 0)
            }),
            (this.name = n.shaderName),
            (this.id = sa++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = y),
            (this.vertexShader = M),
            (this.fragmentShader = T),
            this
          )
        }
        function Ta(t, e, n, i, r, s) {
          const o = [],
            a = i.isWebGL2,
            l = i.logarithmicDepthBuffer,
            c = i.floatVertexTextures,
            h = i.maxVertexUniforms,
            u = i.vertexTextures
          let d = i.precision
          const p = {
              MeshDepthMaterial: 'depth',
              MeshDistanceMaterial: 'distanceRGBA',
              MeshNormalMaterial: 'normal',
              MeshBasicMaterial: 'basic',
              MeshLambertMaterial: 'lambert',
              MeshPhongMaterial: 'phong',
              MeshToonMaterial: 'toon',
              MeshStandardMaterial: 'physical',
              MeshPhysicalMaterial: 'physical',
              MeshMatcapMaterial: 'matcap',
              LineBasicMaterial: 'basic',
              LineDashedMaterial: 'dashed',
              PointsMaterial: 'points',
              ShadowMaterial: 'shadow',
              SpriteMaterial: 'sprite'
            },
            m = [
              'precision',
              'isWebGL2',
              'supportsVertexTextures',
              'outputEncoding',
              'instancing',
              'instancingColor',
              'map',
              'mapEncoding',
              'matcap',
              'matcapEncoding',
              'envMap',
              'envMapMode',
              'envMapEncoding',
              'envMapCubeUV',
              'lightMap',
              'lightMapEncoding',
              'aoMap',
              'emissiveMap',
              'emissiveMapEncoding',
              'bumpMap',
              'normalMap',
              'objectSpaceNormalMap',
              'tangentSpaceNormalMap',
              'clearcoatMap',
              'clearcoatRoughnessMap',
              'clearcoatNormalMap',
              'displacementMap',
              'specularMap',
              'roughnessMap',
              'metalnessMap',
              'gradientMap',
              'alphaMap',
              'combine',
              'vertexColors',
              'vertexAlphas',
              'vertexTangents',
              'vertexUvs',
              'uvsVertexOnly',
              'fog',
              'useFog',
              'fogExp2',
              'flatShading',
              'sizeAttenuation',
              'logarithmicDepthBuffer',
              'skinning',
              'maxBones',
              'useVertexTexture',
              'morphTargets',
              'morphNormals',
              'premultipliedAlpha',
              'numDirLights',
              'numPointLights',
              'numSpotLights',
              'numHemiLights',
              'numRectAreaLights',
              'numDirLightShadows',
              'numPointLightShadows',
              'numSpotLightShadows',
              'shadowMapEnabled',
              'shadowMapType',
              'toneMapping',
              'physicallyCorrectLights',
              'alphaTest',
              'doubleSided',
              'flipSided',
              'numClippingPlanes',
              'numClipIntersection',
              'depthPacking',
              'dithering',
              'sheen',
              'transmissionMap'
            ]
          function f(t) {
            let e
            return (
              t && t.isTexture
                ? (e = t.encoding)
                : t && t.isWebGLRenderTarget
                ? (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (e = t.texture.encoding))
                : (e = tn),
              e
            )
          }
          return {
            getParameters: function (r, o, m, g, v) {
              const y = g.fog,
                w = r.isMeshStandardMaterial ? g.environment : null,
                _ = e.get(r.envMap || w),
                M = p[r.type],
                T = v.isSkinnedMesh
                  ? (function (t) {
                      const e = t.skeleton.bones
                      if (c) return 1024
                      {
                        const t = h,
                          n = Math.floor((t - 20) / 4),
                          i = Math.min(n, e.length)
                        return i < e.length
                          ? (console.warn(
                              'THREE.WebGLRenderer: Skeleton has ' + e.length + ' bones. This GPU supports ' + i + '.'
                            ),
                            0)
                          : i
                      }
                    })(v)
                  : 0
              let S, E
              if (
                (null !== r.precision &&
                  ((d = i.getMaxPrecision(r.precision)),
                  d !== r.precision &&
                    console.warn(
                      'THREE.WebGLProgram.getParameters:',
                      r.precision,
                      'not supported, using',
                      d,
                      'instead.'
                    )),
                M)
              ) {
                const t = zs[M]
                ;(S = t.vertexShader), (E = t.fragmentShader)
              } else (S = r.vertexShader), (E = r.fragmentShader)
              const A = t.getRenderTarget()
              return {
                isWebGL2: a,
                shaderID: M,
                shaderName: r.type,
                vertexShader: S,
                fragmentShader: E,
                defines: r.defines,
                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                glslVersion: r.glslVersion,
                precision: d,
                instancing: !0 === v.isInstancedMesh,
                instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                supportsVertexTextures: u,
                outputEncoding: null !== A ? f(A.texture) : t.outputEncoding,
                map: !!r.map,
                mapEncoding: f(r.map),
                matcap: !!r.matcap,
                matcapEncoding: f(r.matcap),
                envMap: !!_,
                envMapMode: _ && _.mapping,
                envMapEncoding: f(_),
                envMapCubeUV: !!_ && (_.mapping === pt || _.mapping === mt),
                lightMap: !!r.lightMap,
                lightMapEncoding: f(r.lightMap),
                aoMap: !!r.aoMap,
                emissiveMap: !!r.emissiveMap,
                emissiveMapEncoding: f(r.emissiveMap),
                bumpMap: !!r.bumpMap,
                normalMap: !!r.normalMap,
                objectSpaceNormalMap: r.normalMapType === dn,
                tangentSpaceNormalMap: r.normalMapType === un,
                clearcoatMap: !!r.clearcoatMap,
                clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                clearcoatNormalMap: !!r.clearcoatNormalMap,
                displacementMap: !!r.displacementMap,
                roughnessMap: !!r.roughnessMap,
                metalnessMap: !!r.metalnessMap,
                specularMap: !!r.specularMap,
                alphaMap: !!r.alphaMap,
                gradientMap: !!r.gradientMap,
                sheen: !!r.sheen,
                transmissionMap: !!r.transmissionMap,
                combine: r.combine,
                vertexTangents: r.normalMap && r.vertexTangents,
                vertexColors: r.vertexColors,
                vertexAlphas:
                  !0 === r.vertexColors && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize,
                vertexUvs: !!(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatMap ||
                  r.clearcoatRoughnessMap ||
                  r.clearcoatNormalMap ||
                  r.displacementMap ||
                  r.transmissionMap
                ),
                uvsVertexOnly: !(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatNormalMap ||
                  r.transmissionMap ||
                  !r.displacementMap
                ),
                fog: !!y,
                useFog: r.fog,
                fogExp2: y && y.isFogExp2,
                flatShading: !!r.flatShading,
                sizeAttenuation: r.sizeAttenuation,
                logarithmicDepthBuffer: l,
                skinning: r.skinning && T > 0,
                maxBones: T,
                useVertexTexture: c,
                morphTargets: r.morphTargets,
                morphNormals: r.morphNormals,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numClippingPlanes: s.numPlanes,
                numClipIntersection: s.numIntersection,
                dithering: r.dithering,
                shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: r.toneMapped ? t.toneMapping : nt,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: r.premultipliedAlpha,
                alphaTest: r.alphaTest,
                doubleSided: r.side === b,
                flipSided: r.side === x,
                depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                index0AttributeName: r.index0AttributeName,
                extensionDerivatives: r.extensions && r.extensions.derivatives,
                extensionFragDepth: r.extensions && r.extensions.fragDepth,
                extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: a || n.has('EXT_frag_depth'),
                rendererExtensionDrawBuffers: a || n.has('WEBGL_draw_buffers'),
                rendererExtensionShaderTextureLod: a || n.has('EXT_shader_texture_lod'),
                customProgramCacheKey: r.customProgramCacheKey()
              }
            },
            getProgramCacheKey: function (e) {
              const n = []
              if (
                (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t])
              if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < m.length; t++) n.push(e[m[t]])
                n.push(t.outputEncoding), n.push(t.gammaFactor)
              }
              return n.push(e.customProgramCacheKey), n.join()
            },
            getUniforms: function (t) {
              const e = p[t.type]
              let n
              if (e) {
                const t = zs[e]
                n = ws.clone(t.uniforms)
              } else n = t.uniforms
              return n
            },
            acquireProgram: function (e, n) {
              let i
              for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t]
                if (e.cacheKey === n) {
                  ;(i = e), ++i.usedTimes
                  break
                }
              }
              return void 0 === i && ((i = new Ma(t, n, e, r)), o.push(i)), i
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = o.indexOf(t)
                ;(o[e] = o[o.length - 1]), o.pop(), t.destroy()
              }
            },
            programs: o
          }
        }
        function Sa() {
          let t = new WeakMap()
          return {
            get: function (e) {
              let n = t.get(e)
              return void 0 === n && ((n = {}), t.set(e, n)), n
            },
            remove: function (e) {
              t.delete(e)
            },
            update: function (e, n, i) {
              t.get(e)[n] = i
            },
            dispose: function () {
              t = new WeakMap()
            }
          }
        }
        function Ea(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.program !== e.program
            ? t.program.id - e.program.id
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id
        }
        function Aa(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id
        }
        function La(t) {
          const e = []
          let n = 0
          const i = [],
            r = [],
            s = { id: -1 }
          function o(i, r, o, a, l, c) {
            let h = e[n]
            const u = t.get(o)
            return (
              void 0 === h
                ? ((h = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: o,
                    program: u.program || s,
                    groupOrder: a,
                    renderOrder: i.renderOrder,
                    z: l,
                    group: c
                  }),
                  (e[n] = h))
                : ((h.id = i.id),
                  (h.object = i),
                  (h.geometry = r),
                  (h.material = o),
                  (h.program = u.program || s),
                  (h.groupOrder = a),
                  (h.renderOrder = i.renderOrder),
                  (h.z = l),
                  (h.group = c)),
              n++,
              h
            )
          }
          return {
            opaque: i,
            transparent: r,
            init: function () {
              ;(n = 0), (i.length = 0), (r.length = 0)
            },
            push: function (t, e, n, s, a, l) {
              const c = o(t, e, n, s, a, l)
              ;(!0 === n.transparent ? r : i).push(c)
            },
            unshift: function (t, e, n, s, a, l) {
              const c = o(t, e, n, s, a, l)
              ;(!0 === n.transparent ? r : i).unshift(c)
            },
            finish: function () {
              for (let t = n, i = e.length; t < i; t++) {
                const n = e[t]
                if (null === n.id) break
                ;(n.id = null),
                  (n.object = null),
                  (n.geometry = null),
                  (n.material = null),
                  (n.program = null),
                  (n.group = null)
              }
            },
            sort: function (t, e) {
              i.length > 1 && i.sort(t || Ea), r.length > 1 && r.sort(e || Aa)
            }
          }
        }
        function Ra(t) {
          let e = new WeakMap()
          return {
            get: function (n, i) {
              let r
              return (
                !1 === e.has(n)
                  ? ((r = new La(t)), e.set(n, [r]))
                  : i >= e.get(n).length
                  ? ((r = new La(t)), e.get(n).push(r))
                  : (r = e.get(n)[i]),
                r
              )
            },
            dispose: function () {
              e = new WeakMap()
            }
          }
        }
        function Pa() {
          const t = {}
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id]
              let n
              switch (e.type) {
                case 'DirectionalLight':
                  n = { direction: new ei(), color: new Ar() }
                  break
                case 'SpotLight':
                  n = {
                    position: new ei(),
                    direction: new ei(),
                    color: new Ar(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                  }
                  break
                case 'PointLight':
                  n = { position: new ei(), color: new Ar(), distance: 0, decay: 0 }
                  break
                case 'HemisphereLight':
                  n = { direction: new ei(), skyColor: new Ar(), groundColor: new Ar() }
                  break
                case 'RectAreaLight':
                  n = { color: new Ar(), position: new ei(), halfWidth: new ei(), halfHeight: new ei() }
              }
              return (t[e.id] = n), n
            }
          }
        }
        let Ca = 0
        function Ia(t, e) {
          return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function Da(t, e) {
          const n = new Pa(),
            i = (function () {
              const t = {}
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id]
                  let n
                  switch (e.type) {
                    case 'DirectionalLight':
                    case 'SpotLight':
                      n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Wn() }
                      break
                    case 'PointLight':
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Wn(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                      }
                  }
                  return (t[e.id] = n), n
                }
              }
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: []
            }
          for (let t = 0; t < 9; t++) r.probe.push(new ei())
          const s = new ei(),
            o = new Ii(),
            a = new Ii()
          return {
            setup: function (s) {
              let o = 0,
                a = 0,
                l = 0
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0)
              let c = 0,
                h = 0,
                u = 0,
                d = 0,
                p = 0,
                m = 0,
                f = 0,
                g = 0
              s.sort(Ia)
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  v = e.color,
                  y = e.intensity,
                  x = e.distance,
                  b = e.shadow && e.shadow.map ? e.shadow.map.texture : null
                if (e.isAmbientLight) (o += v.r * y), (a += v.g * y), (l += v.b * y)
                else if (e.isLightProbe) for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], y)
                else if (e.isDirectionalLight) {
                  const t = n.get(e)
                  if ((t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow)) {
                    const t = e.shadow,
                      n = i.get(e)
                    ;(n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[c] = n),
                      (r.directionalShadowMap[c] = b),
                      (r.directionalShadowMatrix[c] = e.shadow.matrix),
                      m++
                  }
                  ;(r.directional[c] = t), c++
                } else if (e.isSpotLight) {
                  const t = n.get(e)
                  if (
                    (t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(v).multiplyScalar(y),
                    (t.distance = x),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e)
                    ;(n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.spotShadow[u] = n),
                      (r.spotShadowMap[u] = b),
                      (r.spotShadowMatrix[u] = e.shadow.matrix),
                      g++
                  }
                  ;(r.spot[u] = t), u++
                } else if (e.isRectAreaLight) {
                  const t = n.get(e)
                  t.color.copy(v).multiplyScalar(y),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[d] = t),
                    d++
                } else if (e.isPointLight) {
                  const t = n.get(e)
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e)
                    ;(n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[h] = n),
                      (r.pointShadowMap[h] = b),
                      (r.pointShadowMatrix[h] = e.shadow.matrix),
                      f++
                  }
                  ;(r.point[h] = t), h++
                } else if (e.isHemisphereLight) {
                  const t = n.get(e)
                  t.skyColor.copy(e.color).multiplyScalar(y),
                    t.groundColor.copy(e.groundColor).multiplyScalar(y),
                    (r.hemi[p] = t),
                    p++
                }
              }
              d > 0 &&
                (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
                  ? ((r.rectAreaLTC1 = Fs.LTC_FLOAT_1), (r.rectAreaLTC2 = Fs.LTC_FLOAT_2))
                  : !0 === t.has('OES_texture_half_float_linear')
                  ? ((r.rectAreaLTC1 = Fs.LTC_HALF_1), (r.rectAreaLTC2 = Fs.LTC_HALF_2))
                  : console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.')),
                (r.ambient[0] = o),
                (r.ambient[1] = a),
                (r.ambient[2] = l)
              const v = r.hash
              ;(v.directionalLength === c &&
                v.pointLength === h &&
                v.spotLength === u &&
                v.rectAreaLength === d &&
                v.hemiLength === p &&
                v.numDirectionalShadows === m &&
                v.numPointShadows === f &&
                v.numSpotShadows === g) ||
                ((r.directional.length = c),
                (r.spot.length = u),
                (r.rectArea.length = d),
                (r.point.length = h),
                (r.hemi.length = p),
                (r.directionalShadow.length = m),
                (r.directionalShadowMap.length = m),
                (r.pointShadow.length = f),
                (r.pointShadowMap.length = f),
                (r.spotShadow.length = g),
                (r.spotShadowMap.length = g),
                (r.directionalShadowMatrix.length = m),
                (r.pointShadowMatrix.length = f),
                (r.spotShadowMatrix.length = g),
                (v.directionalLength = c),
                (v.pointLength = h),
                (v.spotLength = u),
                (v.rectAreaLength = d),
                (v.hemiLength = p),
                (v.numDirectionalShadows = m),
                (v.numPointShadows = f),
                (v.numSpotShadows = g),
                (r.version = Ca++))
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                h = 0
              const u = e.matrixWorldInverse
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e]
                if (d.isDirectionalLight) {
                  const t = r.directional[n]
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    n++
                } else if (d.isSpotLight) {
                  const t = r.spot[l]
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    l++
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c]
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    a.identity(),
                    o.copy(d.matrixWorld),
                    o.premultiply(u),
                    a.extractRotation(o),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(a),
                    t.halfHeight.applyMatrix4(a),
                    c++
                } else if (d.isPointLight) {
                  const t = r.point[i]
                  t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[h]
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(u),
                    t.direction.normalize(),
                    h++
                }
              }
            },
            state: r
          }
        }
        function Oa(t, e) {
          const n = new Da(t, e),
            i = [],
            r = []
          return {
            init: function () {
              ;(i.length = 0), (r.length = 0)
            },
            state: { lightsArray: i, shadowsArray: r, lights: n },
            setupLights: function () {
              n.setup(i)
            },
            setupLightsView: function (t) {
              n.setupView(i, t)
            },
            pushLight: function (t) {
              i.push(t)
            },
            pushShadow: function (t) {
              r.push(t)
            }
          }
        }
        function Na(t, e) {
          let n = new WeakMap()
          return {
            get: function (i, r = 0) {
              let s
              return (
                !1 === n.has(i)
                  ? ((s = new Oa(t, e)), n.set(i, [s]))
                  : r >= n.get(i).length
                  ? ((s = new Oa(t, e)), n.get(i).push(s))
                  : (s = n.get(i)[r]),
                s
              )
            },
            dispose: function () {
              n = new WeakMap()
            }
          }
        }
        class Ba extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshDepthMaterial'),
              (this.depthPacking = cn),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            )
          }
        }
        Ba.prototype.isMeshDepthMaterial = !0
        class Fa extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshDistanceMaterial'),
              (this.referencePosition = new ei()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.fog = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.referencePosition.copy(t.referencePosition),
              (this.nearDistance = t.nearDistance),
              (this.farDistance = t.farDistance),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            )
          }
        }
        function za(t, e, n) {
          let i = new Is()
          const r = new Wn(),
            s = new Wn(),
            o = new Kn(),
            a = [],
            l = [],
            c = {},
            h = n.maxTextureSize,
            u = { 0: x, 1: y, 2: b },
            d = new _s({
              defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
              uniforms: { shadow_pass: { value: null }, resolution: { value: new Wn() }, radius: { value: 4 } },
              vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
              fragmentShader:
                'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
            }),
            p = d.clone()
          p.defines.HORIZONTAL_PASS = 1
          const m = new Qr()
          m.setAttribute('position', new Cr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))
          const g = new gs(m, d),
            w = this
          function _(n, i) {
            const r = e.update(g)
            ;(d.uniforms.shadow_pass.value = n.map.texture),
              (d.uniforms.resolution.value = n.mapSize),
              (d.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, r, d, g, null),
              (p.uniforms.shadow_pass.value = n.mapPass.texture),
              (p.uniforms.resolution.value = n.mapSize),
              (p.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, r, p, g, null)
          }
          function T(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2)
            let r = a[i]
            return void 0 === r && ((r = new Ba({ depthPacking: hn, morphTargets: t, skinning: e })), (a[i] = r)), r
          }
          function S(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2)
            let r = l[i]
            return void 0 === r && ((r = new Fa({ morphTargets: t, skinning: e })), (l[i] = r)), r
          }
          function E(e, n, i, r, s, o, a) {
            let l = null,
              h = T,
              d = e.customDepthMaterial
            if ((!0 === r.isPointLight && ((h = S), (d = e.customDistanceMaterial)), void 0 === d)) {
              let t = !1
              !0 === i.morphTargets &&
                (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0)
              let r = !1
              !0 === e.isSkinnedMesh &&
                (!0 === i.skinning
                  ? (r = !0)
                  : console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', e)),
                (l = h(t, r, !0 === e.isInstancedMesh))
            } else l = d
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
              const t = l.uuid,
                e = i.uuid
              let n = c[t]
              void 0 === n && ((n = {}), (c[t] = n))
              let r = n[e]
              void 0 === r && ((r = l.clone()), (n[e] = r)), (l = r)
            }
            return (
              (l.visible = i.visible),
              (l.wireframe = i.wireframe),
              (l.side =
                a === v
                  ? null !== i.shadowSide
                    ? i.shadowSide
                    : i.side
                  : null !== i.shadowSide
                  ? i.shadowSide
                  : u[i.side]),
              (l.clipShadows = i.clipShadows),
              (l.clippingPlanes = i.clippingPlanes),
              (l.clipIntersection = i.clipIntersection),
              (l.wireframeLinewidth = i.wireframeLinewidth),
              (l.linewidth = i.linewidth),
              !0 === r.isPointLight &&
                !0 === l.isMeshDistanceMaterial &&
                (l.referencePosition.setFromMatrixPosition(r.matrixWorld), (l.nearDistance = s), (l.farDistance = o)),
              l
            )
          }
          function A(n, r, s, o, a) {
            if (!1 === n.visible) return
            if (
              n.layers.test(r.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && a === v)) &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld)
              const i = e.update(n),
                r = n.material
              if (Array.isArray(r)) {
                const e = i.groups
                for (let l = 0, c = e.length; l < c; l++) {
                  const c = e[l],
                    h = r[c.materialIndex]
                  if (h && h.visible) {
                    const e = E(n, i, h, o, s.near, s.far, a)
                    t.renderBufferDirect(s, null, i, e, n, c)
                  }
                }
              } else if (r.visible) {
                const e = E(n, i, r, o, s.near, s.far, a)
                t.renderBufferDirect(s, null, i, e, n, null)
              }
            }
            const l = n.children
            for (let t = 0, e = l.length; t < e; t++) A(l[t], r, s, o, a)
          }
          ;(this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = f),
            (this.render = function (e, n, a) {
              if (!1 === w.enabled) return
              if (!1 === w.autoUpdate && !1 === w.needsUpdate) return
              if (0 === e.length) return
              const l = t.getRenderTarget(),
                c = t.getActiveCubeFace(),
                u = t.getActiveMipmapLevel(),
                d = t.state
              d.setBlending(M), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1)
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  u = c.shadow
                if (void 0 === u) {
                  console.warn('THREE.WebGLShadowMap:', c, 'has no shadow.')
                  continue
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue
                r.copy(u.mapSize)
                const p = u.getFrameExtents()
                if (
                  (r.multiply(p),
                  s.copy(u.mapSize),
                  (r.x > h || r.y > h) &&
                    (r.x > h && ((s.x = Math.floor(h / p.x)), (r.x = s.x * p.x), (u.mapSize.x = s.x)),
                    r.y > h && ((s.y = Math.floor(h / p.y)), (r.y = s.y * p.y), (u.mapSize.y = s.y))),
                  null === u.map && !u.isPointLightShadow && this.type === v)
                ) {
                  const t = { minFilter: Mt, magFilter: Mt, format: Gt }
                  ;(u.map = new Qn(r.x, r.y, t)),
                    (u.map.texture.name = c.name + '.shadowMap'),
                    (u.mapPass = new Qn(r.x, r.y, t)),
                    u.camera.updateProjectionMatrix()
                }
                if (null === u.map) {
                  const t = { minFilter: yt, magFilter: yt, format: Gt }
                  ;(u.map = new Qn(r.x, r.y, t)),
                    (u.map.texture.name = c.name + '.shadowMap'),
                    u.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(u.map), t.clear()
                const m = u.getViewportCount()
                for (let t = 0; t < m; t++) {
                  const e = u.getViewport(t)
                  o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                    d.viewport(o),
                    u.updateMatrices(c, t),
                    (i = u.getFrustum()),
                    A(n, a, u.camera, c, this.type)
                }
                u.isPointLightShadow || this.type !== v || _(u, a), (u.needsUpdate = !1)
              }
              ;(w.needsUpdate = !1), t.setRenderTarget(l, c, u)
            })
        }
        function ka(t, e, n) {
          const i = n.isWebGL2,
            r = new (function () {
              let e = !1
              const n = new Kn()
              let i = null
              const r = new Kn(0, 0, 0, 0)
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n))
                },
                setLocked: function (t) {
                  e = t
                },
                setClear: function (e, i, s, o, a) {
                  !0 === a && ((e *= o), (i *= o), (s *= o)),
                    n.set(e, i, s, o),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                },
                reset: function () {
                  ;(e = !1), (i = null), r.set(-1, 0, 0, 0)
                }
              }
            })(),
            s = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null
              return {
                setTest: function (t) {
                  t ? gt(2929) : vt(2929)
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i))
                },
                setFunc: function (e) {
                  if (i !== e) {
                    if (e)
                      switch (e) {
                        case j:
                          t.depthFunc(512)
                          break
                        case q:
                          t.depthFunc(519)
                          break
                        case X:
                          t.depthFunc(513)
                          break
                        case Y:
                          t.depthFunc(515)
                          break
                        case Z:
                          t.depthFunc(514)
                          break
                        case J:
                          t.depthFunc(518)
                          break
                        case K:
                          t.depthFunc(516)
                          break
                        case Q:
                          t.depthFunc(517)
                          break
                        default:
                          t.depthFunc(515)
                      }
                    else t.depthFunc(515)
                    i = e
                  }
                },
                setLocked: function (t) {
                  e = t
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e))
                },
                reset: function () {
                  ;(e = !1), (n = null), (i = null), (r = null)
                }
              }
            })(),
            o = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                o = null,
                a = null,
                l = null,
                c = null
              return {
                setTest: function (t) {
                  e || (t ? gt(2960) : vt(2960))
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i))
                },
                setFunc: function (e, n, o) {
                  ;(i === e && r === n && s === o) || (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o))
                },
                setOp: function (e, n, i) {
                  ;(o === e && a === n && l === i) || (t.stencilOp(e, n, i), (o = e), (a = n), (l = i))
                },
                setLocked: function (t) {
                  e = t
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e))
                },
                reset: function () {
                  ;(e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (s = null),
                    (o = null),
                    (a = null),
                    (l = null),
                    (c = null)
                }
              }
            })()
          let a = {},
            l = null,
            c = {},
            p = null,
            m = !1,
            f = null,
            g = null,
            v = null,
            y = null,
            w = null,
            _ = null,
            $ = null,
            tt = !1,
            et = null,
            nt = null,
            it = null,
            rt = null,
            st = null
          const ot = t.getParameter(35661)
          let at = !1,
            lt = 0
          const ct = t.getParameter(7938)
          ;-1 !== ct.indexOf('WebGL')
            ? ((lt = parseFloat(/^WebGL (\d)/.exec(ct)[1])), (at = lt >= 1))
            : -1 !== ct.indexOf('OpenGL ES') && ((lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1])), (at = lt >= 2))
          let ht = null,
            ut = {}
          const dt = new Kn(0, 0, t.canvas.width, t.canvas.height),
            pt = new Kn(0, 0, t.canvas.width, t.canvas.height)
          function mt(e, n, i) {
            const r = new Uint8Array(4),
              s = t.createTexture()
            t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728)
            for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r)
            return s
          }
          const ft = {}
          function gt(e) {
            !0 !== a[e] && (t.enable(e), (a[e] = !0))
          }
          function vt(e) {
            !1 !== a[e] && (t.disable(e), (a[e] = !1))
          }
          ;(ft[3553] = mt(3553, 3553, 1)),
            (ft[34067] = mt(34067, 34069, 6)),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            o.setClear(0),
            gt(2929),
            s.setFunc(Y),
            wt(!1),
            _t(u),
            gt(2884),
            bt(M)
          const yt = { [R]: 32774, [P]: 32778, [C]: 32779 }
          if (i) (yt[I] = 32775), (yt[D] = 32776)
          else {
            const t = e.get('EXT_blend_minmax')
            null !== t && ((yt[I] = t.MIN_EXT), (yt[D] = t.MAX_EXT))
          }
          const xt = {
            [O]: 0,
            [N]: 1,
            [B]: 768,
            [z]: 770,
            [W]: 776,
            [G]: 774,
            [U]: 772,
            [F]: 769,
            [k]: 771,
            [V]: 775,
            [H]: 773
          }
          function bt(e, n, i, r, s, o, a, l) {
            if (e !== M) {
              if ((!1 === m && (gt(3042), (m = !0)), e === L))
                (s = s || n),
                  (o = o || i),
                  (a = a || r),
                  (n === g && s === w) || (t.blendEquationSeparate(yt[n], yt[s]), (g = n), (w = s)),
                  (i === v && r === y && o === _ && a === $) ||
                    (t.blendFuncSeparate(xt[i], xt[r], xt[o], xt[a]), (v = i), (y = r), (_ = o), ($ = a)),
                  (f = e),
                  (tt = null)
              else if (e !== f || l !== tt) {
                if (((g === R && w === R) || (t.blendEquation(32774), (g = R), (w = R)), l))
                  switch (e) {
                    case T:
                      t.blendFuncSeparate(1, 771, 1, 771)
                      break
                    case S:
                      t.blendFunc(1, 1)
                      break
                    case E:
                      t.blendFuncSeparate(0, 0, 769, 771)
                      break
                    case A:
                      t.blendFuncSeparate(0, 768, 0, 770)
                      break
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', e)
                  }
                else
                  switch (e) {
                    case T:
                      t.blendFuncSeparate(770, 771, 1, 771)
                      break
                    case S:
                      t.blendFunc(770, 1)
                      break
                    case E:
                      t.blendFunc(0, 769)
                      break
                    case A:
                      t.blendFunc(0, 768)
                      break
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', e)
                  }
                ;(v = null), (y = null), (_ = null), ($ = null), (f = e), (tt = l)
              }
            } else !0 === m && (vt(3042), (m = !1))
          }
          function wt(e) {
            et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (et = e))
          }
          function _t(e) {
            e !== h
              ? (gt(2884), e !== nt && (e === u ? t.cullFace(1029) : e === d ? t.cullFace(1028) : t.cullFace(1032)))
              : vt(2884),
              (nt = e)
          }
          function Mt(e, n, i) {
            e ? (gt(32823), (rt === n && st === i) || (t.polygonOffset(n, i), (rt = n), (st = i))) : vt(32823)
          }
          function Tt(e) {
            void 0 === e && (e = 33984 + ot - 1), ht !== e && (t.activeTexture(e), (ht = e))
          }
          return {
            buffers: { color: r, depth: s, stencil: o },
            enable: gt,
            disable: vt,
            bindFramebuffer: function (e, n) {
              null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), (c[e] = n))
            },
            bindXRFramebuffer: function (e) {
              e !== l && (t.bindFramebuffer(36160, e), (l = e))
            },
            useProgram: function (e) {
              return p !== e && (t.useProgram(e), (p = e), !0)
            },
            setBlending: bt,
            setMaterial: function (t, e) {
              t.side === b ? vt(2884) : gt(2884)
              let n = t.side === x
              e && (n = !n),
                wt(n),
                t.blending === T && !1 === t.transparent
                  ? bt(M)
                  : bt(
                      t.blending,
                      t.blendEquation,
                      t.blendSrc,
                      t.blendDst,
                      t.blendEquationAlpha,
                      t.blendSrcAlpha,
                      t.blendDstAlpha,
                      t.premultipliedAlpha
                    ),
                s.setFunc(t.depthFunc),
                s.setTest(t.depthTest),
                s.setMask(t.depthWrite),
                r.setMask(t.colorWrite)
              const i = t.stencilWrite
              o.setTest(i),
                i &&
                  (o.setMask(t.stencilWriteMask),
                  o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                  o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                Mt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                !0 === t.alphaToCoverage ? gt(32926) : vt(32926)
            },
            setFlipSided: wt,
            setCullFace: _t,
            setLineWidth: function (e) {
              e !== it && (at && t.lineWidth(e), (it = e))
            },
            setPolygonOffset: Mt,
            setScissorTest: function (t) {
              t ? gt(3089) : vt(3089)
            },
            activeTexture: Tt,
            bindTexture: function (e, n) {
              null === ht && Tt()
              let i = ut[ht]
              void 0 === i && ((i = { type: void 0, texture: void 0 }), (ut[ht] = i)),
                (i.type === e && i.texture === n) || (t.bindTexture(e, n || ft[e]), (i.type = e), (i.texture = n))
            },
            unbindTexture: function () {
              const e = ut[ht]
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0))
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments)
              } catch (t) {
                console.error('THREE.WebGLState:', t)
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments)
              } catch (t) {
                console.error('THREE.WebGLState:', t)
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments)
              } catch (t) {
                console.error('THREE.WebGLState:', t)
              }
            },
            scissor: function (e) {
              !1 === dt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), dt.copy(e))
            },
            viewport: function (e) {
              !1 === pt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), pt.copy(e))
            },
            reset: function () {
              t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (a = {}),
                (ht = null),
                (ut = {}),
                (l = null),
                (c = {}),
                (p = null),
                (m = !1),
                (f = null),
                (g = null),
                (v = null),
                (y = null),
                (w = null),
                (_ = null),
                ($ = null),
                (tt = !1),
                (et = null),
                (nt = null),
                (it = null),
                (rt = null),
                (st = null),
                dt.set(0, 0, t.canvas.width, t.canvas.height),
                pt.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                o.reset()
            }
          }
        }
        function Ua(t, e, n, i, r, s, o) {
          const a = r.isWebGL2,
            l = r.maxTextures,
            c = r.maxCubemapSize,
            h = r.maxTextureSize,
            u = r.maxSamples,
            d = new WeakMap()
          let p,
            m = !1
          try {
            m = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d')
          } catch (t) {}
          function f(t, e) {
            return m ? new OffscreenCanvas(t, e) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
          }
          function g(t, e, n, i) {
            let r = 1
            if (((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e)) {
              if (
                ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
                ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
                ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? Vn.floorPowerOfTwo : Math.floor,
                  s = i(r * t.width),
                  o = i(r * t.height)
                void 0 === p && (p = f(s, o))
                const a = n ? f(s, o) : p
                return (
                  (a.width = s),
                  (a.height = o),
                  a.getContext('2d').drawImage(t, 0, 0, s, o),
                  console.warn(
                    'THREE.WebGLRenderer: Texture has been resized from (' +
                      t.width +
                      'x' +
                      t.height +
                      ') to (' +
                      s +
                      'x' +
                      o +
                      ').'
                  ),
                  a
                )
              }
              return (
                'data' in t &&
                  console.warn(
                    'THREE.WebGLRenderer: Image in DataTexture is too big (' + t.width + 'x' + t.height + ').'
                  ),
                t
              )
            }
            return t
          }
          function v(t) {
            return Vn.isPowerOfTwo(t.width) && Vn.isPowerOfTwo(t.height)
          }
          function y(t, e) {
            return t.generateMipmaps && e && t.minFilter !== yt && t.minFilter !== Mt
          }
          function x(e, n, r, s) {
            t.generateMipmap(e), (i.get(n).__maxMipLevel = Math.log2(Math.max(r, s)))
          }
          function b(n, i, r) {
            if (!1 === a) return i
            if (null !== n) {
              if (void 0 !== t[n]) return t[n]
              console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let s = i
            return (
              6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)),
              6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)),
              6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)),
              (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) || e.get('EXT_color_buffer_float'),
              s
            )
          }
          function w(t) {
            return t === yt || t === xt || t === wt ? 9728 : 9729
          }
          function _(e) {
            const n = e.target
            n.removeEventListener('dispose', _),
              (function (e) {
                const n = i.get(e)
                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
              })(n),
              n.isVideoTexture && d.delete(n),
              o.memory.textures--
          }
          function M(e) {
            const n = e.target
            n.removeEventListener('dispose', M),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  s = i.get(n)
                if (e) {
                  if (
                    (void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLCubeRenderTarget)
                  )
                    for (let e = 0; e < 6; e++)
                      t.deleteFramebuffer(r.__webglFramebuffer[e]),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e])
                  else
                    t.deleteFramebuffer(r.__webglFramebuffer),
                      r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                      r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                      r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                      r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                  i.remove(n), i.remove(e)
                }
              })(n),
              o.memory.textures--
          }
          let T = 0
          function S(t, e) {
            const r = i.get(t)
            if (
              (t.isVideoTexture &&
                (function (t) {
                  const e = o.render.frame
                  d.get(t) !== e && (d.set(t, e), t.update())
                })(t),
              t.version > 0 && r.__version !== t.version)
            ) {
              const n = t.image
              if (void 0 === n) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined')
              else {
                if (!1 !== n.complete) return void C(r, t, e)
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')
              }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
          }
          function E(e, r) {
            const o = i.get(e)
            e.version > 0 && o.__version !== e.version
              ? (function (e, i, r) {
                  if (6 !== i.image.length) return
                  P(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0)
                  const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                    l = i.image[0] && i.image[0].isDataTexture,
                    h = []
                  for (let t = 0; t < 6; t++)
                    h[t] = o || l ? (l ? i.image[t].image : i.image[t]) : g(i.image[t], !1, !0, c)
                  const u = h[0],
                    d = v(u) || a,
                    p = s.convert(i.format),
                    m = s.convert(i.type),
                    f = b(i.internalFormat, p, m)
                  let w
                  if ((R(34067, i, d), o)) {
                    for (let t = 0; t < 6; t++) {
                      w = h[t].mipmaps
                      for (let e = 0; e < w.length; e++) {
                        const r = w[e]
                        i.format !== Gt && i.format !== Ht
                          ? null !== p
                            ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data)
                            : console.warn(
                                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                              )
                          : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                      }
                    }
                    e.__maxMipLevel = w.length - 1
                  } else {
                    w = i.mipmaps
                    for (let t = 0; t < 6; t++)
                      if (l) {
                        n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data)
                        for (let e = 0; e < w.length; e++) {
                          const i = w[e].image[t].image
                          n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                        }
                      } else {
                        n.texImage2D(34069 + t, 0, f, p, m, h[t])
                        for (let e = 0; e < w.length; e++) {
                          const i = w[e]
                          n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                        }
                      }
                    e.__maxMipLevel = w.length
                  }
                  y(i, d) && x(34067, i, u.width, u.height), (e.__version = i.version), i.onUpdate && i.onUpdate(i)
                })(o, e, r)
              : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
          }
          const A = { [ft]: 10497, [gt]: 33071, [vt]: 33648 },
            L = { [yt]: 9728, [xt]: 9984, [wt]: 9986, [Mt]: 9729, [Tt]: 9985, [Et]: 9987 }
          function R(n, s, o) {
            if (
              (o
                ? (t.texParameteri(n, 10242, A[s.wrapS]),
                  t.texParameteri(n, 10243, A[s.wrapT]),
                  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, A[s.wrapR]),
                  t.texParameteri(n, 10240, L[s.magFilter]),
                  t.texParameteri(n, 10241, L[s.minFilter]))
                : (t.texParameteri(n, 10242, 33071),
                  t.texParameteri(n, 10243, 33071),
                  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
                  (s.wrapS === gt && s.wrapT === gt) ||
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
                    ),
                  t.texParameteri(n, 10240, w(s.magFilter)),
                  t.texParameteri(n, 10241, w(s.minFilter)),
                  s.minFilter !== yt &&
                    s.minFilter !== Mt &&
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
                    )),
              !0 === e.has('EXT_texture_filter_anisotropic'))
            ) {
              const o = e.get('EXT_texture_filter_anisotropic')
              if (s.type === Ot && !1 === e.has('OES_texture_float_linear')) return
              if (!1 === a && s.type === Nt && !1 === e.has('OES_texture_half_float_linear')) return
              ;(s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                (i.get(s).__currentAnisotropy = s.anisotropy))
            }
          }
          function P(e, n) {
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0),
              n.addEventListener('dispose', _),
              (e.__webglTexture = t.createTexture()),
              o.memory.textures++)
          }
          function C(e, i, r) {
            let o = 3553
            i.isDataTexture2DArray && (o = 35866),
              i.isDataTexture3D && (o = 32879),
              P(e, i),
              n.activeTexture(33984 + r),
              n.bindTexture(o, e.__webglTexture),
              t.pixelStorei(37440, i.flipY),
              t.pixelStorei(37441, i.premultiplyAlpha),
              t.pixelStorei(3317, i.unpackAlignment),
              t.pixelStorei(37443, 0)
            const l =
                (function (t) {
                  return !a && (t.wrapS !== gt || t.wrapT !== gt || (t.minFilter !== yt && t.minFilter !== Mt))
                })(i) && !1 === v(i.image),
              c = g(i.image, l, !1, h),
              u = v(c) || a,
              d = s.convert(i.format)
            let p,
              m = s.convert(i.type),
              f = b(i.internalFormat, d, m)
            R(o, i, u)
            const w = i.mipmaps
            if (i.isDepthTexture)
              (f = 6402),
                a
                  ? (f = i.type === Ot ? 36012 : i.type === Dt ? 33190 : i.type === kt ? 35056 : 33189)
                  : i.type === Ot && console.error('WebGLRenderer: Floating point depth texture requires WebGL2.'),
                i.format === qt &&
                  6402 === f &&
                  i.type !== Ct &&
                  i.type !== Dt &&
                  (console.warn(
                    'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
                  ),
                  (i.type = Ct),
                  (m = s.convert(i.type))),
                i.format === Xt &&
                  6402 === f &&
                  ((f = 34041),
                  i.type !== kt &&
                    (console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'),
                    (i.type = kt),
                    (m = s.convert(i.type)))),
                n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null)
            else if (i.isDataTexture)
              if (w.length > 0 && u) {
                for (let t = 0, e = w.length; t < e; t++)
                  (p = w[t]), n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data)
                ;(i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1)
              } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), (e.__maxMipLevel = 0)
            else if (i.isCompressedTexture) {
              for (let t = 0, e = w.length; t < e; t++)
                (p = w[t]),
                  i.format !== Gt && i.format !== Ht
                    ? null !== d
                      ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data)
                      : console.warn(
                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                        )
                    : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data)
              e.__maxMipLevel = w.length - 1
            } else if (i.isDataTexture2DArray)
              n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), (e.__maxMipLevel = 0)
            else if (i.isDataTexture3D)
              n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), (e.__maxMipLevel = 0)
            else if (w.length > 0 && u) {
              for (let t = 0, e = w.length; t < e; t++) (p = w[t]), n.texImage2D(3553, t, f, d, m, p)
              ;(i.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1)
            } else n.texImage2D(3553, 0, f, d, m, c), (e.__maxMipLevel = 0)
            y(i, u) && x(o, i, c.width, c.height), (e.__version = i.version), i.onUpdate && i.onUpdate(i)
          }
          function I(e, r, o, a) {
            const l = r.texture,
              c = s.convert(l.format),
              h = s.convert(l.type),
              u = b(l.internalFormat, c, h)
            32879 === a || 35866 === a
              ? n.texImage3D(a, 0, u, r.width, r.height, r.depth, 0, c, h, null)
              : n.texImage2D(a, 0, u, r.width, r.height, 0, c, h, null),
              n.bindFramebuffer(36160, e),
              t.framebufferTexture2D(36160, o, a, i.get(l).__webglTexture, 0),
              n.bindFramebuffer(36160, null)
          }
          function D(e, n, i) {
            if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
              let r = 33189
              if (i) {
                const e = n.depthTexture
                e && e.isDepthTexture && (e.type === Ot ? (r = 36012) : e.type === Dt && (r = 33190))
                const i = O(n)
                t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
              } else t.renderbufferStorage(36161, r, n.width, n.height)
              t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
              if (i) {
                const e = O(n)
                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
              } else t.renderbufferStorage(36161, 34041, n.width, n.height)
              t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
              const e = n.texture,
                r = s.convert(e.format),
                o = s.convert(e.type),
                a = b(e.internalFormat, r, o)
              if (i) {
                const e = O(n)
                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
              } else t.renderbufferStorage(36161, a, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
          }
          function O(t) {
            return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
          }
          let N = !1,
            B = !1
          ;(this.allocateTextureUnit = function () {
            const t = T
            return (
              t >= l &&
                console.warn(
                  'THREE.WebGLTextures: Trying to use ' + t + ' texture units while this GPU supports only ' + l
                ),
              (T += 1),
              t
            )
          }),
            (this.resetTextureUnits = function () {
              T = 0
            }),
            (this.setTexture2D = S),
            (this.setTexture2DArray = function (t, e) {
              const r = i.get(t)
              t.version > 0 && r.__version !== t.version
                ? C(r, t, e)
                : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
            }),
            (this.setTexture3D = function (t, e) {
              const r = i.get(t)
              t.version > 0 && r.__version !== t.version
                ? C(r, t, e)
                : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
            }),
            (this.setTextureCube = E),
            (this.setupRenderTarget = function (e) {
              const r = e.texture,
                l = i.get(e),
                c = i.get(r)
              e.addEventListener('dispose', M),
                (c.__webglTexture = t.createTexture()),
                (c.__version = r.version),
                o.memory.textures++
              const h = !0 === e.isWebGLCubeRenderTarget,
                u = !0 === e.isWebGLMultisampleRenderTarget,
                d = r.isDataTexture3D || r.isDataTexture2DArray,
                p = v(e) || a
              if (
                (!a ||
                  r.format !== Ht ||
                  (r.type !== Ot && r.type !== Nt) ||
                  ((r.format = Gt),
                  console.warn(
                    'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.'
                  )),
                h)
              ) {
                l.__webglFramebuffer = []
                for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
              } else if (((l.__webglFramebuffer = t.createFramebuffer()), u))
                if (a) {
                  ;(l.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (l.__webglColorRenderbuffer = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, l.__webglColorRenderbuffer)
                  const i = s.convert(r.format),
                    o = s.convert(r.type),
                    a = b(r.internalFormat, i, o),
                    c = O(e)
                  t.renderbufferStorageMultisample(36161, c, a, e.width, e.height),
                    n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer &&
                      ((l.__webglDepthRenderbuffer = t.createRenderbuffer()), D(l.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null)
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')
              if (h) {
                n.bindTexture(34067, c.__webglTexture), R(34067, r, p)
                for (let t = 0; t < 6; t++) I(l.__webglFramebuffer[t], e, 36064, 34069 + t)
                y(r, p) && x(34067, r, e.width, e.height), n.bindTexture(34067, null)
              } else {
                let t = 3553
                d &&
                  (a
                    ? (t = r.isDataTexture3D ? 32879 : 35866)
                    : console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.')),
                  n.bindTexture(t, c.__webglTexture),
                  R(t, r, p),
                  I(l.__webglFramebuffer, e, 36064, t),
                  y(r, p) && x(3553, r, e.width, e.height),
                  n.bindTexture(3553, null)
              }
              e.depthBuffer &&
                (function (e) {
                  const r = i.get(e),
                    s = !0 === e.isWebGLCubeRenderTarget
                  if (e.depthTexture) {
                    if (s) throw new Error('target.depthTexture not supported in Cube render targets')
                    !(function (e, r) {
                      if (r && r.isWebGLCubeRenderTarget)
                        throw new Error('Depth Texture with cube render targets is not supported')
                      if ((n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture))
                        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
                      ;(i.get(r.depthTexture).__webglTexture &&
                        r.depthTexture.image.width === r.width &&
                        r.depthTexture.image.height === r.height) ||
                        ((r.depthTexture.image.width = r.width),
                        (r.depthTexture.image.height = r.height),
                        (r.depthTexture.needsUpdate = !0)),
                        S(r.depthTexture, 0)
                      const s = i.get(r.depthTexture).__webglTexture
                      if (r.depthTexture.format === qt) t.framebufferTexture2D(36160, 36096, 3553, s, 0)
                      else {
                        if (r.depthTexture.format !== Xt) throw new Error('Unknown depthTexture format')
                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                      }
                    })(r.__webglFramebuffer, e)
                  } else if (s) {
                    r.__webglDepthbuffer = []
                    for (let i = 0; i < 6; i++)
                      n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                        (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                        D(r.__webglDepthbuffer[i], e, !1)
                  } else
                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                      (r.__webglDepthbuffer = t.createRenderbuffer()),
                      D(r.__webglDepthbuffer, e, !1)
                  n.bindFramebuffer(36160, null)
                })(e)
            }),
            (this.updateRenderTargetMipmap = function (t) {
              const e = t.texture
              if (y(e, v(t) || a)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  s = i.get(e).__webglTexture
                n.bindTexture(r, s), x(r, e, t.width, t.height), n.bindTexture(r, null)
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (e.isWebGLMultisampleRenderTarget)
                if (a) {
                  const r = i.get(e)
                  n.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, r.__webglFramebuffer)
                  const s = e.width,
                    o = e.height
                  let a = 16384
                  e.depthBuffer && (a |= 256),
                    e.stencilBuffer && (a |= 1024),
                    t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728),
                    n.bindFramebuffer(36160, r.__webglMultisampledFramebuffer)
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.')
            }),
            (this.safeSetTexture2D = function (t, e) {
              t &&
                t.isWebGLRenderTarget &&
                (!1 === N &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (N = !0)),
                (t = t.texture)),
                S(t, e)
            }),
            (this.safeSetTextureCube = function (t, e) {
              t &&
                t.isWebGLCubeRenderTarget &&
                (!1 === B &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                  ),
                  (B = !0)),
                (t = t.texture)),
                E(t, e)
            })
        }
        function Ha(t, e, n) {
          const i = n.isWebGL2
          return {
            convert: function (t) {
              let n
              if (t === Lt) return 5121
              if (t === Bt) return 32819
              if (t === Ft) return 32820
              if (t === zt) return 33635
              if (t === Rt) return 5120
              if (t === Pt) return 5122
              if (t === Ct) return 5123
              if (t === It) return 5124
              if (t === Dt) return 5125
              if (t === Ot) return 5126
              if (t === Nt)
                return i ? 5131 : ((n = e.get('OES_texture_half_float')), null !== n ? n.HALF_FLOAT_OES : null)
              if (t === Ut) return 6406
              if (t === Ht) return 6407
              if (t === Gt) return 6408
              if (t === Vt) return 6409
              if (t === Wt) return 6410
              if (t === qt) return 6402
              if (t === Xt) return 34041
              if (t === Yt) return 6403
              if (t === Zt) return 36244
              if (t === Jt) return 33319
              if (t === Kt) return 33320
              if (t === Qt) return 36248
              if (t === $t) return 36249
              if (t === te || t === ee || t === ne || t === ie) {
                if (((n = e.get('WEBGL_compressed_texture_s3tc')), null === n)) return null
                if (t === te) return n.COMPRESSED_RGB_S3TC_DXT1_EXT
                if (t === ee) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT
                if (t === ne) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT
                if (t === ie) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
              }
              if (t === re || t === se || t === oe || t === ae) {
                if (((n = e.get('WEBGL_compressed_texture_pvrtc')), null === n)) return null
                if (t === re) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
                if (t === se) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
                if (t === oe) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
                if (t === ae) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
              }
              if (t === le)
                return (n = e.get('WEBGL_compressed_texture_etc1')), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
              if ((t === ce || t === he) && ((n = e.get('WEBGL_compressed_texture_etc')), null !== n)) {
                if (t === ce) return n.COMPRESSED_RGB8_ETC2
                if (t === he) return n.COMPRESSED_RGBA8_ETC2_EAC
              }
              return t === ue ||
                t === de ||
                t === pe ||
                t === me ||
                t === fe ||
                t === ge ||
                t === ve ||
                t === ye ||
                t === xe ||
                t === be ||
                t === we ||
                t === _e ||
                t === Me ||
                t === Te ||
                t === Ee ||
                t === Ae ||
                t === Le ||
                t === Re ||
                t === Pe ||
                t === Ce ||
                t === Ie ||
                t === De ||
                t === Oe ||
                t === Ne ||
                t === Be ||
                t === Fe ||
                t === ze ||
                t === ke
                ? ((n = e.get('WEBGL_compressed_texture_astc')), null !== n ? t : null)
                : t === Se
                ? ((n = e.get('EXT_texture_compression_bptc')), null !== n ? t : null)
                : t === kt
                ? i
                  ? 34042
                  : ((n = e.get('WEBGL_depth_texture')), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0
            }
          }
        }
        Fa.prototype.isMeshDistanceMaterial = !0
        class Ga extends Ts {
          constructor(t = []) {
            super(), (this.cameras = t)
          }
        }
        Ga.prototype.isArrayCamera = !0
        class Va extends ir {
          constructor() {
            super(), (this.type = 'Group')
          }
        }
        function Wa() {
          ;(this._targetRay = null), (this._grip = null), (this._hand = null)
        }
        function ja(t, e) {
          const n = this,
            i = t.state
          let r = null,
            s = 1,
            o = null,
            a = 'local-floor',
            l = null
          const c = [],
            h = new Map(),
            u = new Ts()
          u.layers.enable(1), (u.viewport = new Kn())
          const d = new Ts()
          d.layers.enable(2), (d.viewport = new Kn())
          const p = [u, d],
            m = new Ga()
          m.layers.enable(1), m.layers.enable(2)
          let f = null,
            g = null
          function v(t) {
            const e = h.get(t.inputSource)
            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
          }
          function y() {
            h.forEach(function (t, e) {
              t.disconnect(e)
            }),
              h.clear(),
              (f = null),
              (g = null),
              i.bindXRFramebuffer(null),
              t.setRenderTarget(t.getRenderTarget()),
              T.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: 'sessionend' })
          }
          function x(t) {
            const e = r.inputSources
            for (let t = 0; t < c.length; t++) h.set(e[t], c[t])
            for (let e = 0; e < t.removed.length; e++) {
              const n = t.removed[e],
                i = h.get(n)
              i && (i.dispatchEvent({ type: 'disconnected', data: n }), h.delete(n))
            }
            for (let e = 0; e < t.added.length; e++) {
              const n = t.added[e],
                i = h.get(n)
              i && i.dispatchEvent({ type: 'connected', data: n })
            }
          }
          ;(this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = c[t]
              return void 0 === e && ((e = new Wa()), (c[t] = e)), e.getTargetRaySpace()
            }),
            (this.getControllerGrip = function (t) {
              let e = c[t]
              return void 0 === e && ((e = new Wa()), (c[t] = e)), e.getGripSpace()
            }),
            (this.getHand = function (t) {
              let e = c[t]
              return void 0 === e && ((e = new Wa()), (c[t] = e)), e.getHandSpace()
            }),
            (this.setFramebufferScaleFactor = function (t) {
              ;(s = t),
                !0 === n.isPresenting &&
                  console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.')
            }),
            (this.setReferenceSpaceType = function (t) {
              ;(a = t),
                !0 === n.isPresenting &&
                  console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.')
            }),
            (this.getReferenceSpace = function () {
              return o
            }),
            (this.getSession = function () {
              return r
            }),
            (this.setSession = async function (t) {
              if (((r = t), null !== r)) {
                r.addEventListener('select', v),
                  r.addEventListener('selectstart', v),
                  r.addEventListener('selectend', v),
                  r.addEventListener('squeeze', v),
                  r.addEventListener('squeezestart', v),
                  r.addEventListener('squeezeend', v),
                  r.addEventListener('end', y),
                  r.addEventListener('inputsourceschange', x)
                const t = e.getContextAttributes()
                !0 !== t.xrCompatible && (await e.makeXRCompatible())
                const i = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: s
                  },
                  l = new XRWebGLLayer(r, e, i)
                r.updateRenderState({ baseLayer: l }),
                  (o = await r.requestReferenceSpace(a)),
                  T.setContext(r),
                  T.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: 'sessionstart' })
              }
            })
          const b = new ei(),
            w = new ei()
          function _(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert()
          }
          this.getCamera = function (t) {
            ;(m.near = d.near = u.near = t.near),
              (m.far = d.far = u.far = t.far),
              (f === m.near && g === m.far) ||
                (r.updateRenderState({ depthNear: m.near, depthFar: m.far }), (f = m.near), (g = m.far))
            const e = t.parent,
              n = m.cameras
            _(m, e)
            for (let t = 0; t < n.length; t++) _(n[t], e)
            t.matrixWorld.copy(m.matrixWorld),
              t.matrix.copy(m.matrix),
              t.matrix.decompose(t.position, t.quaternion, t.scale)
            const i = t.children
            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0)
            return (
              2 === n.length
                ? (function (t, e, n) {
                    b.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld)
                    const i = b.distanceTo(w),
                      r = e.projectionMatrix.elements,
                      s = n.projectionMatrix.elements,
                      o = r[14] / (r[10] - 1),
                      a = r[14] / (r[10] + 1),
                      l = (r[9] + 1) / r[5],
                      c = (r[9] - 1) / r[5],
                      h = (r[8] - 1) / r[0],
                      u = (s[8] + 1) / s[0],
                      d = o * h,
                      p = o * u,
                      m = i / (-h + u),
                      f = m * -h
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(f),
                      t.translateZ(m),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert()
                    const g = o + m,
                      v = a + m,
                      y = d - f,
                      x = p + (i - f),
                      _ = ((l * a) / v) * g,
                      M = ((c * a) / v) * g
                    t.projectionMatrix.makePerspective(y, x, _, M, g, v)
                  })(m, u, d)
                : m.projectionMatrix.copy(u.projectionMatrix),
              m
            )
          }
          let M = null
          const T = new Ds()
          T.setAnimationLoop(function (t, e) {
            if (((l = e.getViewerPose(o)), null !== l)) {
              const t = l.views,
                e = r.renderState.baseLayer
              i.bindXRFramebuffer(e.framebuffer)
              let n = !1
              t.length !== m.cameras.length && ((m.cameras.length = 0), (n = !0))
              for (let i = 0; i < t.length; i++) {
                const r = t[i],
                  s = e.getViewport(r),
                  o = p[i]
                o.matrix.fromArray(r.transform.matrix),
                  o.projectionMatrix.fromArray(r.projectionMatrix),
                  o.viewport.set(s.x, s.y, s.width, s.height),
                  0 === i && m.matrix.copy(o.matrix),
                  !0 === n && m.cameras.push(o)
              }
            }
            const n = r.inputSources
            for (let t = 0; t < c.length; t++) {
              const i = c[t],
                r = n[t]
              i.update(r, e, o)
            }
            M && M(t, e)
          }),
            (this.setAnimationLoop = function (t) {
              M = t
            }),
            (this.dispose = function () {})
        }
        function qa(t) {
          function e(e, n) {
            ;(e.opacity.value = n.opacity),
              n.color && e.diffuse.value.copy(n.color),
              n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
              n.map && (e.map.value = n.map),
              n.alphaMap && (e.alphaMap.value = n.alphaMap),
              n.specularMap && (e.specularMap.value = n.specularMap)
            const i = t.get(n).envMap
            if (i) {
              ;(e.envMap.value = i),
                (e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
                (e.reflectivity.value = n.reflectivity),
                (e.refractionRatio.value = n.refractionRatio)
              const r = t.get(i).__maxMipLevel
              void 0 !== r && (e.maxMipLevel.value = r)
            }
            let r, s
            n.lightMap && ((e.lightMap.value = n.lightMap), (e.lightMapIntensity.value = n.lightMapIntensity)),
              n.aoMap && ((e.aoMap.value = n.aoMap), (e.aoMapIntensity.value = n.aoMapIntensity)),
              n.map
                ? (r = n.map)
                : n.specularMap
                ? (r = n.specularMap)
                : n.displacementMap
                ? (r = n.displacementMap)
                : n.normalMap
                ? (r = n.normalMap)
                : n.bumpMap
                ? (r = n.bumpMap)
                : n.roughnessMap
                ? (r = n.roughnessMap)
                : n.metalnessMap
                ? (r = n.metalnessMap)
                : n.alphaMap
                ? (r = n.alphaMap)
                : n.emissiveMap
                ? (r = n.emissiveMap)
                : n.clearcoatMap
                ? (r = n.clearcoatMap)
                : n.clearcoatNormalMap
                ? (r = n.clearcoatNormalMap)
                : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
              void 0 !== r &&
                (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
              n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
              void 0 !== s &&
                (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix))
          }
          function n(e, n) {
            ;(e.roughness.value = n.roughness),
              (e.metalness.value = n.metalness),
              n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
              n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
              n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
              n.bumpMap &&
                ((e.bumpMap.value = n.bumpMap),
                (e.bumpScale.value = n.bumpScale),
                n.side === x && (e.bumpScale.value *= -1)),
              n.normalMap &&
                ((e.normalMap.value = n.normalMap),
                e.normalScale.value.copy(n.normalScale),
                n.side === x && e.normalScale.value.negate()),
              n.displacementMap &&
                ((e.displacementMap.value = n.displacementMap),
                (e.displacementScale.value = n.displacementScale),
                (e.displacementBias.value = n.displacementBias)),
              t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
          }
          return {
            refreshFogUniforms: function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density)
            },
            refreshMaterialUniforms: function (t, i, r, s) {
              i.isMeshBasicMaterial
                ? e(t, i)
                : i.isMeshLambertMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                  })(t, i))
                : i.isMeshToonMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        e.side === x && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        e.side === x && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias))
                  })(t, i))
                : i.isMeshPhongMaterial
                ? (e(t, i),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4)),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        e.side === x && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        e.side === x && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias))
                  })(t, i))
                : i.isMeshStandardMaterial
                ? (e(t, i),
                  i.isMeshPhysicalMaterial
                    ? (function (t, e) {
                        n(t, e),
                          (t.reflectivity.value = e.reflectivity),
                          (t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.sheen && t.sheen.value.copy(e.sheen),
                          e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                          e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                          e.clearcoatNormalMap &&
                            (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                            (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            e.side === x && t.clearcoatNormalScale.value.negate()),
                          (t.transmission.value = e.transmission),
                          e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                      })(t, i)
                    : n(t, i))
                : i.isMeshMatcapMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        e.side === x && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        e.side === x && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias))
                  })(t, i))
                : i.isMeshDepthMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                  })(t, i))
                : i.isMeshDistanceMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias)),
                      t.referencePosition.value.copy(e.referencePosition),
                      (t.nearDistance.value = e.nearDistance),
                      (t.farDistance.value = e.farDistance)
                  })(t, i))
                : i.isMeshNormalMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === x && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        e.side === x && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias))
                  })(t, i))
                : i.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity)
                  })(t, i),
                  i.isLineDashedMaterial &&
                    (function (t, e) {
                      ;(t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale)
                    })(t, i))
                : i.isPointsMaterial
                ? (function (t, e, n, i) {
                    let r
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * n),
                      (t.scale.value = 0.5 * i),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
                      void 0 !== r &&
                        (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                  })(t, i, r, s)
                : i.isSpriteMaterial
                ? (function (t, e) {
                    let n
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                      void 0 !== n &&
                        (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                  })(t, i)
                : i.isShadowMaterial
                ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
                : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
          }
        }
        function Xa(t) {
          const e =
              void 0 !== (t = t || {}).canvas
                ? t.canvas
                : (function () {
                    const t = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
                    return (t.style.display = 'block'), t
                  })(),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            s = void 0 === t.stencil || t.stencil,
            o = void 0 !== t.antialias && t.antialias,
            a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            c = void 0 !== t.powerPreference ? t.powerPreference : 'default',
            h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat
          let u = null,
            d = null
          const p = [],
            m = []
          ;(this.domElement = e),
            (this.debug = { checkShaderErrors: !0 }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.gammaFactor = 2),
            (this.outputEncoding = tn),
            (this.physicallyCorrectLights = !1),
            (this.toneMapping = nt),
            (this.toneMappingExposure = 1)
          const f = this
          let g = !1,
            v = 0,
            y = 0,
            x = null,
            b = -1,
            w = null
          const _ = new Kn(),
            M = new Kn()
          let T = null,
            S = e.width,
            E = e.height,
            A = 1,
            L = null,
            R = null
          const P = new Kn(0, 0, S, E),
            C = new Kn(0, 0, S, E)
          let I = !1
          const D = new Is()
          let O = !1,
            N = !1
          const B = new Ii(),
            F = new ei(),
            z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }
          function k() {
            return null === x ? A : 1
          }
          let U,
            H,
            G,
            V,
            W,
            j,
            q,
            X,
            Y,
            Z,
            J,
            K,
            Q,
            $,
            tt,
            et,
            it,
            rt,
            st,
            ot,
            at,
            lt,
            ct = n
          function ht(t, n) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i],
                s = e.getContext(r, n)
              if (null !== s) return s
            }
            return null
          }
          try {
            const t = {
              alpha: i,
              depth: r,
              stencil: s,
              antialias: o,
              premultipliedAlpha: a,
              preserveDrawingBuffer: l,
              powerPreference: c,
              failIfMajorPerformanceCaveat: h
            }
            if (
              (e.addEventListener('webglcontextlost', pt, !1),
              e.addEventListener('webglcontextrestored', mt, !1),
              null === ct)
            ) {
              const e = ['webgl2', 'webgl', 'experimental-webgl']
              if ((!0 === f.isWebGL1Renderer && e.shift(), (ct = ht(e, t)), null === ct))
                throw ht(e)
                  ? new Error('Error creating WebGL context with your selected attributes.')
                  : new Error('Error creating WebGL context.')
            }
            void 0 === ct.getShaderPrecisionFormat &&
              (ct.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 }
              })
          } catch (t) {
            throw (console.error('THREE.WebGLRenderer: ' + t.message), t)
          }
          function ut() {
            ;(U = new js(ct)),
              (H = new Gs(ct, U, t)),
              U.init(H),
              (at = new Ha(ct, U, H)),
              (G = new ka(ct, U, H)),
              (V = new Ys(ct)),
              (W = new Sa()),
              (j = new Ua(ct, U, G, W, H, at, V)),
              (q = new Ws(f)),
              (X = new Os(ct, H)),
              (lt = new Us(ct, U, X, H)),
              (Y = new qs(ct, X, V, lt)),
              (Z = new Qs(ct, Y, X, V)),
              (rt = new Ks(ct)),
              (tt = new Vs(W)),
              (J = new Ta(f, q, U, H, lt, tt)),
              (K = new qa(W)),
              (Q = new Ra(W)),
              ($ = new Na(U, H)),
              (it = new ks(f, q, G, Z, a)),
              (et = new za(f, Z, H)),
              (st = new Hs(ct, U, V, H)),
              (ot = new Xs(ct, U, V, H)),
              (V.programs = J.programs),
              (f.capabilities = H),
              (f.extensions = U),
              (f.properties = W),
              (f.renderLists = Q),
              (f.shadowMap = et),
              (f.state = G),
              (f.info = V)
          }
          ut()
          const dt = new ja(f, ct)
          function pt(t) {
            t.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (g = !0)
          }
          function mt() {
            console.log('THREE.WebGLRenderer: Context Restored.'), (g = !1)
            const t = V.autoReset,
              e = et.enabled,
              n = et.autoUpdate,
              i = et.needsUpdate,
              r = et.type
            ut(), (V.autoReset = t), (et.enabled = e), (et.autoUpdate = n), (et.needsUpdate = i), (et.type = r)
          }
          function ft(t) {
            const e = t.target
            e.removeEventListener('dispose', ft),
              (function (t) {
                ;(function (t) {
                  const e = W.get(t).programs
                  void 0 !== e &&
                    e.forEach(function (t) {
                      J.releaseProgram(t)
                    })
                })(t),
                  W.remove(t)
              })(e)
          }
          ;(this.xr = dt),
            (this.getContext = function () {
              return ct
            }),
            (this.getContextAttributes = function () {
              return ct.getContextAttributes()
            }),
            (this.forceContextLoss = function () {
              const t = U.get('WEBGL_lose_context')
              t && t.loseContext()
            }),
            (this.forceContextRestore = function () {
              const t = U.get('WEBGL_lose_context')
              t && t.restoreContext()
            }),
            (this.getPixelRatio = function () {
              return A
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((A = t), this.setSize(S, E, !1))
            }),
            (this.getSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument'), (t = new Wn())),
                t.set(S, E)
              )
            }),
            (this.setSize = function (t, n, i) {
              dt.isPresenting
                ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
                : ((S = t),
                  (E = n),
                  (e.width = Math.floor(t * A)),
                  (e.height = Math.floor(n * A)),
                  !1 !== i && ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
                  this.setViewport(0, 0, t, n))
            }),
            (this.getDrawingBufferSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument'),
                  (t = new Wn())),
                t.set(S * A, E * A).floor()
              )
            }),
            (this.setDrawingBufferSize = function (t, n, i) {
              ;(S = t),
                (E = n),
                (A = i),
                (e.width = Math.floor(t * i)),
                (e.height = Math.floor(n * i)),
                this.setViewport(0, 0, t, n)
            }),
            (this.getCurrentViewport = function (t) {
              return (
                void 0 === t &&
                  (console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument'),
                  (t = new Kn())),
                t.copy(_)
              )
            }),
            (this.getViewport = function (t) {
              return t.copy(P)
            }),
            (this.setViewport = function (t, e, n, i) {
              t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
                G.viewport(_.copy(P).multiplyScalar(A).floor())
            }),
            (this.getScissor = function (t) {
              return t.copy(C)
            }),
            (this.setScissor = function (t, e, n, i) {
              t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
                G.scissor(M.copy(C).multiplyScalar(A).floor())
            }),
            (this.getScissorTest = function () {
              return I
            }),
            (this.setScissorTest = function (t) {
              G.setScissorTest((I = t))
            }),
            (this.setOpaqueSort = function (t) {
              L = t
            }),
            (this.setTransparentSort = function (t) {
              R = t
            }),
            (this.getClearColor = function (t) {
              return (
                void 0 === t &&
                  (console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument'), (t = new Ar())),
                t.copy(it.getClearColor())
              )
            }),
            (this.setClearColor = function () {
              it.setClearColor.apply(it, arguments)
            }),
            (this.getClearAlpha = function () {
              return it.getClearAlpha()
            }),
            (this.setClearAlpha = function () {
              it.setClearAlpha.apply(it, arguments)
            }),
            (this.clear = function (t, e, n) {
              let i = 0
              ;(void 0 === t || t) && (i |= 16384),
                (void 0 === e || e) && (i |= 256),
                (void 0 === n || n) && (i |= 1024),
                ct.clear(i)
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1)
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1)
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0)
            }),
            (this.dispose = function () {
              e.removeEventListener('webglcontextlost', pt, !1),
                e.removeEventListener('webglcontextrestored', mt, !1),
                Q.dispose(),
                $.dispose(),
                W.dispose(),
                q.dispose(),
                Z.dispose(),
                lt.dispose(),
                dt.dispose(),
                dt.removeEventListener('sessionstart', vt),
                dt.removeEventListener('sessionend', yt),
                xt.stop()
            }),
            (this.renderBufferImmediate = function (t, e) {
              lt.initAttributes()
              const n = W.get(t)
              t.hasPositions && !n.position && (n.position = ct.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = ct.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = ct.createBuffer()),
                t.hasColors && !n.color && (n.color = ct.createBuffer())
              const i = e.getAttributes()
              t.hasPositions &&
                (ct.bindBuffer(34962, n.position),
                ct.bufferData(34962, t.positionArray, 35048),
                lt.enableAttribute(i.position),
                ct.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                t.hasNormals &&
                  (ct.bindBuffer(34962, n.normal),
                  ct.bufferData(34962, t.normalArray, 35048),
                  lt.enableAttribute(i.normal),
                  ct.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs &&
                  (ct.bindBuffer(34962, n.uv),
                  ct.bufferData(34962, t.uvArray, 35048),
                  lt.enableAttribute(i.uv),
                  ct.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                t.hasColors &&
                  (ct.bindBuffer(34962, n.color),
                  ct.bufferData(34962, t.colorArray, 35048),
                  lt.enableAttribute(i.color),
                  ct.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                lt.disableUnusedAttributes(),
                ct.drawArrays(4, 0, t.count),
                (t.count = 0)
            }),
            (this.renderBufferDirect = function (t, e, n, i, r, s) {
              null === e && (e = z)
              const o = r.isMesh && r.matrixWorld.determinant() < 0,
                a = St(t, e, i, r)
              G.setMaterial(i, o)
              let l = n.index
              const c = n.attributes.position
              if (null === l) {
                if (void 0 === c || 0 === c.count) return
              } else if (0 === l.count) return
              let h,
                u = 1
              !0 === i.wireframe && ((l = Y.getWireframeAttribute(n)), (u = 2)),
                (i.morphTargets || i.morphNormals) && rt.update(r, n, i, a),
                lt.setup(r, i, a, n, l)
              let d = st
              null !== l && ((h = X.get(l)), (d = ot), d.setIndex(h))
              const p = null !== l ? l.count : c.count,
                m = n.drawRange.start * u,
                f = n.drawRange.count * u,
                g = null !== s ? s.start * u : 0,
                v = null !== s ? s.count * u : 1 / 0,
                y = Math.max(m, g),
                x = Math.min(p, m + f, g + v) - 1,
                b = Math.max(0, x - y + 1)
              if (0 !== b) {
                if (r.isMesh)
                  !0 === i.wireframe ? (G.setLineWidth(i.wireframeLinewidth * k()), d.setMode(1)) : d.setMode(4)
                else if (r.isLine) {
                  let t = i.linewidth
                  void 0 === t && (t = 1),
                    G.setLineWidth(t * k()),
                    r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4)
                if (r.isInstancedMesh) d.renderInstances(y, b, r.count)
                else if (n.isInstancedBufferGeometry) {
                  const t = Math.min(n.instanceCount, n._maxInstanceCount)
                  d.renderInstances(y, b, t)
                } else d.render(y, b)
              }
            }),
            (this.compile = function (t, e) {
              ;(d = $.get(t)),
                d.init(),
                t.traverseVisible(function (t) {
                  t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                }),
                d.setupLights(),
                t.traverse(function (e) {
                  const n = e.material
                  if (n)
                    if (Array.isArray(n)) for (let i = 0; i < n.length; i++) Mt(n[i], t, e)
                    else Mt(n, t, e)
                })
            })
          let gt = null
          function vt() {
            xt.stop()
          }
          function yt() {
            xt.start()
          }
          const xt = new Ds()
          function bt(t, e, n, i) {
            if (!1 === t.visible) return
            if (t.layers.test(e.layers))
              if (t.isGroup) n = t.renderOrder
              else if (t.isLOD) !0 === t.autoUpdate && t.update(e)
              else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t)
              else if (t.isSprite) {
                if (!t.frustumCulled || D.intersectsSprite(t)) {
                  i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B)
                  const e = Z.update(t),
                    r = t.material
                  r.visible && u.push(t, e, r, n, F.z, null)
                }
              } else if (t.isImmediateRenderObject)
                i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B), u.push(t, null, t.material, n, F.z, null)
              else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (t.isSkinnedMesh &&
                  t.skeleton.frame !== V.render.frame &&
                  (t.skeleton.update(), (t.skeleton.frame = V.render.frame)),
                !t.frustumCulled || D.intersectsObject(t))
              ) {
                i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B)
                const e = Z.update(t),
                  r = t.material
                if (Array.isArray(r)) {
                  const i = e.groups
                  for (let s = 0, o = i.length; s < o; s++) {
                    const o = i[s],
                      a = r[o.materialIndex]
                    a && a.visible && u.push(t, e, a, n, F.z, o)
                  }
                } else r.visible && u.push(t, e, r, n, F.z, null)
              }
            const r = t.children
            for (let t = 0, s = r.length; t < s; t++) bt(r[t], e, n, i)
          }
          function wt(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                o = s.object,
                a = s.geometry,
                l = null === i ? s.material : i,
                c = s.group
              if (n.isArrayCamera) {
                const t = n.cameras
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n]
                  o.layers.test(i.layers) &&
                    (G.viewport(_.copy(i.viewport)), d.setupLightsView(i), _t(o, e, i, a, l, c))
                }
              } else _t(o, e, n, a, l, c)
            }
          }
          function _t(t, e, n, i, r, s) {
            if (
              (t.onBeforeRender(f, e, n, i, r, s),
              t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
              t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
              t.isImmediateRenderObject)
            ) {
              const i = St(n, e, r, t)
              G.setMaterial(r),
                lt.reset(),
                (function (t, e) {
                  t.render(function (t) {
                    f.renderBufferImmediate(t, e)
                  })
                })(t, i)
            } else f.renderBufferDirect(n, e, i, r, t, s)
            t.onAfterRender(f, e, n, i, r, s)
          }
          function Mt(t, e, n) {
            !0 !== e.isScene && (e = z)
            const i = W.get(t),
              r = d.state.lights,
              s = d.state.shadowsArray,
              o = r.state.version,
              a = J.getParameters(t, r.state, s, e, n),
              l = J.getProgramCacheKey(a)
            let c = i.programs
            ;(i.environment = t.isMeshStandardMaterial ? e.environment : null),
              (i.fog = e.fog),
              (i.envMap = q.get(t.envMap || i.environment)),
              void 0 === c && (t.addEventListener('dispose', ft), (c = new Map()), (i.programs = c))
            let h = c.get(l)
            if (void 0 !== h) {
              if (i.currentProgram === h && i.lightsStateVersion === o) return Tt(t, a), h
            } else
              (a.uniforms = J.getUniforms(t)),
                t.onBeforeCompile(a, f),
                (h = J.acquireProgram(a, l)),
                c.set(l, h),
                (i.uniforms = a.uniforms)
            const u = i.uniforms
            ;((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) || (u.clippingPlanes = tt.uniform),
              Tt(t, a),
              (i.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                )
              })(t)),
              (i.lightsStateVersion = o),
              i.needsLights &&
                ((u.ambientLightColor.value = r.state.ambient),
                (u.lightProbe.value = r.state.probe),
                (u.directionalLights.value = r.state.directional),
                (u.directionalLightShadows.value = r.state.directionalShadow),
                (u.spotLights.value = r.state.spot),
                (u.spotLightShadows.value = r.state.spotShadow),
                (u.rectAreaLights.value = r.state.rectArea),
                (u.ltc_1.value = r.state.rectAreaLTC1),
                (u.ltc_2.value = r.state.rectAreaLTC2),
                (u.pointLights.value = r.state.point),
                (u.pointLightShadows.value = r.state.pointShadow),
                (u.hemisphereLights.value = r.state.hemi),
                (u.directionalShadowMap.value = r.state.directionalShadowMap),
                (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
                (u.spotShadowMap.value = r.state.spotShadowMap),
                (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
                (u.pointShadowMap.value = r.state.pointShadowMap),
                (u.pointShadowMatrix.value = r.state.pointShadowMatrix))
            const p = h.getUniforms(),
              m = ia.seqWithValue(p.seq, u)
            return (i.currentProgram = h), (i.uniformsList = m), h
          }
          function Tt(t, e) {
            const n = W.get(t)
            ;(n.outputEncoding = e.outputEncoding),
              (n.instancing = e.instancing),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas)
          }
          function St(t, e, n, i) {
            !0 !== e.isScene && (e = z), j.resetTextureUnits()
            const r = e.fog,
              s = n.isMeshStandardMaterial ? e.environment : null,
              o = null === x ? f.outputEncoding : x.texture.encoding,
              a = q.get(n.envMap || s),
              l = !0 === n.vertexColors && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
              c = W.get(n),
              h = d.state.lights
            if (!0 === O && (!0 === N || t !== w)) {
              const e = t === w && n.id === b
              tt.setState(n, t, e)
            }
            let u = !1
            n.version === c.__version
              ? (c.needsLights && c.lightsStateVersion !== h.state.version) ||
                c.outputEncoding !== o ||
                (i.isInstancedMesh && !1 === c.instancing)
                ? (u = !0)
                : i.isInstancedMesh || !0 !== c.instancing
                ? c.envMap !== a || (n.fog && c.fog !== r)
                  ? (u = !0)
                  : void 0 === c.numClippingPlanes ||
                    (c.numClippingPlanes === tt.numPlanes && c.numIntersection === tt.numIntersection)
                  ? c.vertexAlphas !== l && (u = !0)
                  : (u = !0)
                : (u = !0)
              : ((u = !0), (c.__version = n.version))
            let p = c.currentProgram
            !0 === u && (p = Mt(n, e, i))
            let m = !1,
              g = !1,
              v = !1
            const y = p.getUniforms(),
              _ = c.uniforms
            if (
              (G.useProgram(p.program) && ((m = !0), (g = !0), (v = !0)),
              n.id !== b && ((b = n.id), (g = !0)),
              m || w !== t)
            ) {
              if (
                (y.setValue(ct, 'projectionMatrix', t.projectionMatrix),
                H.logarithmicDepthBuffer && y.setValue(ct, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
                w !== t && ((w = t), (g = !0), (v = !0)),
                n.isShaderMaterial ||
                  n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshStandardMaterial ||
                  n.envMap)
              ) {
                const e = y.map.cameraPosition
                void 0 !== e && e.setValue(ct, F.setFromMatrixPosition(t.matrixWorld))
              }
              ;(n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial) &&
                y.setValue(ct, 'isOrthographic', !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial ||
                  n.isShadowMaterial ||
                  n.skinning) &&
                  y.setValue(ct, 'viewMatrix', t.matrixWorldInverse)
            }
            if (n.skinning) {
              y.setOptional(ct, i, 'bindMatrix'), y.setOptional(ct, i, 'bindMatrixInverse')
              const t = i.skeleton
              if (t) {
                const e = t.bones
                if (H.floatVertexTextures) {
                  if (null === t.boneTexture) {
                    let n = Math.sqrt(4 * e.length)
                    ;(n = Vn.ceilPowerOfTwo(n)), (n = Math.max(n, 4))
                    const i = new Float32Array(n * n * 4)
                    i.set(t.boneMatrices)
                    const r = new Rs(i, n, n, Gt, Ot)
                    ;(t.boneMatrices = i), (t.boneTexture = r), (t.boneTextureSize = n)
                  }
                  y.setValue(ct, 'boneTexture', t.boneTexture, j), y.setValue(ct, 'boneTextureSize', t.boneTextureSize)
                } else y.setOptional(ct, t, 'boneMatrices')
              }
            }
            var M, T
            return (
              (g || c.receiveShadow !== i.receiveShadow) &&
                ((c.receiveShadow = i.receiveShadow), y.setValue(ct, 'receiveShadow', i.receiveShadow)),
              g &&
                (y.setValue(ct, 'toneMappingExposure', f.toneMappingExposure),
                c.needsLights &&
                  ((T = v),
                  ((M = _).ambientLightColor.needsUpdate = T),
                  (M.lightProbe.needsUpdate = T),
                  (M.directionalLights.needsUpdate = T),
                  (M.directionalLightShadows.needsUpdate = T),
                  (M.pointLights.needsUpdate = T),
                  (M.pointLightShadows.needsUpdate = T),
                  (M.spotLights.needsUpdate = T),
                  (M.spotLightShadows.needsUpdate = T),
                  (M.rectAreaLights.needsUpdate = T),
                  (M.hemisphereLights.needsUpdate = T)),
                r && n.fog && K.refreshFogUniforms(_, r),
                K.refreshMaterialUniforms(_, n, A, E),
                ia.upload(ct, c.uniformsList, _, j)),
              n.isShaderMaterial &&
                !0 === n.uniformsNeedUpdate &&
                (ia.upload(ct, c.uniformsList, _, j), (n.uniformsNeedUpdate = !1)),
              n.isSpriteMaterial && y.setValue(ct, 'center', i.center),
              y.setValue(ct, 'modelViewMatrix', i.modelViewMatrix),
              y.setValue(ct, 'normalMatrix', i.normalMatrix),
              y.setValue(ct, 'modelMatrix', i.matrixWorld),
              p
            )
          }
          xt.setAnimationLoop(function (t) {
            gt && gt(t)
          }),
            'undefined' != typeof window && xt.setContext(window),
            (this.setAnimationLoop = function (t) {
              ;(gt = t), dt.setAnimationLoop(t), null === t ? xt.stop() : xt.start()
            }),
            dt.addEventListener('sessionstart', vt),
            dt.addEventListener('sessionend', yt),
            (this.render = function (t, e) {
              let n, i
              if (
                (void 0 !== arguments[2] &&
                  (console.warn(
                    'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.'
                  ),
                  (n = arguments[2])),
                void 0 !== arguments[3] &&
                  (console.warn(
                    'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.'
                  ),
                  (i = arguments[3])),
                void 0 !== e && !0 !== e.isCamera)
              )
                return void console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.')
              if (!0 === g) return
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)),
                !0 === t.isScene && t.onBeforeRender(f, t, e, n || x),
                (d = $.get(t, m.length)),
                d.init(),
                m.push(d),
                B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                D.setFromProjectionMatrix(B),
                (N = this.localClippingEnabled),
                (O = tt.init(this.clippingPlanes, N, e)),
                (u = Q.get(t, p.length)),
                u.init(),
                p.push(u),
                bt(t, e, 0, f.sortObjects),
                u.finish(),
                !0 === f.sortObjects && u.sort(L, R),
                !0 === O && tt.beginShadows()
              const r = d.state.shadowsArray
              et.render(r, t, e),
                d.setupLights(),
                d.setupLightsView(e),
                !0 === O && tt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                it.render(u, t, e, i)
              const s = u.opaque,
                o = u.transparent
              s.length > 0 && wt(s, t, e),
                o.length > 0 && wt(o, t, e),
                null !== x && (j.updateRenderTargetMipmap(x), j.updateMultisampleRenderTarget(x)),
                !0 === t.isScene && t.onAfterRender(f, t, e),
                G.buffers.depth.setTest(!0),
                G.buffers.depth.setMask(!0),
                G.buffers.color.setMask(!0),
                G.setPolygonOffset(!1),
                lt.resetDefaultState(),
                (b = -1),
                (w = null),
                m.pop(),
                (d = m.length > 0 ? m[m.length - 1] : null),
                p.pop(),
                (u = p.length > 0 ? p[p.length - 1] : null)
            }),
            (this.getActiveCubeFace = function () {
              return v
            }),
            (this.getActiveMipmapLevel = function () {
              return y
            }),
            (this.getRenderTarget = function () {
              return x
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              ;(x = t), (v = e), (y = n), t && void 0 === W.get(t).__webglFramebuffer && j.setupRenderTarget(t)
              let i = null,
                r = !1,
                s = !1
              if (t) {
                const n = t.texture
                ;(n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0)
                const o = W.get(t).__webglFramebuffer
                t.isWebGLCubeRenderTarget
                  ? ((i = o[e]), (r = !0))
                  : (i = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : o),
                  _.copy(t.viewport),
                  M.copy(t.scissor),
                  (T = t.scissorTest)
              } else _.copy(P).multiplyScalar(A).floor(), M.copy(C).multiplyScalar(A).floor(), (T = I)
              if ((G.bindFramebuffer(36160, i), G.viewport(_), G.scissor(M), G.setScissorTest(T), r)) {
                const i = W.get(t.texture)
                ct.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
              } else if (s) {
                const i = W.get(t.texture),
                  r = e || 0
                ct.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
              }
            }),
            (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
                )
              let a = W.get(t).__webglFramebuffer
              if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
                G.bindFramebuffer(36160, a)
                try {
                  const o = t.texture,
                    a = o.format,
                    l = o.type
                  if (a !== Gt && at.convert(a) !== ct.getParameter(35739))
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                    )
                  const c =
                    l === Nt &&
                    (U.has('EXT_color_buffer_half_float') || (H.isWebGL2 && U.has('EXT_color_buffer_float')))
                  if (
                    !(
                      l === Lt ||
                      at.convert(l) === ct.getParameter(35738) ||
                      (l === Ot && (H.isWebGL2 || U.has('OES_texture_float') || U.has('WEBGL_color_buffer_float'))) ||
                      c
                    )
                  )
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                    )
                  36053 === ct.checkFramebufferStatus(36160)
                    ? e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      ct.readPixels(e, n, i, r, at.convert(a), at.convert(l), s)
                    : console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
                      )
                } finally {
                  const t = null !== x ? W.get(x).__webglFramebuffer : null
                  G.bindFramebuffer(36160, t)
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                s = Math.floor(e.image.height * i),
                o = at.convert(e.format)
              j.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), G.unbindTexture()
            }),
            (this.copyTextureToTexture = function (t, e, n, i = 0) {
              const r = e.image.width,
                s = e.image.height,
                o = at.convert(n.format),
                a = at.convert(n.type)
              j.setTexture2D(n, 0),
                ct.pixelStorei(37440, n.flipY),
                ct.pixelStorei(37441, n.premultiplyAlpha),
                ct.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture
                  ? ct.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data)
                  : e.isCompressedTexture
                  ? ct.compressedTexSubImage2D(
                      3553,
                      i,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      o,
                      e.mipmaps[0].data
                    )
                  : ct.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
                0 === i && n.generateMipmaps && ct.generateMipmap(3553),
                G.unbindTexture()
            }),
            (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
              if (f.isWebGL1Renderer)
                return void console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.')
              const { width: s, height: o, data: a } = n.image,
                l = at.convert(i.format),
                c = at.convert(i.type)
              let h
              if (i.isDataTexture3D) j.setTexture3D(i, 0), (h = 32879)
              else {
                if (!i.isDataTexture2DArray)
                  return void console.warn(
                    'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
                  )
                j.setTexture2DArray(i, 0), (h = 35866)
              }
              ct.pixelStorei(37440, i.flipY),
                ct.pixelStorei(37441, i.premultiplyAlpha),
                ct.pixelStorei(3317, i.unpackAlignment)
              const u = ct.getParameter(3314),
                d = ct.getParameter(32878),
                p = ct.getParameter(3316),
                m = ct.getParameter(3315),
                g = ct.getParameter(32877)
              ct.pixelStorei(3314, s),
                ct.pixelStorei(32878, o),
                ct.pixelStorei(3316, t.min.x),
                ct.pixelStorei(3315, t.min.y),
                ct.pixelStorei(32877, t.min.z),
                ct.texSubImage3D(
                  h,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  t.max.x - t.min.x + 1,
                  t.max.y - t.min.y + 1,
                  t.max.z - t.min.z + 1,
                  l,
                  c,
                  a
                ),
                ct.pixelStorei(3314, u),
                ct.pixelStorei(32878, d),
                ct.pixelStorei(3316, p),
                ct.pixelStorei(3315, m),
                ct.pixelStorei(32877, g),
                0 === r && i.generateMipmaps && ct.generateMipmap(h),
                G.unbindTexture()
            }),
            (this.initTexture = function (t) {
              j.setTexture2D(t, 0), G.unbindTexture()
            }),
            (this.resetState = function () {
              ;(v = 0), (y = 0), (x = null), G.reset(), lt.reset()
            }),
            'undefined' != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
        }
        ;(Va.prototype.isGroup = !0),
          Object.assign(Wa.prototype, {
            constructor: Wa,
            getHandSpace: function () {
              return (
                null === this._hand &&
                  ((this._hand = new Va()),
                  (this._hand.matrixAutoUpdate = !1),
                  (this._hand.visible = !1),
                  (this._hand.joints = {}),
                  (this._hand.inputState = { pinching: !1 })),
                this._hand
              )
            },
            getTargetRaySpace: function () {
              return (
                null === this._targetRay &&
                  ((this._targetRay = new Va()),
                  (this._targetRay.matrixAutoUpdate = !1),
                  (this._targetRay.visible = !1)),
                this._targetRay
              )
            },
            getGripSpace: function () {
              return (
                null === this._grip &&
                  ((this._grip = new Va()), (this._grip.matrixAutoUpdate = !1), (this._grip.visible = !1)),
                this._grip
              )
            },
            dispatchEvent: function (t) {
              return (
                null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
              )
            },
            disconnect: function (t) {
              return (
                this.dispatchEvent({ type: 'disconnected', data: t }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
              )
            },
            update: function (t, e, n) {
              let i = null,
                r = null,
                s = null
              const o = this._targetRay,
                a = this._grip,
                l = this._hand
              if (t && 'visible-blurred' !== e.session.visibilityState)
                if (
                  (null !== o &&
                    ((i = e.getPose(t.targetRaySpace, n)),
                    null !== i &&
                      (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))),
                  l && t.hand)
                ) {
                  s = !0
                  for (const i of t.hand.values()) {
                    const t = e.getJointPose(i, n)
                    if (void 0 === l.joints[i.jointName]) {
                      const t = new Va()
                      ;(t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[i.jointName] = t), l.add(t)
                    }
                    const r = l.joints[i.jointName]
                    null !== t &&
                      (r.matrix.fromArray(t.transform.matrix),
                      r.matrix.decompose(r.position, r.rotation, r.scale),
                      (r.jointRadius = t.radius)),
                      (r.visible = null !== t)
                  }
                  const i = l.joints['index-finger-tip'],
                    r = l.joints['thumb-tip'],
                    o = i.position.distanceTo(r.position),
                    a = 0.02,
                    c = 0.005
                  l.inputState.pinching && o > a + c
                    ? ((l.inputState.pinching = !1),
                      this.dispatchEvent({ type: 'pinchend', handedness: t.handedness, target: this }))
                    : !l.inputState.pinching &&
                      o <= a - c &&
                      ((l.inputState.pinching = !0),
                      this.dispatchEvent({ type: 'pinchstart', handedness: t.handedness, target: this }))
                } else
                  null !== a &&
                    t.gripSpace &&
                    ((r = e.getPose(t.gripSpace, n)),
                    null !== r &&
                      (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)))
              return (
                null !== o && (o.visible = null !== i),
                null !== a && (a.visible = null !== r),
                null !== l && (l.visible = null !== s),
                this
              )
            }
          }),
          Object.assign(ja.prototype, Un.prototype)
        class Ya extends Xa {}
        Ya.prototype.isWebGL1Renderer = !0
        class Za {
          constructor(t, e = 25e-5) {
            ;(this.name = ''), (this.color = new Ar(t)), (this.density = e)
          }
          clone() {
            return new Za(this.color, this.density)
          }
          toJSON() {
            return { type: 'FogExp2', color: this.color.getHex(), density: this.density }
          }
        }
        Za.prototype.isFogExp2 = !0
        class Ja {
          constructor(t, e = 1, n = 1e3) {
            ;(this.name = ''), (this.color = new Ar(t)), (this.near = e), (this.far = n)
          }
          clone() {
            return new Ja(this.color, this.near, this.far)
          }
          toJSON() {
            return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far }
          }
        }
        Ja.prototype.isFog = !0
        class Ka extends ir {
          constructor() {
            super(),
              (this.type = 'Scene'),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.overrideMaterial = null),
              (this.autoUpdate = !0),
              'undefined' != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment && (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            )
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (
              null !== this.background && (e.object.background = this.background.toJSON(t)),
              null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              e
            )
          }
        }
        function Qa(t, e) {
          ;(this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = Rn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Vn.generateUUID())
        }
        ;(Ka.prototype.isScene = !0),
          Object.defineProperty(Qa.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++
            }
          }),
          Object.assign(Qa.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
              return (this.usage = t), this
            },
            copy: function (t) {
              return (
                (this.array = new t.array.constructor(t.array)),
                (this.count = t.count),
                (this.stride = t.stride),
                (this.usage = t.usage),
                this
              )
            },
            copyAt: function (t, e, n) {
              ;(t *= this.stride), (n *= e.stride)
              for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i]
              return this
            },
            set: function (t, e = 0) {
              return this.array.set(t, e), this
            },
            clone: function (t) {
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Vn.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                  (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
              const e = new Qa(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride)
              return e.setUsage(this.usage), e
            },
            onUpload: function (t) {
              return (this.onUploadCallback = t), this
            },
            toJSON: function (t) {
              return (
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Vn.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                  (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
                    new Uint32Array(this.array.buffer)
                  )),
                {
                  uuid: this.uuid,
                  buffer: this.array.buffer._uuid,
                  type: this.array.constructor.name,
                  stride: this.stride
                }
              )
            }
          })
        const $a = new ei()
        function tl(t, e, n, i) {
          ;(this.name = ''), (this.data = t), (this.itemSize = e), (this.offset = n), (this.normalized = !0 === i)
        }
        Object.defineProperties(tl.prototype, {
          count: {
            get: function () {
              return this.data.count
            }
          },
          array: {
            get: function () {
              return this.data.array
            }
          },
          needsUpdate: {
            set: function (t) {
              this.data.needsUpdate = t
            }
          }
        }),
          Object.assign(tl.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function (t) {
              for (let e = 0, n = this.data.count; e < n; e++)
                ($a.x = this.getX(e)),
                  ($a.y = this.getY(e)),
                  ($a.z = this.getZ(e)),
                  $a.applyMatrix4(t),
                  this.setXYZ(e, $a.x, $a.y, $a.z)
              return this
            },
            applyNormalMatrix: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                ($a.x = this.getX(e)),
                  ($a.y = this.getY(e)),
                  ($a.z = this.getZ(e)),
                  $a.applyNormalMatrix(t),
                  this.setXYZ(e, $a.x, $a.y, $a.z)
              return this
            },
            transformDirection: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                ($a.x = this.getX(e)),
                  ($a.y = this.getY(e)),
                  ($a.z = this.getZ(e)),
                  $a.transformDirection(t),
                  this.setXYZ(e, $a.x, $a.y, $a.z)
              return this
            },
            setX: function (t, e) {
              return (this.data.array[t * this.data.stride + this.offset] = e), this
            },
            setY: function (t, e) {
              return (this.data.array[t * this.data.stride + this.offset + 1] = e), this
            },
            setZ: function (t, e) {
              return (this.data.array[t * this.data.stride + this.offset + 2] = e), this
            },
            setW: function (t, e) {
              return (this.data.array[t * this.data.stride + this.offset + 3] = e), this
            },
            getX: function (t) {
              return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function (t, e, n) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                this
              )
            },
            setXYZ: function (t, e, n, i) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                (this.data.array[t + 2] = i),
                this
              )
            },
            setXYZW: function (t, e, n, i, r) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                (this.data.array[t + 2] = i),
                (this.data.array[t + 3] = r),
                this
              )
            },
            clone: function (t) {
              if (void 0 === t) {
                console.log(
                  'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.'
                )
                const t = []
                for (let e = 0; e < this.count; e++) {
                  const n = e * this.data.stride + this.offset
                  for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return new Cr(new this.array.constructor(t), this.itemSize, this.normalized)
              }
              return (
                void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] &&
                  (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new tl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
              )
            },
            toJSON: function (t) {
              if (void 0 === t) {
                console.log(
                  'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.'
                )
                const t = []
                for (let e = 0; e < this.count; e++) {
                  const n = e * this.data.stride + this.offset
                  for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return {
                  itemSize: this.itemSize,
                  type: this.array.constructor.name,
                  array: t,
                  normalized: this.normalized
                }
              }
              return (
                void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] &&
                  (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                  isInterleavedBufferAttribute: !0,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized
                }
              )
            }
          })
        class el extends br {
          constructor(t) {
            super(),
              (this.type = 'SpriteMaterial'),
              (this.color = new Ar(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            )
          }
        }
        let nl
        el.prototype.isSpriteMaterial = !0
        const il = new ei(),
          rl = new ei(),
          sl = new ei(),
          ol = new Wn(),
          al = new Wn(),
          ll = new Ii(),
          cl = new ei(),
          hl = new ei(),
          ul = new ei(),
          dl = new Wn(),
          pl = new Wn(),
          ml = new Wn()
        class fl extends ir {
          constructor(t) {
            if ((super(), (this.type = 'Sprite'), void 0 === nl)) {
              nl = new Qr()
              const t = new Qa(
                new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
                5
              )
              nl.setIndex([0, 1, 2, 0, 2, 3]),
                nl.setAttribute('position', new tl(t, 3, 0, !1)),
                nl.setAttribute('uv', new tl(t, 2, 3, !1))
            }
            ;(this.geometry = nl), (this.material = void 0 !== t ? t : new el()), (this.center = new Wn(0.5, 0.5))
          }
          raycast(t, e) {
            null === t.camera &&
              console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
              rl.setFromMatrixScale(this.matrixWorld),
              ll.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
              sl.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && rl.multiplyScalar(-sl.z)
            const n = this.material.rotation
            let i, r
            0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)))
            const s = this.center
            gl(cl.set(-0.5, -0.5, 0), sl, s, rl, i, r),
              gl(hl.set(0.5, -0.5, 0), sl, s, rl, i, r),
              gl(ul.set(0.5, 0.5, 0), sl, s, rl, i, r),
              dl.set(0, 0),
              pl.set(1, 0),
              ml.set(1, 1)
            let o = t.ray.intersectTriangle(cl, hl, ul, !1, il)
            if (
              null === o &&
              (gl(hl.set(-0.5, 0.5, 0), sl, s, rl, i, r),
              pl.set(0, 1),
              (o = t.ray.intersectTriangle(cl, ul, hl, !1, il)),
              null === o)
            )
              return
            const a = t.ray.origin.distanceTo(il)
            a < t.near ||
              a > t.far ||
              e.push({
                distance: a,
                point: il.clone(),
                uv: yr.getUV(il, cl, hl, ul, dl, pl, ml, new Wn()),
                face: null,
                object: this
              })
          }
          copy(t) {
            return super.copy(t), void 0 !== t.center && this.center.copy(t.center), (this.material = t.material), this
          }
        }
        function gl(t, e, n, i, r, s) {
          ol.subVectors(t, n).addScalar(0.5).multiply(i),
            void 0 !== r ? ((al.x = s * ol.x - r * ol.y), (al.y = r * ol.x + s * ol.y)) : al.copy(ol),
            t.copy(e),
            (t.x += al.x),
            (t.y += al.y),
            t.applyMatrix4(ll)
        }
        fl.prototype.isSprite = !0
        const vl = new ei(),
          yl = new ei()
        class xl extends ir {
          constructor() {
            super(),
              (this._currentLevel = 0),
              (this.type = 'LOD'),
              Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }),
              (this.autoUpdate = !0)
          }
          copy(t) {
            super.copy(t, !1)
            const e = t.levels
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t]
              this.addLevel(n.object.clone(), n.distance)
            }
            return (this.autoUpdate = t.autoUpdate), this
          }
          addLevel(t, e = 0) {
            e = Math.abs(e)
            const n = this.levels
            let i
            for (i = 0; i < n.length && !(e < n[i].distance); i++);
            return n.splice(i, 0, { distance: e, object: t }), this.add(t), this
          }
          getCurrentLevel() {
            return this._currentLevel
          }
          getObjectForDistance(t) {
            const e = this.levels
            if (e.length > 0) {
              let n, i
              for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
              return e[n - 1].object
            }
            return null
          }
          raycast(t, e) {
            if (this.levels.length > 0) {
              vl.setFromMatrixPosition(this.matrixWorld)
              const n = t.ray.origin.distanceTo(vl)
              this.getObjectForDistance(n).raycast(t, e)
            }
          }
          update(t) {
            const e = this.levels
            if (e.length > 1) {
              vl.setFromMatrixPosition(t.matrixWorld), yl.setFromMatrixPosition(this.matrixWorld)
              const n = vl.distanceTo(yl) / t.zoom
              let i, r
              for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++)
                (e[i - 1].object.visible = !1), (e[i].object.visible = !0)
              for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
            }
          }
          toJSON(t) {
            const e = super.toJSON(t)
            !1 === this.autoUpdate && (e.object.autoUpdate = !1), (e.object.levels = [])
            const n = this.levels
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t]
              e.object.levels.push({ object: i.object.uuid, distance: i.distance })
            }
            return e
          }
        }
        const bl = new ei(),
          wl = new Kn(),
          _l = new Kn(),
          Ml = new ei(),
          Tl = new Ii()
        function Sl(t, e) {
          gs.call(this, t, e),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = 'attached'),
            (this.bindMatrix = new Ii()),
            (this.bindMatrixInverse = new Ii())
        }
        function El() {
          ir.call(this), (this.type = 'Bone')
        }
        ;(Sl.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: Sl,
          isSkinnedMesh: !0,
          copy: function (t) {
            return (
              gs.prototype.copy.call(this, t),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              this
            )
          },
          bind: function (t, e) {
            ;(this.skeleton = t),
              void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert()
          },
          pose: function () {
            this.skeleton.pose()
          },
          normalizeSkinWeights: function () {
            const t = new Kn(),
              e = this.geometry.attributes.skinWeight
            for (let n = 0, i = e.count; n < i; n++) {
              ;(t.x = e.getX(n)), (t.y = e.getY(n)), (t.z = e.getZ(n)), (t.w = e.getW(n))
              const i = 1 / t.manhattanLength()
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
          },
          updateMatrixWorld: function (t) {
            gs.prototype.updateMatrixWorld.call(this, t),
              'attached' === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : 'detached' === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode)
          },
          boneTransform: function (t, e) {
            const n = this.skeleton,
              i = this.geometry
            wl.fromBufferAttribute(i.attributes.skinIndex, t),
              _l.fromBufferAttribute(i.attributes.skinWeight, t),
              bl.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0)
            for (let t = 0; t < 4; t++) {
              const i = _l.getComponent(t)
              if (0 !== i) {
                const r = wl.getComponent(t)
                Tl.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(Ml.copy(bl).applyMatrix4(Tl), i)
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse)
          }
        })),
          (El.prototype = Object.assign(Object.create(ir.prototype), { constructor: El, isBone: !0 }))
        const Al = new Ii(),
          Ll = new Ii()
        class Rl {
          constructor(t = [], e = []) {
            ;(this.uuid = Vn.generateUUID()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init()
          }
          init() {
            const t = this.bones,
              e = this.boneInverses
            if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)) this.calculateInverses()
            else if (t.length !== e.length) {
              console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'),
                (this.boneInverses = [])
              for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ii())
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new Ii()
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t]
              e && e.matrixWorld.copy(this.boneInverses[t]).invert()
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t]
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : Ll
              Al.multiplyMatrices(r, e[i]), Al.toArray(n, 16 * i)
            }
            null !== i && (i.needsUpdate = !0)
          }
          clone() {
            return new Rl(this.bones, this.boneInverses)
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e]
              if (n.name === t) return n
            }
          }
          dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null))
          }
          fromJSON(t, e) {
            this.uuid = t.uuid
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n]
              let r = e[i]
              void 0 === r && (console.warn('THREE.Skeleton: No bone found with UUID:', i), (r = new El())),
                this.bones.push(r),
                this.boneInverses.push(new Ii().fromArray(t.boneInverses[n]))
            }
            return this.init(), this
          }
          toJSON() {
            const t = {
              metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' },
              bones: [],
              boneInverses: []
            }
            t.uuid = this.uuid
            const e = this.bones,
              n = this.boneInverses
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i]
              t.bones.push(r.uuid)
              const s = n[i]
              t.boneInverses.push(s.toArray())
            }
            return t
          }
        }
        const Pl = new Ii(),
          Cl = new Ii(),
          Il = [],
          Dl = new gs()
        function Ol(t, e, n) {
          gs.call(this, t, e),
            (this.instanceMatrix = new Cr(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1)
        }
        Ol.prototype = Object.assign(Object.create(gs.prototype), {
          constructor: Ol,
          isInstancedMesh: !0,
          copy: function (t) {
            return (
              gs.prototype.copy.call(this, t),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              this
            )
          },
          getColorAt: function (t, e) {
            e.fromArray(this.instanceColor.array, 3 * t)
          },
          getMatrixAt: function (t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
          },
          raycast: function (t, e) {
            const n = this.matrixWorld,
              i = this.count
            if (((Dl.geometry = this.geometry), (Dl.material = this.material), void 0 !== Dl.material))
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, Pl), Cl.multiplyMatrices(n, Pl), (Dl.matrixWorld = Cl), Dl.raycast(t, Il)
                for (let t = 0, n = Il.length; t < n; t++) {
                  const n = Il[t]
                  ;(n.instanceId = r), (n.object = this), e.push(n)
                }
                Il.length = 0
              }
          },
          setColorAt: function (t, e) {
            null === this.instanceColor && (this.instanceColor = new Cr(new Float32Array(3 * this.count), 3)),
              e.toArray(this.instanceColor.array, 3 * t)
          },
          setMatrixAt: function (t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
          },
          updateMorphTargets: function () {},
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' })
          }
        })
        class Nl extends br {
          constructor(t) {
            super(),
              (this.type = 'LineBasicMaterial'),
              (this.color = new Ar(16777215)),
              (this.linewidth = 1),
              (this.linecap = 'round'),
              (this.linejoin = 'round'),
              (this.morphTargets = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.morphTargets = t.morphTargets),
              this
            )
          }
        }
        Nl.prototype.isLineBasicMaterial = !0
        const Bl = new ei(),
          Fl = new ei(),
          zl = new Ii(),
          kl = new Ci(),
          Ul = new Mi()
        function Hl(t = new Qr(), e = new Nl()) {
          ir.call(this), (this.type = 'Line'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        Hl.prototype = Object.assign(Object.create(ir.prototype), {
          constructor: Hl,
          isLine: !0,
          copy: function (t) {
            return ir.prototype.copy.call(this, t), (this.material = t.material), (this.geometry = t.geometry), this
          },
          computeLineDistances: function () {
            const t = this.geometry
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [0]
                for (let t = 1, i = e.count; t < i; t++)
                  Bl.fromBufferAttribute(e, t - 1),
                    Fl.fromBufferAttribute(e, t),
                    (n[t] = n[t - 1]),
                    (n[t] += Bl.distanceTo(Fl))
                t.setAttribute('lineDistance', new Ur(n, 1))
              } else
                console.warn(
                  'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
                )
            else
              t.isGeometry &&
                console.error(
                  'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
            return this
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              s = n.drawRange
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Ul.copy(n.boundingSphere),
              Ul.applyMatrix4(i),
              (Ul.radius += r),
              !1 === t.ray.intersectsSphere(Ul))
            )
              return
            zl.copy(i).invert(), kl.copy(t.ray).applyMatrix4(zl)
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = new ei(),
              c = new ei(),
              h = new ei(),
              u = new ei(),
              d = this.isLineSegments ? 2 : 1
            if (n.isBufferGeometry) {
              const i = n.index,
                r = n.attributes.position
              if (null !== i)
                for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                  const s = i.getX(n),
                    o = i.getX(n + 1)
                  if (
                    (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, o), kl.distanceSqToSegment(l, c, u, h) > a)
                  )
                    continue
                  u.applyMatrix4(this.matrixWorld)
                  const d = t.ray.origin.distanceTo(u)
                  d < t.near ||
                    d > t.far ||
                    e.push({
                      distance: d,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this
                    })
                }
              else
                for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                  if (
                    (l.fromBufferAttribute(r, n),
                    c.fromBufferAttribute(r, n + 1),
                    kl.distanceSqToSegment(l, c, u, h) > a)
                  )
                    continue
                  u.applyMatrix4(this.matrixWorld)
                  const i = t.ray.origin.distanceTo(u)
                  i < t.near ||
                    i > t.far ||
                    e.push({
                      distance: i,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this
                    })
                }
            } else
              n.isGeometry &&
                console.error(
                  'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
          },
          updateMorphTargets: function () {
            const t = this.geometry
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e)
              if (n.length > 0) {
                const t = e[n[0]]
                if (void 0 !== t) {
                  ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e)
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
                  }
                }
              }
            } else {
              const e = t.morphTargets
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
            }
          }
        })
        const Gl = new ei(),
          Vl = new ei()
        function Wl(t, e) {
          Hl.call(this, t, e), (this.type = 'LineSegments')
        }
        Wl.prototype = Object.assign(Object.create(Hl.prototype), {
          constructor: Wl,
          isLineSegments: !0,
          computeLineDistances: function () {
            const t = this.geometry
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = []
                for (let t = 0, i = e.count; t < i; t += 2)
                  Gl.fromBufferAttribute(e, t),
                    Vl.fromBufferAttribute(e, t + 1),
                    (n[t] = 0 === t ? 0 : n[t - 1]),
                    (n[t + 1] = n[t] + Gl.distanceTo(Vl))
                t.setAttribute('lineDistance', new Ur(n, 1))
              } else
                console.warn(
                  'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
                )
            else
              t.isGeometry &&
                console.error(
                  'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
            return this
          }
        })
        class jl extends Hl {
          constructor(t, e) {
            super(t, e), (this.type = 'LineLoop')
          }
        }
        jl.prototype.isLineLoop = !0
        class ql extends br {
          constructor(t) {
            super(),
              (this.type = 'PointsMaterial'),
              (this.color = new Ar(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.morphTargets = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.morphTargets = t.morphTargets),
              this
            )
          }
        }
        ql.prototype.isPointsMaterial = !0
        const Xl = new Ii(),
          Yl = new Ci(),
          Zl = new Mi(),
          Jl = new ei()
        function Kl(t = new Qr(), e = new ql()) {
          ir.call(this), (this.type = 'Points'), (this.geometry = t), (this.material = e), this.updateMorphTargets()
        }
        function Ql(t, e, n, i, r, s, o) {
          const a = Yl.distanceSqToPoint(t)
          if (a < n) {
            const n = new ei()
            Yl.closestPointToPoint(t, n), n.applyMatrix4(i)
            const l = r.ray.origin.distanceTo(n)
            if (l < r.near || l > r.far) return
            s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o })
          }
        }
        Kl.prototype = Object.assign(Object.create(ir.prototype), {
          constructor: Kl,
          isPoints: !0,
          copy: function (t) {
            return ir.prototype.copy.call(this, t), (this.material = t.material), (this.geometry = t.geometry), this
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              s = n.drawRange
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Zl.copy(n.boundingSphere),
              Zl.applyMatrix4(i),
              (Zl.radius += r),
              !1 === t.ray.intersectsSphere(Zl))
            )
              return
            Xl.copy(i).invert(), Yl.copy(t.ray).applyMatrix4(Xl)
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o
            if (n.isBufferGeometry) {
              const r = n.index,
                o = n.attributes.position
              if (null !== r)
                for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                  const s = r.getX(n)
                  Jl.fromBufferAttribute(o, s), Ql(Jl, s, a, i, t, e, this)
                }
              else
                for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++)
                  Jl.fromBufferAttribute(o, n), Ql(Jl, n, a, i, t, e, this)
            } else
              console.error(
                'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
              )
          },
          updateMorphTargets: function () {
            const t = this.geometry
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e)
              if (n.length > 0) {
                const t = e[n[0]]
                if (void 0 !== t) {
                  ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e)
                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
                  }
                }
              }
            } else {
              const e = t.morphTargets
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
                )
            }
          }
        })
        class $l extends Zn {
          constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l),
              (this.format = void 0 !== o ? o : Ht),
              (this.minFilter = void 0 !== s ? s : Mt),
              (this.magFilter = void 0 !== r ? r : Mt),
              (this.generateMipmaps = !1)
            const c = this
            'requestVideoFrameCallback' in t &&
              t.requestVideoFrameCallback(function e() {
                ;(c.needsUpdate = !0), t.requestVideoFrameCallback(e)
              })
          }
          clone() {
            return new this.constructor(this.image).copy(this)
          }
          update() {
            const t = this.image
            !1 == 'requestVideoFrameCallback' in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
          }
        }
        $l.prototype.isVideoTexture = !0
        class tc extends Zn {
          constructor(t, e, n, i, r, s, o, a, l, c, h, u) {
            super(null, s, o, a, l, c, i, r, h, u),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1)
          }
        }
        tc.prototype.isCompressedTexture = !0
        class ec extends Zn {
          constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l), (this.needsUpdate = !0)
          }
        }
        ec.prototype.isCanvasTexture = !0
        class nc extends Zn {
          constructor(t, e, n, i, r, s, o, a, l, c) {
            if ((c = void 0 !== c ? c : qt) !== qt && c !== Xt)
              throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat')
            void 0 === n && c === qt && (n = Ct),
              void 0 === n && c === Xt && (n = kt),
              super(null, i, r, s, o, a, c, n, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== o ? o : yt),
              (this.minFilter = void 0 !== a ? a : yt),
              (this.flipY = !1),
              (this.generateMipmaps = !1)
          }
        }
        nc.prototype.isDepthTexture = !0
        class ic extends Qr {
          constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = 'CircleGeometry'),
              (this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }),
              (e = Math.max(3, e))
            const r = [],
              s = [],
              o = [],
              a = [],
              l = new ei(),
              c = new Wn()
            s.push(0, 0, 0), o.push(0, 0, 1), a.push(0.5, 0.5)
            for (let r = 0, h = 3; r <= e; r++, h += 3) {
              const u = n + (r / e) * i
              ;(l.x = t * Math.cos(u)),
                (l.y = t * Math.sin(u)),
                s.push(l.x, l.y, l.z),
                o.push(0, 0, 1),
                (c.x = (s[h] / t + 1) / 2),
                (c.y = (s[h + 1] / t + 1) / 2),
                a.push(c.x, c.y)
            }
            for (let t = 1; t <= e; t++) r.push(t, t + 1, 0)
            this.setIndex(r),
              this.setAttribute('position', new Ur(s, 3)),
              this.setAttribute('normal', new Ur(o, 3)),
              this.setAttribute('uv', new Ur(a, 2))
          }
        }
        class rc extends Qr {
          constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) {
            super(),
              (this.type = 'CylinderGeometry'),
              (this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: s,
                thetaStart: o,
                thetaLength: a
              })
            const l = this
            ;(i = Math.floor(i)), (r = Math.floor(r))
            const c = [],
              h = [],
              u = [],
              d = []
            let p = 0
            const m = [],
              f = n / 2
            let g = 0
            function v(n) {
              const r = p,
                s = new Wn(),
                m = new ei()
              let v = 0
              const y = !0 === n ? t : e,
                x = !0 === n ? 1 : -1
              for (let t = 1; t <= i; t++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++
              const b = p
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * a + o,
                  n = Math.cos(e),
                  r = Math.sin(e)
                ;(m.x = y * r),
                  (m.y = f * x),
                  (m.z = y * n),
                  h.push(m.x, m.y, m.z),
                  u.push(0, x, 0),
                  (s.x = 0.5 * n + 0.5),
                  (s.y = 0.5 * r * x + 0.5),
                  d.push(s.x, s.y),
                  p++
              }
              for (let t = 0; t < i; t++) {
                const e = r + t,
                  i = b + t
                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (v += 3)
              }
              l.addGroup(g, v, !0 === n ? 1 : 2), (g += v)
            }
            !(function () {
              const s = new ei(),
                v = new ei()
              let y = 0
              const x = (e - t) / n
              for (let l = 0; l <= r; l++) {
                const c = [],
                  g = l / r,
                  y = g * (e - t) + t
                for (let t = 0; t <= i; t++) {
                  const e = t / i,
                    r = e * a + o,
                    l = Math.sin(r),
                    m = Math.cos(r)
                  ;(v.x = y * l),
                    (v.y = -g * n + f),
                    (v.z = y * m),
                    h.push(v.x, v.y, v.z),
                    s.set(l, x, m).normalize(),
                    u.push(s.x, s.y, s.z),
                    d.push(e, 1 - g),
                    c.push(p++)
                }
                m.push(c)
              }
              for (let t = 0; t < i; t++)
                for (let e = 0; e < r; e++) {
                  const n = m[e][t],
                    i = m[e + 1][t],
                    r = m[e + 1][t + 1],
                    s = m[e][t + 1]
                  c.push(n, i, s), c.push(i, r, s), (y += 6)
                }
              l.addGroup(g, y, 0), (g += y)
            })(),
              !1 === s && (t > 0 && v(!0), e > 0 && v(!1)),
              this.setIndex(c),
              this.setAttribute('position', new Ur(h, 3)),
              this.setAttribute('normal', new Ur(u, 3)),
              this.setAttribute('uv', new Ur(d, 2))
          }
        }
        class sc extends rc {
          constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, o = 2 * Math.PI) {
            super(0, t, e, n, i, r, s, o),
              (this.type = 'ConeGeometry'),
              (this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: s,
                thetaLength: o
              })
          }
        }
        class oc extends Qr {
          constructor(t, e, n = 1, i = 0) {
            super(),
              (this.type = 'PolyhedronGeometry'),
              (this.parameters = { vertices: t, indices: e, radius: n, detail: i })
            const r = [],
              s = []
            function o(t, e, n, i) {
              const r = i + 1,
                s = []
              for (let i = 0; i <= r; i++) {
                s[i] = []
                const o = t.clone().lerp(n, i / r),
                  a = e.clone().lerp(n, i / r),
                  l = r - i
                for (let t = 0; t <= l; t++) s[i][t] = 0 === t && i === r ? o : o.clone().lerp(a, t / l)
              }
              for (let t = 0; t < r; t++)
                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                  const n = Math.floor(e / 2)
                  e % 2 == 0
                    ? (a(s[t][n + 1]), a(s[t + 1][n]), a(s[t][n]))
                    : (a(s[t][n + 1]), a(s[t + 1][n + 1]), a(s[t + 1][n]))
                }
            }
            function a(t) {
              r.push(t.x, t.y, t.z)
            }
            function l(e, n) {
              const i = 3 * e
              ;(n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2])
            }
            function c(t, e, n, i) {
              i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + 0.5)
            }
            function h(t) {
              return Math.atan2(t.z, -t.x)
            }
            !(function (t) {
              const n = new ei(),
                i = new ei(),
                r = new ei()
              for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), o(n, i, r, t)
            })(i),
              (function (t) {
                const e = new ei()
                for (let n = 0; n < r.length; n += 3)
                  (e.x = r[n + 0]),
                    (e.y = r[n + 1]),
                    (e.z = r[n + 2]),
                    e.normalize().multiplyScalar(t),
                    (r[n + 0] = e.x),
                    (r[n + 1] = e.y),
                    (r[n + 2] = e.z)
              })(n),
              (function () {
                const t = new ei()
                for (let n = 0; n < r.length; n += 3) {
                  ;(t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2])
                  const i = h(t) / 2 / Math.PI + 0.5,
                    o = ((e = t), Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + 0.5)
                  s.push(i, 1 - o)
                }
                var e
                ;(function () {
                  const t = new ei(),
                    e = new ei(),
                    n = new ei(),
                    i = new ei(),
                    o = new Wn(),
                    a = new Wn(),
                    l = new Wn()
                  for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]),
                      e.set(r[u + 3], r[u + 4], r[u + 5]),
                      n.set(r[u + 6], r[u + 7], r[u + 8]),
                      o.set(s[d + 0], s[d + 1]),
                      a.set(s[d + 2], s[d + 3]),
                      l.set(s[d + 4], s[d + 5]),
                      i.copy(t).add(e).add(n).divideScalar(3)
                    const p = h(i)
                    c(o, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p)
                  }
                })(),
                  (function () {
                    for (let t = 0; t < s.length; t += 6) {
                      const e = s[t + 0],
                        n = s[t + 2],
                        i = s[t + 4],
                        r = Math.max(e, n, i),
                        o = Math.min(e, n, i)
                      r > 0.9 &&
                        o < 0.1 &&
                        (e < 0.2 && (s[t + 0] += 1), n < 0.2 && (s[t + 2] += 1), i < 0.2 && (s[t + 4] += 1))
                    }
                  })()
              })(),
              this.setAttribute('position', new Ur(r, 3)),
              this.setAttribute('normal', new Ur(r.slice(), 3)),
              this.setAttribute('uv', new Ur(s, 2)),
              0 === i ? this.computeVertexNormals() : this.normalizeNormals()
          }
        }
        class ac extends oc {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
              i = 1 / n
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                0,
                -n,
                0,
                -i,
                n,
                0,
                -i,
                -n,
                0,
                i,
                n,
                0,
                i
              ],
              [
                3,
                11,
                7,
                3,
                7,
                15,
                3,
                15,
                13,
                7,
                19,
                17,
                7,
                17,
                6,
                7,
                6,
                15,
                17,
                4,
                8,
                17,
                8,
                10,
                17,
                10,
                6,
                8,
                0,
                16,
                8,
                16,
                2,
                8,
                2,
                10,
                0,
                12,
                1,
                0,
                1,
                18,
                0,
                18,
                16,
                6,
                10,
                2,
                6,
                2,
                13,
                6,
                13,
                15,
                2,
                16,
                18,
                2,
                18,
                3,
                2,
                3,
                13,
                18,
                1,
                9,
                18,
                9,
                11,
                18,
                11,
                3,
                4,
                14,
                12,
                4,
                12,
                0,
                4,
                0,
                8,
                11,
                9,
                5,
                11,
                5,
                19,
                11,
                19,
                7,
                19,
                5,
                14,
                19,
                14,
                4,
                19,
                4,
                17,
                1,
                12,
                14,
                1,
                14,
                5,
                1,
                5,
                9
              ],
              t,
              e
            ),
              (this.type = 'DodecahedronGeometry'),
              (this.parameters = { radius: t, detail: e })
          }
        }
        const lc = new ei(),
          cc = new ei(),
          hc = new ei(),
          uc = new yr()
        class dc extends Qr {
          constructor(t, e) {
            if (
              (super(),
              (this.type = 'EdgesGeometry'),
              (this.parameters = { thresholdAngle: e }),
              (e = void 0 !== e ? e : 1),
              !0 === t.isGeometry)
            )
              return void console.error(
                'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
              )
            const n = Math.pow(10, 4),
              i = Math.cos(Vn.DEG2RAD * e),
              r = t.getIndex(),
              s = t.getAttribute('position'),
              o = r ? r.count : s.count,
              a = [0, 0, 0],
              l = ['a', 'b', 'c'],
              c = new Array(3),
              h = {},
              u = []
            for (let t = 0; t < o; t += 3) {
              r
                ? ((a[0] = r.getX(t)), (a[1] = r.getX(t + 1)), (a[2] = r.getX(t + 2)))
                : ((a[0] = t), (a[1] = t + 1), (a[2] = t + 2))
              const { a: e, b: o, c: d } = uc
              if (
                (e.fromBufferAttribute(s, a[0]),
                o.fromBufferAttribute(s, a[1]),
                d.fromBufferAttribute(s, a[2]),
                uc.getNormal(hc),
                (c[0] = `${Math.round(e.x * n)},${Math.round(e.y * n)},${Math.round(e.z * n)}`),
                (c[1] = `${Math.round(o.x * n)},${Math.round(o.y * n)},${Math.round(o.z * n)}`),
                (c[2] = `${Math.round(d.x * n)},${Math.round(d.y * n)},${Math.round(d.z * n)}`),
                c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
              )
                for (let t = 0; t < 3; t++) {
                  const e = (t + 1) % 3,
                    n = c[t],
                    r = c[e],
                    s = uc[l[t]],
                    o = uc[l[e]],
                    d = `${n}_${r}`,
                    p = `${r}_${n}`
                  p in h && h[p]
                    ? (hc.dot(h[p].normal) <= i && (u.push(s.x, s.y, s.z), u.push(o.x, o.y, o.z)), (h[p] = null))
                    : d in h || (h[d] = { index0: a[t], index1: a[e], normal: hc.clone() })
                }
            }
            for (const t in h)
              if (h[t]) {
                const { index0: e, index1: n } = h[t]
                lc.fromBufferAttribute(s, e),
                  cc.fromBufferAttribute(s, n),
                  u.push(lc.x, lc.y, lc.z),
                  u.push(cc.x, cc.y, cc.z)
              }
            this.setAttribute('position', new Ur(u, 3))
          }
        }
        function pc(t, e, n, i, r) {
          let s, o
          if (
            r ===
            (function (t, e, n, i) {
              let r = 0
              for (let s = e, o = n - i; s < n; s += i) (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s)
              return r
            })(t, e, n, i) >
              0
          )
            for (s = e; s < n; s += i) o = Oc(s, t[s], t[s + 1], o)
          else for (s = n - i; s >= e; s -= i) o = Oc(s, t[s], t[s + 1], o)
          return o && Lc(o, o.next) && (Nc(o), (o = o.next)), o
        }
        function mc(t, e) {
          if (!t) return t
          e || (e = t)
          let n,
            i = t
          do {
            if (((n = !1), i.steiner || (!Lc(i, i.next) && 0 !== Ac(i.prev, i, i.next)))) i = i.next
            else {
              if ((Nc(i), (i = e = i.prev), i === i.next)) break
              n = !0
            }
          } while (n || i !== e)
          return e
        }
        function fc(t, e, n, i, r, s, o) {
          if (!t) return
          !o &&
            s &&
            (function (t, e, n, i) {
              let r = t
              do {
                null === r.z && (r.z = Mc(r.x, r.y, e, n, i)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next)
              } while (r !== t)
              ;(r.prevZ.nextZ = null),
                (r.prevZ = null),
                (function (t) {
                  let e,
                    n,
                    i,
                    r,
                    s,
                    o,
                    a,
                    l,
                    c = 1
                  do {
                    for (n = t, t = null, s = null, o = 0; n; ) {
                      for (o++, i = n, a = 0, e = 0; e < c && (a++, (i = i.nextZ), i); e++);
                      for (l = c; a > 0 || (l > 0 && i); )
                        0 !== a && (0 === l || !i || n.z <= i.z)
                          ? ((r = n), (n = n.nextZ), a--)
                          : ((r = i), (i = i.nextZ), l--),
                          s ? (s.nextZ = r) : (t = r),
                          (r.prevZ = s),
                          (s = r)
                      n = i
                    }
                    ;(s.nextZ = null), (c *= 2)
                  } while (o > 1)
                })(r)
            })(t, i, r, s)
          let a,
            l,
            c = t
          for (; t.prev !== t.next; )
            if (((a = t.prev), (l = t.next), s ? vc(t, i, r, s) : gc(t)))
              e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Nc(t), (t = l.next), (c = l.next)
            else if ((t = l) === c) {
              o
                ? 1 === o
                  ? fc((t = yc(mc(t), e, n)), e, n, i, r, s, 2)
                  : 2 === o && xc(t, e, n, i, r, s)
                : fc(mc(t), e, n, i, r, s, 1)
              break
            }
        }
        function gc(t) {
          const e = t.prev,
            n = t,
            i = t.next
          if (Ac(e, n, i) >= 0) return !1
          let r = t.next.next
          for (; r !== t.prev; ) {
            if (Sc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ac(r.prev, r, r.next) >= 0) return !1
            r = r.next
          }
          return !0
        }
        function vc(t, e, n, i) {
          const r = t.prev,
            s = t,
            o = t.next
          if (Ac(r, s, o) >= 0) return !1
          const a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
            l = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
            c = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
            h = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
            u = Mc(a, l, e, n, i),
            d = Mc(c, h, e, n, i)
          let p = t.prevZ,
            m = t.nextZ
          for (; p && p.z >= u && m && m.z <= d; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              Sc(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
              Ac(p.prev, p, p.next) >= 0
            )
              return !1
            if (
              ((p = p.prevZ),
              m !== t.prev && m !== t.next && Sc(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && Ac(m.prev, m, m.next) >= 0)
            )
              return !1
            m = m.nextZ
          }
          for (; p && p.z >= u; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              Sc(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
              Ac(p.prev, p, p.next) >= 0
            )
              return !1
            p = p.prevZ
          }
          for (; m && m.z <= d; ) {
            if (
              m !== t.prev &&
              m !== t.next &&
              Sc(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) &&
              Ac(m.prev, m, m.next) >= 0
            )
              return !1
            m = m.nextZ
          }
          return !0
        }
        function yc(t, e, n) {
          let i = t
          do {
            const r = i.prev,
              s = i.next.next
            !Lc(r, s) &&
              Rc(r, i, i.next, s) &&
              Ic(r, s) &&
              Ic(s, r) &&
              (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), Nc(i), Nc(i.next), (i = t = s)),
              (i = i.next)
          } while (i !== t)
          return mc(i)
        }
        function xc(t, e, n, i, r, s) {
          let o = t
          do {
            let t = o.next.next
            for (; t !== o.prev; ) {
              if (o.i !== t.i && Ec(o, t)) {
                let a = Dc(o, t)
                return (o = mc(o, o.next)), (a = mc(a, a.next)), fc(o, e, n, i, r, s), void fc(a, e, n, i, r, s)
              }
              t = t.next
            }
            o = o.next
          } while (o !== t)
        }
        function bc(t, e) {
          return t.x - e.x
        }
        function wc(t, e) {
          if (
            (e = (function (t, e) {
              let n = e
              const i = t.x,
                r = t.y
              let s,
                o = -1 / 0
              do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                  const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y)
                  if (t <= i && t > o) {
                    if (((o = t), t === i)) {
                      if (r === n.y) return n
                      if (r === n.next.y) return n.next
                    }
                    s = n.x < n.next.x ? n : n.next
                  }
                }
                n = n.next
              } while (n !== e)
              if (!s) return null
              if (i === o) return s
              const a = s,
                l = s.x,
                c = s.y
              let h,
                u = 1 / 0
              n = s
              do {
                i >= n.x &&
                  n.x >= l &&
                  i !== n.x &&
                  Sc(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) &&
                  ((h = Math.abs(r - n.y) / (i - n.x)),
                  Ic(n, t) && (h < u || (h === u && (n.x > s.x || (n.x === s.x && _c(s, n))))) && ((s = n), (u = h))),
                  (n = n.next)
              } while (n !== a)
              return s
            })(t, e))
          ) {
            const n = Dc(e, t)
            mc(e, e.next), mc(n, n.next)
          }
        }
        function _c(t, e) {
          return Ac(t.prev, t, e.prev) < 0 && Ac(e.next, t, t.next) < 0
        }
        function Mc(t, e, n, i, r) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) | (t << 4))) | (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) | (e << 4))) | (e << 2))) |
                (e << 1))) <<
              1)
          )
        }
        function Tc(t) {
          let e = t,
            n = t
          do {
            ;(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next)
          } while (e !== t)
          return n
        }
        function Sc(t, e, n, i, r, s, o, a) {
          return (
            (r - o) * (e - a) - (t - o) * (s - a) >= 0 &&
            (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
            (n - o) * (s - a) - (r - o) * (i - a) >= 0
          )
        }
        function Ec(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              let n = t
              do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Rc(n, n.next, t, e)) return !0
                n = n.next
              } while (n !== t)
              return !1
            })(t, e) &&
            ((Ic(t, e) &&
              Ic(e, t) &&
              (function (t, e) {
                let n = t,
                  i = !1
                const r = (t.x + e.x) / 2,
                  s = (t.y + e.y) / 2
                do {
                  n.y > s != n.next.y > s &&
                    n.next.y !== n.y &&
                    r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                    (i = !i),
                    (n = n.next)
                } while (n !== t)
                return i
              })(t, e) &&
              (Ac(t.prev, t, e.prev) || Ac(t, e.prev, e))) ||
              (Lc(t, e) && Ac(t.prev, t, t.next) > 0 && Ac(e.prev, e, e.next) > 0))
          )
        }
        function Ac(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function Lc(t, e) {
          return t.x === e.x && t.y === e.y
        }
        function Rc(t, e, n, i) {
          const r = Cc(Ac(t, e, n)),
            s = Cc(Ac(t, e, i)),
            o = Cc(Ac(n, i, t)),
            a = Cc(Ac(n, i, e))
          return (
            (r !== s && o !== a) ||
            !(0 !== r || !Pc(t, n, e)) ||
            !(0 !== s || !Pc(t, i, e)) ||
            !(0 !== o || !Pc(n, t, i)) ||
            !(0 !== a || !Pc(n, e, i))
          )
        }
        function Pc(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          )
        }
        function Cc(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Ic(t, e) {
          return Ac(t.prev, t, t.next) < 0
            ? Ac(t, e, t.next) >= 0 && Ac(t, t.prev, e) >= 0
            : Ac(t, e, t.prev) < 0 || Ac(t, t.next, e) < 0
        }
        function Dc(t, e) {
          const n = new Bc(t.i, t.x, t.y),
            i = new Bc(e.i, e.x, e.y),
            r = t.next,
            s = e.prev
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = r),
            (r.prev = n),
            (i.next = n),
            (n.prev = i),
            (s.next = i),
            (i.prev = s),
            i
          )
        }
        function Oc(t, e, n, i) {
          const r = new Bc(t, e, n)
          return (
            i ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r)) : ((r.prev = r), (r.next = r)), r
          )
        }
        function Nc(t) {
          ;(t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Bc(t, e, n) {
          ;(this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1)
        }
        const Fc = {
          area: function (t) {
            const e = t.length
            let n = 0
            for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y
            return 0.5 * n
          },
          isClockWise: function (t) {
            return Fc.area(t) < 0
          },
          triangulateShape: function (t, e) {
            const n = [],
              i = [],
              r = []
            zc(t), kc(n, t)
            let s = t.length
            e.forEach(zc)
            for (let t = 0; t < e.length; t++) i.push(s), (s += e[t].length), kc(n, e[t])
            const o = (function (t, e, n) {
              n = n || 2
              const i = e && e.length,
                r = i ? e[0] * n : t.length
              let s = pc(t, 0, r, n, !0)
              const o = []
              if (!s || s.next === s.prev) return o
              let a, l, c, h, u, d, p
              if (
                (i &&
                  (s = (function (t, e, n, i) {
                    const r = []
                    let s, o, a, l, c
                    for (s = 0, o = e.length; s < o; s++)
                      (a = e[s] * i),
                        (l = s < o - 1 ? e[s + 1] * i : t.length),
                        (c = pc(t, a, l, i, !1)),
                        c === c.next && (c.steiner = !0),
                        r.push(Tc(c))
                    for (r.sort(bc), s = 0; s < r.length; s++) wc(r[s], n), (n = mc(n, n.next))
                    return n
                  })(t, e, s, n)),
                t.length > 80 * n)
              ) {
                ;(a = c = t[0]), (l = h = t[1])
                for (let e = n; e < r; e += n)
                  (u = t[e]), (d = t[e + 1]), u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d)
                ;(p = Math.max(c - a, h - l)), (p = 0 !== p ? 1 / p : 0)
              }
              return fc(s, o, n, a, l, p), o
            })(n, i)
            for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3))
            return r
          }
        }
        function zc(t) {
          const e = t.length
          e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function kc(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
        }
        class Uc extends Qr {
          constructor(t, e) {
            super(),
              (this.type = 'ExtrudeGeometry'),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t])
            const n = this,
              i = [],
              r = []
            for (let e = 0, n = t.length; e < n; e++) s(t[e])
            function s(t) {
              const s = [],
                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                a = void 0 !== e.steps ? e.steps : 1
              let l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3
              const m = e.extrudePath,
                f = void 0 !== e.UVGenerator ? e.UVGenerator : Hc
              void 0 !== e.amount &&
                (console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'), (l = e.amount))
              let g,
                v,
                y,
                x,
                b,
                w = !1
              m &&
                ((g = m.getSpacedPoints(a)),
                (w = !0),
                (c = !1),
                (v = m.computeFrenetFrames(a, !1)),
                (y = new ei()),
                (x = new ei()),
                (b = new ei())),
                c || ((p = 0), (h = 0), (u = 0), (d = 0))
              const _ = t.extractPoints(o)
              let M = _.shape
              const T = _.holes
              if (!Fc.isClockWise(M)) {
                M = M.reverse()
                for (let t = 0, e = T.length; t < e; t++) {
                  const e = T[t]
                  Fc.isClockWise(e) && (T[t] = e.reverse())
                }
              }
              const S = Fc.triangulateShape(M, T),
                E = M
              for (let t = 0, e = T.length; t < e; t++) {
                const e = T[t]
                M = M.concat(e)
              }
              function A(t, e, n) {
                return (
                  e || console.error('THREE.ExtrudeGeometry: vec does not exist'), e.clone().multiplyScalar(n).add(t)
                )
              }
              const L = M.length,
                R = S.length
              function P(t, e, n) {
                let i, r, s
                const o = t.x - e.x,
                  a = t.y - e.y,
                  l = n.x - t.x,
                  c = n.y - t.y,
                  h = o * o + a * a,
                  u = o * c - a * l
                if (Math.abs(u) > Number.EPSILON) {
                  const u = Math.sqrt(h),
                    d = Math.sqrt(l * l + c * c),
                    p = e.x - a / u,
                    m = e.y + o / u,
                    f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (o * c - a * l)
                  ;(i = p + o * f - t.x), (r = m + a * f - t.y)
                  const g = i * i + r * r
                  if (g <= 2) return new Wn(i, r)
                  s = Math.sqrt(g / 2)
                } else {
                  let t = !1
                  o > Number.EPSILON
                    ? l > Number.EPSILON && (t = !0)
                    : o < -Number.EPSILON
                    ? l < -Number.EPSILON && (t = !0)
                    : Math.sign(a) === Math.sign(c) && (t = !0),
                    t ? ((i = -a), (r = o), (s = Math.sqrt(h))) : ((i = o), (r = a), (s = Math.sqrt(h / 2)))
                }
                return new Wn(i / s, r / s)
              }
              const C = []
              for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)
                n === e && (n = 0), i === e && (i = 0), (C[t] = P(E[t], E[n], E[i]))
              const I = []
              let D,
                O = C.concat()
              for (let t = 0, e = T.length; t < e; t++) {
                const e = T[t]
                D = []
                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++)
                  i === n && (i = 0), r === n && (r = 0), (D[t] = P(e[t], e[i], e[r]))
                I.push(D), (O = O.concat(D))
              }
              for (let t = 0; t < p; t++) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = A(E[t], C[t], i)
                  F(e.x, e.y, -n)
                }
                for (let t = 0, e = T.length; t < e; t++) {
                  const e = T[t]
                  D = I[t]
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = A(e[t], D[t], i)
                    F(r.x, r.y, -n)
                  }
                }
              }
              const N = u + d
              for (let t = 0; t < L; t++) {
                const e = c ? A(M[t], O[t], N) : M[t]
                w
                  ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                    y.copy(v.binormals[0]).multiplyScalar(e.y),
                    b.copy(g[0]).add(x).add(y),
                    F(b.x, b.y, b.z))
                  : F(e.x, e.y, 0)
              }
              for (let t = 1; t <= a; t++)
                for (let e = 0; e < L; e++) {
                  const n = c ? A(M[e], O[e], N) : M[e]
                  w
                    ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                      y.copy(v.binormals[t]).multiplyScalar(n.y),
                      b.copy(g[t]).add(x).add(y),
                      F(b.x, b.y, b.z))
                    : F(n.x, n.y, (l / a) * t)
                }
              for (let t = p - 1; t >= 0; t--) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = A(E[t], C[t], i)
                  F(e.x, e.y, l + n)
                }
                for (let t = 0, e = T.length; t < e; t++) {
                  const e = T[t]
                  D = I[t]
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = A(e[t], D[t], i)
                    w ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, l + n)
                  }
                }
              }
              function B(t, e) {
                let n = t.length
                for (; --n >= 0; ) {
                  const i = n
                  let r = n - 1
                  r < 0 && (r = t.length - 1)
                  for (let t = 0, n = a + 2 * p; t < n; t++) {
                    const n = L * t,
                      s = L * (t + 1)
                    k(e + i + n, e + r + n, e + r + s, e + i + s)
                  }
                }
              }
              function F(t, e, n) {
                s.push(t), s.push(e), s.push(n)
              }
              function z(t, e, r) {
                U(t), U(e), U(r)
                const s = i.length / 3,
                  o = f.generateTopUV(n, i, s - 3, s - 2, s - 1)
                H(o[0]), H(o[1]), H(o[2])
              }
              function k(t, e, r, s) {
                U(t), U(e), U(s), U(e), U(r), U(s)
                const o = i.length / 3,
                  a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1)
                H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
              }
              function U(t) {
                i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2])
              }
              function H(t) {
                r.push(t.x), r.push(t.y)
              }
              !(function () {
                const t = i.length / 3
                if (c) {
                  let t = 0,
                    e = L * t
                  for (let t = 0; t < R; t++) {
                    const n = S[t]
                    z(n[2] + e, n[1] + e, n[0] + e)
                  }
                  ;(t = a + 2 * p), (e = L * t)
                  for (let t = 0; t < R; t++) {
                    const n = S[t]
                    z(n[0] + e, n[1] + e, n[2] + e)
                  }
                } else {
                  for (let t = 0; t < R; t++) {
                    const e = S[t]
                    z(e[2], e[1], e[0])
                  }
                  for (let t = 0; t < R; t++) {
                    const e = S[t]
                    z(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                  }
                }
                n.addGroup(t, i.length / 3 - t, 0)
              })(),
                (function () {
                  const t = i.length / 3
                  let e = 0
                  B(E, e), (e += E.length)
                  for (let t = 0, n = T.length; t < n; t++) {
                    const n = T[t]
                    B(n, e), (e += n.length)
                  }
                  n.addGroup(t, i.length / 3 - t, 1)
                })()
            }
            this.setAttribute('position', new Ur(i, 3)),
              this.setAttribute('uv', new Ur(r, 2)),
              this.computeVertexNormals()
          }
          toJSON() {
            const t = Qr.prototype.toJSON.call(this)
            return (function (t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e]
                  n.shapes.push(i.uuid)
                }
              else n.shapes.push(t.uuid)
              return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            })(this.parameters.shapes, this.parameters.options, t)
          }
        }
        const Hc = {
          generateTopUV: function (t, e, n, i, r) {
            const s = e[3 * n],
              o = e[3 * n + 1],
              a = e[3 * i],
              l = e[3 * i + 1],
              c = e[3 * r],
              h = e[3 * r + 1]
            return [new Wn(s, o), new Wn(a, l), new Wn(c, h)]
          },
          generateSideWallUV: function (t, e, n, i, r, s) {
            const o = e[3 * n],
              a = e[3 * n + 1],
              l = e[3 * n + 2],
              c = e[3 * i],
              h = e[3 * i + 1],
              u = e[3 * i + 2],
              d = e[3 * r],
              p = e[3 * r + 1],
              m = e[3 * r + 2],
              f = e[3 * s],
              g = e[3 * s + 1],
              v = e[3 * s + 2]
            return Math.abs(a - h) < 0.01
              ? [new Wn(o, 1 - l), new Wn(c, 1 - u), new Wn(d, 1 - m), new Wn(f, 1 - v)]
              : [new Wn(a, 1 - l), new Wn(h, 1 - u), new Wn(p, 1 - m), new Wn(g, 1 - v)]
          }
        }
        class Gc extends oc {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2
            super(
              [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1
              ],
              [
                0,
                11,
                5,
                0,
                5,
                1,
                0,
                1,
                7,
                0,
                7,
                10,
                0,
                10,
                11,
                1,
                5,
                9,
                5,
                11,
                4,
                11,
                10,
                2,
                10,
                7,
                6,
                7,
                1,
                8,
                3,
                9,
                4,
                3,
                4,
                2,
                3,
                2,
                6,
                3,
                6,
                8,
                3,
                8,
                9,
                4,
                9,
                5,
                2,
                4,
                11,
                6,
                2,
                10,
                8,
                6,
                7,
                9,
                8,
                1
              ],
              t,
              e
            ),
              (this.type = 'IcosahedronGeometry'),
              (this.parameters = { radius: t, detail: e })
          }
        }
        class Vc extends Qr {
          constructor(t, e = 12, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = 'LatheGeometry'),
              (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
              (e = Math.floor(e)),
              (i = Vn.clamp(i, 0, 2 * Math.PI))
            const r = [],
              s = [],
              o = [],
              a = 1 / e,
              l = new ei(),
              c = new Wn()
            for (let r = 0; r <= e; r++) {
              const h = n + r * a * i,
                u = Math.sin(h),
                d = Math.cos(h)
              for (let n = 0; n <= t.length - 1; n++)
                (l.x = t[n].x * u),
                  (l.y = t[n].y),
                  (l.z = t[n].x * d),
                  s.push(l.x, l.y, l.z),
                  (c.x = r / e),
                  (c.y = n / (t.length - 1)),
                  o.push(c.x, c.y)
            }
            for (let n = 0; n < e; n++)
              for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                  s = i,
                  o = i + t.length,
                  a = i + t.length + 1,
                  l = i + 1
                r.push(s, o, l), r.push(o, a, l)
              }
            if (
              (this.setIndex(r),
              this.setAttribute('position', new Ur(s, 3)),
              this.setAttribute('uv', new Ur(o, 2)),
              this.computeVertexNormals(),
              i === 2 * Math.PI)
            ) {
              const n = this.attributes.normal.array,
                i = new ei(),
                r = new ei(),
                s = new ei(),
                o = e * t.length * 3
              for (let e = 0, a = 0; e < t.length; e++, a += 3)
                (i.x = n[a + 0]),
                  (i.y = n[a + 1]),
                  (i.z = n[a + 2]),
                  (r.x = n[o + a + 0]),
                  (r.y = n[o + a + 1]),
                  (r.z = n[o + a + 2]),
                  s.addVectors(i, r).normalize(),
                  (n[a + 0] = n[o + a + 0] = s.x),
                  (n[a + 1] = n[o + a + 1] = s.y),
                  (n[a + 2] = n[o + a + 2] = s.z)
            }
          }
        }
        class Wc extends oc {
          constructor(t = 1, e = 0) {
            super(
              [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
              [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
              t,
              e
            ),
              (this.type = 'OctahedronGeometry'),
              (this.parameters = { radius: t, detail: e })
          }
        }
        function jc(t, e, n) {
          Qr.call(this), (this.type = 'ParametricGeometry'), (this.parameters = { func: t, slices: e, stacks: n })
          const i = [],
            r = [],
            s = [],
            o = [],
            a = 1e-5,
            l = new ei(),
            c = new ei(),
            h = new ei(),
            u = new ei(),
            d = new ei()
          t.length < 3 &&
            console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.')
          const p = e + 1
          for (let i = 0; i <= n; i++) {
            const p = i / n
            for (let n = 0; n <= e; n++) {
              const i = n / e
              t(i, p, c),
                r.push(c.x, c.y, c.z),
                i - a >= 0 ? (t(i - a, p, h), u.subVectors(c, h)) : (t(i + a, p, h), u.subVectors(h, c)),
                p - a >= 0 ? (t(i, p - a, h), d.subVectors(c, h)) : (t(i, p + a, h), d.subVectors(h, c)),
                l.crossVectors(u, d).normalize(),
                s.push(l.x, l.y, l.z),
                o.push(i, p)
            }
          }
          for (let t = 0; t < n; t++)
            for (let n = 0; n < e; n++) {
              const e = t * p + n,
                r = t * p + n + 1,
                s = (t + 1) * p + n + 1,
                o = (t + 1) * p + n
              i.push(e, r, o), i.push(r, s, o)
            }
          this.setIndex(i),
            this.setAttribute('position', new Ur(r, 3)),
            this.setAttribute('normal', new Ur(s, 3)),
            this.setAttribute('uv', new Ur(o, 2))
        }
        ;(jc.prototype = Object.create(Qr.prototype)), (jc.prototype.constructor = jc)
        class qc extends Qr {
          constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
            super(),
              (this.type = 'RingGeometry'),
              (this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: s
              }),
              (n = Math.max(3, n))
            const o = [],
              a = [],
              l = [],
              c = []
            let h = t
            const u = (e - t) / (i = Math.max(1, i)),
              d = new ei(),
              p = new Wn()
            for (let t = 0; t <= i; t++) {
              for (let t = 0; t <= n; t++) {
                const i = r + (t / n) * s
                ;(d.x = h * Math.cos(i)),
                  (d.y = h * Math.sin(i)),
                  a.push(d.x, d.y, d.z),
                  l.push(0, 0, 1),
                  (p.x = (d.x / e + 1) / 2),
                  (p.y = (d.y / e + 1) / 2),
                  c.push(p.x, p.y)
              }
              h += u
            }
            for (let t = 0; t < i; t++) {
              const e = t * (n + 1)
              for (let t = 0; t < n; t++) {
                const i = t + e,
                  r = i,
                  s = i + n + 1,
                  a = i + n + 2,
                  l = i + 1
                o.push(r, s, l), o.push(s, a, l)
              }
            }
            this.setIndex(o),
              this.setAttribute('position', new Ur(a, 3)),
              this.setAttribute('normal', new Ur(l, 3)),
              this.setAttribute('uv', new Ur(c, 2))
          }
        }
        class Xc extends Qr {
          constructor(t, e = 12) {
            super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: t, curveSegments: e })
            const n = [],
              i = [],
              r = [],
              s = []
            let o = 0,
              a = 0
            if (!1 === Array.isArray(t)) l(t)
            else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), (o += a), (a = 0)
            function l(t) {
              const o = i.length / 3,
                l = t.extractPoints(e)
              let c = l.shape
              const h = l.holes
              !1 === Fc.isClockWise(c) && (c = c.reverse())
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t]
                !0 === Fc.isClockWise(e) && (h[t] = e.reverse())
              }
              const u = Fc.triangulateShape(c, h)
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t]
                c = c.concat(e)
              }
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t]
                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
              }
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t],
                  i = e[0] + o,
                  r = e[1] + o,
                  s = e[2] + o
                n.push(i, r, s), (a += 3)
              }
            }
            this.setIndex(n),
              this.setAttribute('position', new Ur(i, 3)),
              this.setAttribute('normal', new Ur(r, 3)),
              this.setAttribute('uv', new Ur(s, 2))
          }
          toJSON() {
            const t = Qr.prototype.toJSON.call(this)
            return (function (t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n]
                  e.shapes.push(i.uuid)
                }
              else e.shapes.push(t.uuid)
              return e
            })(this.parameters.shapes, t)
          }
        }
        class Yc extends Qr {
          constructor(t = 1, e = 8, n = 6, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) {
            super(),
              (this.type = 'SphereGeometry'),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: o
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)))
            const a = Math.min(s + o, Math.PI)
            let l = 0
            const c = [],
              h = new ei(),
              u = new ei(),
              d = [],
              p = [],
              m = [],
              f = []
            for (let d = 0; d <= n; d++) {
              const g = [],
                v = d / n
              let y = 0
              0 == d && 0 == s ? (y = 0.5 / e) : d == n && a == Math.PI && (y = -0.5 / e)
              for (let n = 0; n <= e; n++) {
                const a = n / e
                ;(h.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o)),
                  (h.y = t * Math.cos(s + v * o)),
                  (h.z = t * Math.sin(i + a * r) * Math.sin(s + v * o)),
                  p.push(h.x, h.y, h.z),
                  u.copy(h).normalize(),
                  m.push(u.x, u.y, u.z),
                  f.push(a + y, 1 - v),
                  g.push(l++)
              }
              c.push(g)
            }
            for (let t = 0; t < n; t++)
              for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                  r = c[t][i],
                  o = c[t + 1][i],
                  l = c[t + 1][i + 1]
                ;(0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
              }
            this.setIndex(d),
              this.setAttribute('position', new Ur(p, 3)),
              this.setAttribute('normal', new Ur(m, 3)),
              this.setAttribute('uv', new Ur(f, 2))
          }
        }
        class Zc extends oc {
          constructor(t = 1, e = 0) {
            super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
              (this.type = 'TetrahedronGeometry'),
              (this.parameters = { radius: t, detail: e })
          }
        }
        class Jc extends Uc {
          constructor(t, e = {}) {
            const n = e.font
            if (!n || !n.isFont)
              return console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.'), new Qr()
            const i = n.generateShapes(t, e.size)
            ;(e.depth = void 0 !== e.height ? e.height : 50),
              void 0 === e.bevelThickness && (e.bevelThickness = 10),
              void 0 === e.bevelSize && (e.bevelSize = 8),
              void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
              super(i, e),
              (this.type = 'TextGeometry')
          }
        }
        class Kc extends Qr {
          constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
            super(),
              (this.type = 'TorusGeometry'),
              (this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }),
              (n = Math.floor(n)),
              (i = Math.floor(i))
            const s = [],
              o = [],
              a = [],
              l = [],
              c = new ei(),
              h = new ei(),
              u = new ei()
            for (let s = 0; s <= n; s++)
              for (let d = 0; d <= i; d++) {
                const p = (d / i) * r,
                  m = (s / n) * Math.PI * 2
                ;(h.x = (t + e * Math.cos(m)) * Math.cos(p)),
                  (h.y = (t + e * Math.cos(m)) * Math.sin(p)),
                  (h.z = e * Math.sin(m)),
                  o.push(h.x, h.y, h.z),
                  (c.x = t * Math.cos(p)),
                  (c.y = t * Math.sin(p)),
                  u.subVectors(h, c).normalize(),
                  a.push(u.x, u.y, u.z),
                  l.push(d / i),
                  l.push(s / n)
              }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                  r = (i + 1) * (t - 1) + e - 1,
                  o = (i + 1) * (t - 1) + e,
                  a = (i + 1) * t + e
                s.push(n, r, a), s.push(r, o, a)
              }
            this.setIndex(s),
              this.setAttribute('position', new Ur(o, 3)),
              this.setAttribute('normal', new Ur(a, 3)),
              this.setAttribute('uv', new Ur(l, 2))
          }
        }
        class Qc extends Qr {
          constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, s = 3) {
            super(),
              (this.type = 'TorusKnotGeometry'),
              (this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: s }),
              (n = Math.floor(n)),
              (i = Math.floor(i))
            const o = [],
              a = [],
              l = [],
              c = [],
              h = new ei(),
              u = new ei(),
              d = new ei(),
              p = new ei(),
              m = new ei(),
              f = new ei(),
              g = new ei()
            for (let o = 0; o <= n; ++o) {
              const y = (o / n) * r * Math.PI * 2
              v(y, r, s, t, d),
                v(y + 0.01, r, s, t, p),
                f.subVectors(p, d),
                g.addVectors(p, d),
                m.crossVectors(f, g),
                g.crossVectors(m, f),
                m.normalize(),
                g.normalize()
              for (let t = 0; t <= i; ++t) {
                const r = (t / i) * Math.PI * 2,
                  s = -e * Math.cos(r),
                  p = e * Math.sin(r)
                ;(h.x = d.x + (s * g.x + p * m.x)),
                  (h.y = d.y + (s * g.y + p * m.y)),
                  (h.z = d.z + (s * g.z + p * m.z)),
                  a.push(h.x, h.y, h.z),
                  u.subVectors(h, d).normalize(),
                  l.push(u.x, u.y, u.z),
                  c.push(o / n),
                  c.push(t / i)
              }
            }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  s = (i + 1) * t + e,
                  a = (i + 1) * (t - 1) + e
                o.push(n, r, a), o.push(r, s, a)
              }
            function v(t, e, n, i, r) {
              const s = Math.cos(t),
                o = Math.sin(t),
                a = (n / e) * t,
                l = Math.cos(a)
              ;(r.x = i * (2 + l) * 0.5 * s), (r.y = i * (2 + l) * o * 0.5), (r.z = i * Math.sin(a) * 0.5)
            }
            this.setIndex(o),
              this.setAttribute('position', new Ur(a, 3)),
              this.setAttribute('normal', new Ur(l, 3)),
              this.setAttribute('uv', new Ur(c, 2))
          }
        }
        class $c extends Qr {
          constructor(t, e = 64, n = 1, i = 8, r = !1) {
            super(),
              (this.type = 'TubeGeometry'),
              (this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r })
            const s = t.computeFrenetFrames(e, r)
            ;(this.tangents = s.tangents), (this.normals = s.normals), (this.binormals = s.binormals)
            const o = new ei(),
              a = new ei(),
              l = new Wn()
            let c = new ei()
            const h = [],
              u = [],
              d = [],
              p = []
            function m(r) {
              c = t.getPointAt(r / e, c)
              const l = s.normals[r],
                d = s.binormals[r]
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * Math.PI * 2,
                  r = Math.sin(e),
                  s = -Math.cos(e)
                ;(a.x = s * l.x + r * d.x),
                  (a.y = s * l.y + r * d.y),
                  (a.z = s * l.z + r * d.z),
                  a.normalize(),
                  u.push(a.x, a.y, a.z),
                  (o.x = c.x + n * a.x),
                  (o.y = c.y + n * a.y),
                  (o.z = c.z + n * a.z),
                  h.push(o.x, o.y, o.z)
              }
            }
            !(function () {
              for (let t = 0; t < e; t++) m(t)
              m(!1 === r ? e : 0),
                (function () {
                  for (let t = 0; t <= e; t++)
                    for (let n = 0; n <= i; n++) (l.x = t / e), (l.y = n / i), d.push(l.x, l.y)
                })(),
                (function () {
                  for (let t = 1; t <= e; t++)
                    for (let e = 1; e <= i; e++) {
                      const n = (i + 1) * (t - 1) + (e - 1),
                        r = (i + 1) * t + (e - 1),
                        s = (i + 1) * t + e,
                        o = (i + 1) * (t - 1) + e
                      p.push(n, r, o), p.push(r, s, o)
                    }
                })()
            })(),
              this.setIndex(p),
              this.setAttribute('position', new Ur(h, 3)),
              this.setAttribute('normal', new Ur(u, 3)),
              this.setAttribute('uv', new Ur(d, 2))
          }
          toJSON() {
            const t = Qr.prototype.toJSON.call(this)
            return (t.path = this.parameters.path.toJSON()), t
          }
        }
        class th extends Qr {
          constructor(t) {
            if ((super(), (this.type = 'WireframeGeometry'), !0 === t.isGeometry))
              return void console.error(
                'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
              )
            const e = [],
              n = [0, 0],
              i = {},
              r = new ei()
            if (null !== t.index) {
              const s = t.attributes.position,
                o = t.index
              let a = t.groups
              0 === a.length && (a = [{ start: 0, count: o.count, materialIndex: 0 }])
              for (let t = 0, e = a.length; t < e; ++t) {
                const e = a[t],
                  r = e.start
                for (let t = r, s = r + e.count; t < s; t += 3)
                  for (let e = 0; e < 3; e++) {
                    const r = o.getX(t + e),
                      s = o.getX(t + ((e + 1) % 3))
                    ;(n[0] = Math.min(r, s)), (n[1] = Math.max(r, s))
                    const a = n[0] + ',' + n[1]
                    void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] })
                  }
              }
              for (const t in i) {
                const n = i[t]
                r.fromBufferAttribute(s, n.index1),
                  e.push(r.x, r.y, r.z),
                  r.fromBufferAttribute(s, n.index2),
                  e.push(r.x, r.y, r.z)
              }
            } else {
              const n = t.attributes.position
              for (let t = 0, i = n.count / 3; t < i; t++)
                for (let i = 0; i < 3; i++) {
                  const s = 3 * t + i
                  r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z)
                  const o = 3 * t + ((i + 1) % 3)
                  r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z)
                }
            }
            this.setAttribute('position', new Ur(e, 3))
          }
        }
        var eh = Object.freeze({
          __proto__: null,
          BoxGeometry: ys,
          BoxBufferGeometry: ys,
          CircleGeometry: ic,
          CircleBufferGeometry: ic,
          ConeGeometry: sc,
          ConeBufferGeometry: sc,
          CylinderGeometry: rc,
          CylinderBufferGeometry: rc,
          DodecahedronGeometry: ac,
          DodecahedronBufferGeometry: ac,
          EdgesGeometry: dc,
          ExtrudeGeometry: Uc,
          ExtrudeBufferGeometry: Uc,
          IcosahedronGeometry: Gc,
          IcosahedronBufferGeometry: Gc,
          LatheGeometry: Vc,
          LatheBufferGeometry: Vc,
          OctahedronGeometry: Wc,
          OctahedronBufferGeometry: Wc,
          ParametricGeometry: jc,
          ParametricBufferGeometry: jc,
          PlaneGeometry: Ns,
          PlaneBufferGeometry: Ns,
          PolyhedronGeometry: oc,
          PolyhedronBufferGeometry: oc,
          RingGeometry: qc,
          RingBufferGeometry: qc,
          ShapeGeometry: Xc,
          ShapeBufferGeometry: Xc,
          SphereGeometry: Yc,
          SphereBufferGeometry: Yc,
          TetrahedronGeometry: Zc,
          TetrahedronBufferGeometry: Zc,
          TextGeometry: Jc,
          TextBufferGeometry: Jc,
          TorusGeometry: Kc,
          TorusBufferGeometry: Kc,
          TorusKnotGeometry: Qc,
          TorusKnotBufferGeometry: Qc,
          TubeGeometry: $c,
          TubeBufferGeometry: $c,
          WireframeGeometry: th
        })
        class nh extends br {
          constructor(t) {
            super(),
              (this.type = 'ShadowMaterial'),
              (this.color = new Ar(0)),
              (this.transparent = !0),
              this.setValues(t)
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), this
          }
        }
        nh.prototype.isShadowMaterial = !0
        class ih extends _s {
          constructor(t) {
            super(t), (this.type = 'RawShaderMaterial')
          }
        }
        function rh(t) {
          br.call(this),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new Ar(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ar(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = un),
            (this.normalScale = new Wn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.skinning = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            (this.vertexTangents = !1),
            this.setValues(t)
        }
        function sh(t) {
          rh.call(this),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Wn(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, 'ior', {
              get: function () {
                return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
              },
              set: function (t) {
                this.reflectivity = Vn.clamp((2.5 * (t - 1)) / (t + 1), 0, 1)
              }
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            this.setValues(t)
        }
        ;(ih.prototype.isRawShaderMaterial = !0),
          (rh.prototype = Object.create(br.prototype)),
          (rh.prototype.constructor = rh),
          (rh.prototype.isMeshStandardMaterial = !0),
          (rh.prototype.copy = function (t) {
            return (
              br.prototype.copy.call(this, t),
              (this.defines = { STANDARD: '' }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              (this.vertexTangents = t.vertexTangents),
              this
            )
          }),
          (sh.prototype = Object.create(rh.prototype)),
          (sh.prototype.constructor = sh),
          (sh.prototype.isMeshPhysicalMaterial = !0),
          (sh.prototype.copy = function (t) {
            return (
              rh.prototype.copy.call(this, t),
              (this.defines = { STANDARD: '', PHYSICAL: '' }),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.reflectivity = t.reflectivity),
              t.sheen ? (this.sheen = (this.sheen || new Ar()).copy(t.sheen)) : (this.sheen = null),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              this
            )
          })
        class oh extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshPhongMaterial'),
              (this.color = new Ar(16777215)),
              (this.specular = new Ar(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ar(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = un),
              (this.normalScale = new Wn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }
        oh.prototype.isMeshPhongMaterial = !0
        class ah extends br {
          constructor(t) {
            super(),
              (this.defines = { TOON: '' }),
              (this.type = 'MeshToonMaterial'),
              (this.color = new Ar(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ar(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = un),
              (this.normalScale = new Wn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            )
          }
        }
        ah.prototype.isMeshToonMaterial = !0
        class lh extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshNormalMaterial'),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = un),
              (this.normalScale = new Wn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }
        lh.prototype.isMeshNormalMaterial = !0
        class ch extends br {
          constructor(t) {
            super(),
              (this.type = 'MeshLambertMaterial'),
              (this.color = new Ar(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Ar(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            )
          }
        }
        ch.prototype.isMeshLambertMaterial = !0
        class hh extends br {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: '' }),
              (this.type = 'MeshMatcapMaterial'),
              (this.color = new Ar(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = un),
              (this.normalScale = new Wn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: '' }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            )
          }
        }
        hh.prototype.isMeshMatcapMaterial = !0
        class uh extends Nl {
          constructor(t) {
            super(),
              (this.type = 'LineDashedMaterial'),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t)
          }
          copy(t) {
            return super.copy(t), (this.scale = t.scale), (this.dashSize = t.dashSize), (this.gapSize = t.gapSize), this
          }
        }
        uh.prototype.isLineDashedMaterial = !0
        var dh = Object.freeze({
          __proto__: null,
          ShadowMaterial: nh,
          SpriteMaterial: el,
          RawShaderMaterial: ih,
          ShaderMaterial: _s,
          PointsMaterial: ql,
          MeshPhysicalMaterial: sh,
          MeshStandardMaterial: rh,
          MeshPhongMaterial: oh,
          MeshToonMaterial: ah,
          MeshNormalMaterial: lh,
          MeshLambertMaterial: ch,
          MeshDepthMaterial: Ba,
          MeshDistanceMaterial: Fa,
          MeshBasicMaterial: Lr,
          MeshMatcapMaterial: hh,
          LineDashedMaterial: uh,
          LineBasicMaterial: Nl,
          Material: br
        })
        const ph = {
          arraySlice: function (t, e, n) {
            return ph.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
          },
          convertArray: function (t, e, n) {
            return !t || (!n && t.constructor === e)
              ? t
              : 'number' == typeof e.BYTES_PER_ELEMENT
              ? new e(t)
              : Array.prototype.slice.call(t)
          },
          isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
          },
          getKeyframeOrder: function (t) {
            const e = t.length,
              n = new Array(e)
            for (let t = 0; t !== e; ++t) n[t] = t
            return (
              n.sort(function (e, n) {
                return t[e] - t[n]
              }),
              n
            )
          },
          sortedArray: function (t, e, n) {
            const i = t.length,
              r = new t.constructor(i)
            for (let s = 0, o = 0; o !== i; ++s) {
              const i = n[s] * e
              for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
            }
            return r
          },
          flattenJSON: function (t, e, n, i) {
            let r = 1,
              s = t[0]
            for (; void 0 !== s && void 0 === s[i]; ) s = t[r++]
            if (void 0 === s) return
            let o = s[i]
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  ;(o = s[i]), void 0 !== o && (e.push(s.time), n.push.apply(n, o)), (s = t[r++])
                } while (void 0 !== s)
              else if (void 0 !== o.toArray)
                do {
                  ;(o = s[i]), void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), (s = t[r++])
                } while (void 0 !== s)
              else
                do {
                  ;(o = s[i]), void 0 !== o && (e.push(s.time), n.push(o)), (s = t[r++])
                } while (void 0 !== s)
          },
          subclip: function (t, e, n, i, r = 30) {
            const s = t.clone()
            s.name = e
            const o = []
            for (let t = 0; t < s.tracks.length; ++t) {
              const e = s.tracks[t],
                a = e.getValueSize(),
                l = [],
                c = []
              for (let t = 0; t < e.times.length; ++t) {
                const s = e.times[t] * r
                if (!(s < n || s >= i)) {
                  l.push(e.times[t])
                  for (let n = 0; n < a; ++n) c.push(e.values[t * a + n])
                }
              }
              0 !== l.length &&
                ((e.times = ph.convertArray(l, e.times.constructor)),
                (e.values = ph.convertArray(c, e.values.constructor)),
                o.push(e))
            }
            s.tracks = o
            let a = 1 / 0
            for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0])
            for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a)
            return s.resetDuration(), s
          },
          makeClipAdditive: function (t, e = 0, n = t, i = 30) {
            i <= 0 && (i = 30)
            const r = n.tracks.length,
              s = e / i
            for (let e = 0; e < r; ++e) {
              const i = n.tracks[e],
                r = i.ValueTypeName
              if ('bool' === r || 'string' === r) continue
              const o = t.tracks.find(function (t) {
                return t.name === i.name && t.ValueTypeName === r
              })
              if (void 0 === o) continue
              let a = 0
              const l = i.getValueSize()
              i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3)
              let c = 0
              const h = o.getValueSize()
              o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3)
              const u = i.times.length - 1
              let d
              if (s <= i.times[0]) {
                const t = a,
                  e = l - a
                d = ph.arraySlice(i.values, t, e)
              } else if (s >= i.times[u]) {
                const t = u * l + a,
                  e = t + l - a
                d = ph.arraySlice(i.values, t, e)
              } else {
                const t = i.createInterpolant(),
                  e = a,
                  n = l - a
                t.evaluate(s), (d = ph.arraySlice(t.resultBuffer, e, n))
              }
              'quaternion' === r && new ti().fromArray(d).normalize().conjugate().toArray(d)
              const p = o.times.length
              for (let t = 0; t < p; ++t) {
                const e = t * h + c
                if ('quaternion' === r) ti.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e)
                else {
                  const t = h - 2 * c
                  for (let n = 0; n < t; ++n) o.values[e + n] -= d[n]
                }
              }
            }
            return (t.blendMode = Je), t
          }
        }
        function mh(t, e, n, i) {
          ;(this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n)
        }
        function fh(t, e, n, i) {
          mh.call(this, t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0)
        }
        function gh(t, e, n, i) {
          mh.call(this, t, e, n, i)
        }
        function vh(t, e, n, i) {
          mh.call(this, t, e, n, i)
        }
        Object.assign(mh.prototype, {
          evaluate: function (t) {
            const e = this.parameterPositions
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1]
            t: {
              e: {
                let s
                n: {
                  i: if (!(t < i)) {
                    for (let s = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i
                        return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, t, r)
                      }
                      if (n === s) break
                      if (((r = i), (i = e[++n]), t < i)) break e
                    }
                    s = e.length
                    break n
                  }
                  if (t >= r) break t
                  {
                    const o = e[1]
                    t < o && ((n = 2), (r = o))
                    for (let s = n - 2; ; ) {
                      if (void 0 === r) return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                      if (n === s) break
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e
                    }
                    ;(s = n), (n = 0)
                  }
                }
                for (; n < s; ) {
                  const i = (n + s) >>> 1
                  t < e[i] ? (s = i) : (n = i + 1)
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                if (void 0 === i) return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t)
              }
              ;(this._cachedIndex = n), this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
          },
          settings: null,
          DefaultSettings_: {},
          getSettings_: function () {
            return this.settings || this.DefaultSettings_
          },
          copySampleValue_: function (t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i
            for (let t = 0; t !== i; ++t) e[t] = n[r + t]
            return e
          },
          interpolate_: function () {
            throw new Error('call to abstract method')
          },
          intervalChanged_: function () {}
        }),
          Object.assign(mh.prototype, {
            beforeStart_: mh.prototype.copySampleValue_,
            afterEnd_: mh.prototype.copySampleValue_
          }),
          (fh.prototype = Object.assign(Object.create(mh.prototype), {
            constructor: fh,
            DefaultSettings_: { endingStart: qe, endingEnd: qe },
            intervalChanged_: function (t, e, n) {
              const i = this.parameterPositions
              let r = t - 2,
                s = t + 1,
                o = i[r],
                a = i[s]
              if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                  case Xe:
                    ;(r = t), (o = 2 * e - n)
                    break
                  case Ye:
                    ;(r = i.length - 2), (o = e + i[r] - i[r + 1])
                    break
                  default:
                    ;(r = t), (o = n)
                }
              if (void 0 === a)
                switch (this.getSettings_().endingEnd) {
                  case Xe:
                    ;(s = t), (a = 2 * n - e)
                    break
                  case Ye:
                    ;(s = 1), (a = n + i[1] - i[0])
                    break
                  default:
                    ;(s = t - 1), (a = e)
                }
              const l = 0.5 * (n - e),
                c = this.valueSize
              ;(this._weightPrev = l / (e - o)),
                (this._weightNext = l / (a - n)),
                (this._offsetPrev = r * c),
                (this._offsetNext = s * c)
            },
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                s = this.sampleValues,
                o = this.valueSize,
                a = t * o,
                l = a - o,
                c = this._offsetPrev,
                h = this._offsetNext,
                u = this._weightPrev,
                d = this._weightNext,
                p = (n - e) / (i - e),
                m = p * p,
                f = m * p,
                g = -u * f + 2 * u * m - u * p,
                v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
                y = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
                x = d * f - d * m
              for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[h + t]
              return r
            }
          })),
          (gh.prototype = Object.assign(Object.create(mh.prototype), {
            constructor: gh,
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                s = this.sampleValues,
                o = this.valueSize,
                a = t * o,
                l = a - o,
                c = (n - e) / (i - e),
                h = 1 - c
              for (let t = 0; t !== o; ++t) r[t] = s[l + t] * h + s[a + t] * c
              return r
            }
          })),
          (vh.prototype = Object.assign(Object.create(mh.prototype), {
            constructor: vh,
            interpolate_: function (t) {
              return this.copySampleValue_(t - 1)
            }
          }))
        class yh {
          constructor(t, e, n, i) {
            if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined')
            if (void 0 === e || 0 === e.length) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t)
            ;(this.name = t),
              (this.times = ph.convertArray(e, this.TimeBufferType)),
              (this.values = ph.convertArray(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation)
          }
          static toJSON(t) {
            const e = t.constructor
            let n
            if (e.toJSON !== this.toJSON) n = e.toJSON(t)
            else {
              n = { name: t.name, times: ph.convertArray(t.times, Array), values: ph.convertArray(t.values, Array) }
              const e = t.getInterpolation()
              e !== t.DefaultInterpolation && (n.interpolation = e)
            }
            return (n.type = t.ValueTypeName), n
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new vh(this.times, this.values, this.getValueSize(), t)
          }
          InterpolantFactoryMethodLinear(t) {
            return new gh(this.times, this.values, this.getValueSize(), t)
          }
          InterpolantFactoryMethodSmooth(t) {
            return new fh(this.times, this.values, this.getValueSize(), t)
          }
          setInterpolation(t) {
            let e
            switch (t) {
              case Ve:
                e = this.InterpolantFactoryMethodDiscrete
                break
              case We:
                e = this.InterpolantFactoryMethodLinear
                break
              case je:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
              const e = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e)
                this.setInterpolation(this.DefaultInterpolation)
              }
              return console.warn('THREE.KeyframeTrack:', e), this
            }
            return (this.createInterpolant = e), this
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Ve
              case this.InterpolantFactoryMethodLinear:
                return We
              case this.InterpolantFactoryMethodSmooth:
                return je
            }
          }
          getValueSize() {
            return this.values.length / this.times.length
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
            }
            return this
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
            }
            return this
          }
          trim(t, e) {
            const n = this.times,
              i = n.length
            let r = 0,
              s = i - 1
            for (; r !== i && n[r] < t; ) ++r
            for (; -1 !== s && n[s] > e; ) --s
            if ((++s, 0 !== r || s !== i)) {
              r >= s && ((s = Math.max(s, 1)), (r = s - 1))
              const t = this.getValueSize()
              ;(this.times = ph.arraySlice(n, r, s)), (this.values = ph.arraySlice(this.values, r * t, s * t))
            }
            return this
          }
          validate() {
            let t = !0
            const e = this.getValueSize()
            e - Math.floor(e) != 0 &&
              (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (t = !1))
            const n = this.times,
              i = this.values,
              r = n.length
            0 === r && (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1))
            let s = null
            for (let e = 0; e !== r; e++) {
              const i = n[e]
              if ('number' == typeof i && isNaN(i)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, e, i), (t = !1)
                break
              }
              if (null !== s && s > i) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, e, i, s), (t = !1)
                break
              }
              s = i
            }
            if (void 0 !== i && ph.isTypedArray(i))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e]
                if (isNaN(n)) {
                  console.error('THREE.KeyframeTrack: Value is not a valid number.', this, e, n), (t = !1)
                  break
                }
              }
            return t
          }
          optimize() {
            const t = ph.arraySlice(this.times),
              e = ph.arraySlice(this.values),
              n = this.getValueSize(),
              i = this.getInterpolation() === je,
              r = t.length - 1
            let s = 1
            for (let o = 1; o < r; ++o) {
              let r = !1
              const a = t[o]
              if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (i) r = !0
                else {
                  const t = o * n,
                    i = t - n,
                    s = t + n
                  for (let o = 0; o !== n; ++o) {
                    const n = e[t + o]
                    if (n !== e[i + o] || n !== e[s + o]) {
                      r = !0
                      break
                    }
                  }
                }
              if (r) {
                if (o !== s) {
                  t[s] = t[o]
                  const i = o * n,
                    r = s * n
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                }
                ++s
              }
            }
            if (r > 0) {
              t[s] = t[r]
              for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o]
              ++s
            }
            return (
              s !== t.length
                ? ((this.times = ph.arraySlice(t, 0, s)), (this.values = ph.arraySlice(e, 0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            )
          }
          clone() {
            const t = ph.arraySlice(this.times, 0),
              e = ph.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e)
            return (n.createInterpolant = this.createInterpolant), n
          }
        }
        ;(yh.prototype.TimeBufferType = Float32Array),
          (yh.prototype.ValueBufferType = Float32Array),
          (yh.prototype.DefaultInterpolation = We)
        class xh extends yh {}
        ;(xh.prototype.ValueTypeName = 'bool'),
          (xh.prototype.ValueBufferType = Array),
          (xh.prototype.DefaultInterpolation = Ve),
          (xh.prototype.InterpolantFactoryMethodLinear = void 0),
          (xh.prototype.InterpolantFactoryMethodSmooth = void 0)
        class bh extends yh {}
        bh.prototype.ValueTypeName = 'color'
        class wh extends yh {}
        function _h(t, e, n, i) {
          mh.call(this, t, e, n, i)
        }
        ;(wh.prototype.ValueTypeName = 'number'),
          (_h.prototype = Object.assign(Object.create(mh.prototype), {
            constructor: _h,
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                s = this.sampleValues,
                o = this.valueSize,
                a = (n - e) / (i - e)
              let l = t * o
              for (let t = l + o; l !== t; l += 4) ti.slerpFlat(r, 0, s, l - o, s, l, a)
              return r
            }
          }))
        class Mh extends yh {
          InterpolantFactoryMethodLinear(t) {
            return new _h(this.times, this.values, this.getValueSize(), t)
          }
        }
        ;(Mh.prototype.ValueTypeName = 'quaternion'),
          (Mh.prototype.DefaultInterpolation = We),
          (Mh.prototype.InterpolantFactoryMethodSmooth = void 0)
        class Th extends yh {}
        ;(Th.prototype.ValueTypeName = 'string'),
          (Th.prototype.ValueBufferType = Array),
          (Th.prototype.DefaultInterpolation = Ve),
          (Th.prototype.InterpolantFactoryMethodLinear = void 0),
          (Th.prototype.InterpolantFactoryMethodSmooth = void 0)
        class Sh extends yh {}
        Sh.prototype.ValueTypeName = 'vector'
        class Eh {
          constructor(t, e = -1, n, i = Ze) {
            ;(this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = Vn.generateUUID()),
              this.duration < 0 && this.resetDuration()
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1)
            for (let t = 0, r = n.length; t !== r; ++t) e.push(Ah(n[t]).scale(i))
            const r = new this(t.name, t.duration, e, t.blendMode)
            return (r.uuid = t.uuid), r
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }
            for (let t = 0, i = n.length; t !== i; ++t) e.push(yh.toJSON(n[t]))
            return i
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              s = []
            for (let t = 0; t < r; t++) {
              let o = [],
                a = []
              o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0)
              const l = ph.getKeyframeOrder(o)
              ;(o = ph.sortedArray(o, 1, l)),
                (a = ph.sortedArray(a, 1, l)),
                i || 0 !== o[0] || (o.push(r), a.push(a[0])),
                s.push(new wh('.morphTargetInfluences[' + e[t].name + ']', o, a).scale(1 / n))
            }
            return new this(t, -1, s)
          }
          static findByName(t, e) {
            let n = t
            if (!Array.isArray(t)) {
              const e = t
              n = (e.geometry && e.geometry.animations) || e.animations
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t]
            return null
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                s = n.name.match(r)
              if (s && s.length > 1) {
                const t = s[1]
                let e = i[t]
                e || (i[t] = e = []), e.push(n)
              }
            }
            const s = []
            for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n))
            return s
          }
          static parseAnimation(t, e) {
            if (!t) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const s = [],
                    o = []
                  ph.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                }
              },
              i = [],
              r = t.name || 'default',
              s = t.fps || 30,
              o = t.blendMode
            let a = t.length || -1
            const l = t.hierarchy || []
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {}
                  let e
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1
                  for (const n in t) {
                    const t = [],
                      s = []
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e]
                      t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                    }
                    i.push(new wh('.morphTargetInfluence[' + n + ']', t, s))
                  }
                  a = t.length * (s || 1)
                } else {
                  const s = '.bones[' + e[t].name + ']'
                  n(Sh, s + '.position', r, 'pos', i),
                    n(Mh, s + '.quaternion', r, 'rot', i),
                    n(Sh, s + '.scale', r, 'scl', i)
                }
            }
            return 0 === i.length ? null : new this(r, a, i, o)
          }
          resetDuration() {
            let t = 0
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e]
              t = Math.max(t, n.times[n.times.length - 1])
            }
            return (this.duration = t), this
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration)
            return this
          }
          validate() {
            let t = !0
            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate()
            return t
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
            return this
          }
          clone() {
            const t = []
            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone())
            return new this.constructor(this.name, this.duration, t, this.blendMode)
          }
          toJSON() {
            return this.constructor.toJSON(this)
          }
        }
        function Ah(t) {
          if (void 0 === t.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case 'scalar':
              case 'double':
              case 'float':
              case 'number':
              case 'integer':
                return wh
              case 'vector':
              case 'vector2':
              case 'vector3':
              case 'vector4':
                return Sh
              case 'color':
                return bh
              case 'quaternion':
                return Mh
              case 'bool':
              case 'boolean':
                return xh
              case 'string':
                return Th
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
          })(t.type)
          if (void 0 === t.times) {
            const e = [],
              n = []
            ph.flattenJSON(t.keys, e, n, 'value'), (t.times = e), (t.values = n)
          }
          return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const Lh = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e)
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t]
          },
          remove: function (t) {
            delete this.files[t]
          },
          clear: function () {
            this.files = {}
          }
        }
        function Rh(t, e, n) {
          const i = this
          let r,
            s = !1,
            o = 0,
            a = 0
          const l = []
          ;(this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (t) {
              a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), (s = !0)
            }),
            (this.itemEnd = function (t) {
              o++,
                void 0 !== i.onProgress && i.onProgress(t, o, a),
                o === a && ((s = !1), void 0 !== i.onLoad && i.onLoad())
            }),
            (this.itemError = function (t) {
              void 0 !== i.onError && i.onError(t)
            }),
            (this.resolveURL = function (t) {
              return r ? r(t) : t
            }),
            (this.setURLModifier = function (t) {
              return (r = t), this
            }),
            (this.addHandler = function (t, e) {
              return l.push(t, e), this
            }),
            (this.removeHandler = function (t) {
              const e = l.indexOf(t)
              return -1 !== e && l.splice(e, 2), this
            }),
            (this.getHandler = function (t) {
              for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e],
                  i = l[e + 1]
                if ((n.global && (n.lastIndex = 0), n.test(t))) return i
              }
              return null
            })
        }
        const Ph = new Rh()
        function Ch(t) {
          ;(this.manager = void 0 !== t ? t : Ph),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {})
        }
        Object.assign(Ch.prototype, {
          load: function () {},
          loadAsync: function (t, e) {
            const n = this
            return new Promise(function (i, r) {
              n.load(t, i, e, r)
            })
          },
          parse: function () {},
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this
          },
          setWithCredentials: function (t) {
            return (this.withCredentials = t), this
          },
          setPath: function (t) {
            return (this.path = t), this
          },
          setResourcePath: function (t) {
            return (this.resourcePath = t), this
          },
          setRequestHeader: function (t) {
            return (this.requestHeader = t), this
          }
        })
        const Ih = {}
        function Dh(t) {
          Ch.call(this, t)
        }
        Dh.prototype = Object.assign(Object.create(Ch.prototype), {
          constructor: Dh,
          load: function (t, e, n, i) {
            void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
            const r = this,
              s = Lh.get(t)
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t)
                }, 0),
                s
              )
            if (void 0 !== Ih[t]) return void Ih[t].push({ onLoad: e, onProgress: n, onError: i })
            const o = t.match(/^data:(.*?)(;base64)?,(.*)$/)
            let a
            if (o) {
              const n = o[1],
                s = !!o[2]
              let a = o[3]
              ;(a = decodeURIComponent(a)), s && (a = atob(a))
              try {
                let i
                const s = (this.responseType || '').toLowerCase()
                switch (s) {
                  case 'arraybuffer':
                  case 'blob':
                    const t = new Uint8Array(a.length)
                    for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e)
                    i = 'blob' === s ? new Blob([t.buffer], { type: n }) : t.buffer
                    break
                  case 'document':
                    const e = new DOMParser()
                    i = e.parseFromString(a, n)
                    break
                  case 'json':
                    i = JSON.parse(a)
                    break
                  default:
                    i = a
                }
                setTimeout(function () {
                  e && e(i), r.manager.itemEnd(t)
                }, 0)
              } catch (e) {
                setTimeout(function () {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }, 0)
              }
            } else {
              ;(Ih[t] = []),
                Ih[t].push({ onLoad: e, onProgress: n, onError: i }),
                (a = new XMLHttpRequest()),
                a.open('GET', t, !0),
                a.addEventListener(
                  'load',
                  function (e) {
                    const n = this.response,
                      i = Ih[t]
                    if ((delete Ih[t], 200 === this.status || 0 === this.status)) {
                      0 === this.status && console.warn('THREE.FileLoader: HTTP Status 0 received.'), Lh.add(t, n)
                      for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t]
                        e.onLoad && e.onLoad(n)
                      }
                      r.manager.itemEnd(t)
                    } else {
                      for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t]
                        n.onError && n.onError(e)
                      }
                      r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                  },
                  !1
                ),
                a.addEventListener(
                  'progress',
                  function (e) {
                    const n = Ih[t]
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t]
                      i.onProgress && i.onProgress(e)
                    }
                  },
                  !1
                ),
                a.addEventListener(
                  'error',
                  function (e) {
                    const n = Ih[t]
                    delete Ih[t]
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t]
                      i.onError && i.onError(e)
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t)
                  },
                  !1
                ),
                a.addEventListener(
                  'abort',
                  function (e) {
                    const n = Ih[t]
                    delete Ih[t]
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t]
                      i.onError && i.onError(e)
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t)
                  },
                  !1
                ),
                void 0 !== this.responseType && (a.responseType = this.responseType),
                void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials),
                a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain')
              for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t])
              a.send(null)
            }
            return r.manager.itemStart(t), a
          },
          setResponseType: function (t) {
            return (this.responseType = t), this
          },
          setMimeType: function (t) {
            return (this.mimeType = t), this
          }
        })
        class Oh extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = this,
              s = new Dh(this.manager)
            s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)))
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                  }
                },
                n,
                i
              )
          }
          parse(t) {
            const e = []
            for (let n = 0; n < t.length; n++) {
              const i = Eh.parse(t[n])
              e.push(i)
            }
            return e
          }
        }
        function Nh(t) {
          Ch.call(this, t)
        }
        Nh.prototype = Object.assign(Object.create(Ch.prototype), {
          constructor: Nh,
          load: function (t, e, n, i) {
            const r = this,
              s = [],
              o = new tc(),
              a = new Dh(this.manager)
            a.setPath(this.path),
              a.setResponseType('arraybuffer'),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(r.withCredentials)
            let l = 0
            function c(c) {
              a.load(
                t[c],
                function (t) {
                  const n = r.parse(t, !0)
                  ;(s[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }),
                    (l += 1),
                    6 === l &&
                      (1 === n.mipmapCount && (o.minFilter = Mt),
                      (o.image = s),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      e && e(o))
                },
                n,
                i
              )
            }
            if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) c(e)
            else
              a.load(
                t,
                function (t) {
                  const n = r.parse(t, !0)
                  if (n.isCubemap) {
                    const t = n.mipmaps.length / n.mipmapCount
                    for (let e = 0; e < t; e++) {
                      s[e] = { mipmaps: [] }
                      for (let t = 0; t < n.mipmapCount; t++)
                        s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                          (s[e].format = n.format),
                          (s[e].width = n.width),
                          (s[e].height = n.height)
                    }
                    o.image = s
                  } else (o.image.width = n.width), (o.image.height = n.height), (o.mipmaps = n.mipmaps)
                  1 === n.mipmapCount && (o.minFilter = Mt), (o.format = n.format), (o.needsUpdate = !0), e && e(o)
                },
                n,
                i
              )
            return o
          }
        })
        class Bh extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
            const r = this,
              s = Lh.get(t)
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t)
                }, 0),
                s
              )
            const o = document.createElementNS('http://www.w3.org/1999/xhtml', 'img')
            function a() {
              o.removeEventListener('load', a, !1),
                o.removeEventListener('error', l, !1),
                Lh.add(t, this),
                e && e(this),
                r.manager.itemEnd(t)
            }
            function l(e) {
              o.removeEventListener('load', a, !1),
                o.removeEventListener('error', l, !1),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            return (
              o.addEventListener('load', a, !1),
              o.addEventListener('error', l, !1),
              'data:' !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (o.src = t),
              o
            )
          }
        }
        class Fh extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = new As(),
              s = new Bh(this.manager)
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path)
            let o = 0
            function a(n) {
              s.load(
                t[n],
                function (t) {
                  ;(r.images[n] = t), o++, 6 === o && ((r.needsUpdate = !0), e && e(r))
                },
                void 0,
                i
              )
            }
            for (let e = 0; e < t.length; ++e) a(e)
            return r
          }
        }
        function zh(t) {
          Ch.call(this, t)
        }
        function kh(t) {
          Ch.call(this, t)
        }
        function Uh() {
          ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
        }
        ;(zh.prototype = Object.assign(Object.create(Ch.prototype), {
          constructor: zh,
          load: function (t, e, n, i) {
            const r = this,
              s = new Rs(),
              o = new Dh(this.manager)
            return (
              o.setResponseType('arraybuffer'),
              o.setRequestHeader(this.requestHeader),
              o.setPath(this.path),
              o.setWithCredentials(r.withCredentials),
              o.load(
                t,
                function (t) {
                  const n = r.parse(t)
                  n &&
                    (void 0 !== n.image
                      ? (s.image = n.image)
                      : void 0 !== n.data &&
                        ((s.image.width = n.width), (s.image.height = n.height), (s.image.data = n.data)),
                    (s.wrapS = void 0 !== n.wrapS ? n.wrapS : gt),
                    (s.wrapT = void 0 !== n.wrapT ? n.wrapT : gt),
                    (s.magFilter = void 0 !== n.magFilter ? n.magFilter : Mt),
                    (s.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt),
                    (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.encoding && (s.encoding = n.encoding),
                    void 0 !== n.flipY && (s.flipY = n.flipY),
                    void 0 !== n.format && (s.format = n.format),
                    void 0 !== n.type && (s.type = n.type),
                    void 0 !== n.mipmaps && ((s.mipmaps = n.mipmaps), (s.minFilter = Et)),
                    1 === n.mipmapCount && (s.minFilter = Mt),
                    void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                    (s.needsUpdate = !0),
                    e && e(s, n))
                },
                n,
                i
              ),
              s
            )
          }
        })),
          (kh.prototype = Object.assign(Object.create(Ch.prototype), {
            constructor: kh,
            load: function (t, e, n, i) {
              const r = new Zn(),
                s = new Bh(this.manager)
              return (
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(
                  t,
                  function (n) {
                    r.image = n
                    const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/)
                    ;(r.format = i ? Ht : Gt), (r.needsUpdate = !0), void 0 !== e && e(r)
                  },
                  n,
                  i
                ),
                r
              )
            }
          })),
          Object.assign(Uh.prototype, {
            getPoint: function () {
              return console.warn('THREE.Curve: .getPoint() not implemented.'), null
            },
            getPointAt: function (t, e) {
              const n = this.getUtoTmapping(t)
              return this.getPoint(n, e)
            },
            getPoints: function (t = 5) {
              const e = []
              for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
              return e
            },
            getSpacedPoints: function (t = 5) {
              const e = []
              for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t))
              return e
            },
            getLength: function () {
              const t = this.getLengths()
              return t[t.length - 1]
            },
            getLengths: function (t) {
              if (
                (void 0 === t && (t = this.arcLengthDivisions),
                this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
              )
                return this.cacheArcLengths
              this.needsUpdate = !1
              const e = []
              let n,
                i = this.getPoint(0),
                r = 0
              e.push(0)
              for (let s = 1; s <= t; s++) (n = this.getPoint(s / t)), (r += n.distanceTo(i)), e.push(r), (i = n)
              return (this.cacheArcLengths = e), e
            },
            updateArcLengths: function () {
              ;(this.needsUpdate = !0), this.getLengths()
            },
            getUtoTmapping: function (t, e) {
              const n = this.getLengths()
              let i = 0
              const r = n.length
              let s
              s = e || t * n[r - 1]
              let o,
                a = 0,
                l = r - 1
              for (; a <= l; )
                if (((i = Math.floor(a + (l - a) / 2)), (o = n[i] - s), o < 0)) a = i + 1
                else {
                  if (!(o > 0)) {
                    l = i
                    break
                  }
                  l = i - 1
                }
              if (((i = l), n[i] === s)) return i / (r - 1)
              const c = n[i]
              return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
            },
            getTangent: function (t, e) {
              const n = 1e-4
              let i = t - n,
                r = t + n
              i < 0 && (i = 0), r > 1 && (r = 1)
              const s = this.getPoint(i),
                o = this.getPoint(r),
                a = e || (s.isVector2 ? new Wn() : new ei())
              return a.copy(o).sub(s).normalize(), a
            },
            getTangentAt: function (t, e) {
              const n = this.getUtoTmapping(t)
              return this.getTangent(n, e)
            },
            computeFrenetFrames: function (t, e) {
              const n = new ei(),
                i = [],
                r = [],
                s = [],
                o = new ei(),
                a = new Ii()
              for (let e = 0; e <= t; e++) {
                const n = e / t
                ;(i[e] = this.getTangentAt(n, new ei())), i[e].normalize()
              }
              ;(r[0] = new ei()), (s[0] = new ei())
              let l = Number.MAX_VALUE
              const c = Math.abs(i[0].x),
                h = Math.abs(i[0].y),
                u = Math.abs(i[0].z)
              c <= l && ((l = c), n.set(1, 0, 0)),
                h <= l && ((l = h), n.set(0, 1, 0)),
                u <= l && n.set(0, 0, 1),
                o.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], o),
                s[0].crossVectors(i[0], r[0])
              for (let e = 1; e <= t; e++) {
                if (
                  ((r[e] = r[e - 1].clone()),
                  (s[e] = s[e - 1].clone()),
                  o.crossVectors(i[e - 1], i[e]),
                  o.length() > Number.EPSILON)
                ) {
                  o.normalize()
                  const t = Math.acos(Vn.clamp(i[e - 1].dot(i[e]), -1, 1))
                  r[e].applyMatrix4(a.makeRotationAxis(o, t))
                }
                s[e].crossVectors(i[e], r[e])
              }
              if (!0 === e) {
                let e = Math.acos(Vn.clamp(r[0].dot(r[t]), -1, 1))
                ;(e /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e)
                for (let n = 1; n <= t; n++)
                  r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
              }
              return { tangents: i, normals: r, binormals: s }
            },
            clone: function () {
              return new this.constructor().copy(this)
            },
            copy: function (t) {
              return (this.arcLengthDivisions = t.arcLengthDivisions), this
            },
            toJSON: function () {
              const t = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } }
              return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
            },
            fromJSON: function (t) {
              return (this.arcLengthDivisions = t.arcLengthDivisions), this
            }
          })
        class Hh extends Uh {
          constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) {
            super(),
              (this.type = 'EllipseCurve'),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = i),
              (this.aStartAngle = r),
              (this.aEndAngle = s),
              (this.aClockwise = o),
              (this.aRotation = a)
          }
          getPoint(t, e) {
            const n = e || new Wn(),
              i = 2 * Math.PI
            let r = this.aEndAngle - this.aStartAngle
            const s = Math.abs(r) < Number.EPSILON
            for (; r < 0; ) r += i
            for (; r > i; ) r -= i
            r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i))
            const o = this.aStartAngle + t * r
            let a = this.aX + this.xRadius * Math.cos(o),
              l = this.aY + this.yRadius * Math.sin(o)
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = a - this.aX,
                i = l - this.aY
              ;(a = n * t - i * e + this.aX), (l = n * e + i * t + this.aY)
            }
            return n.set(a, l)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            )
          }
          toJSON() {
            const t = super.toJSON()
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            )
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            )
          }
        }
        Hh.prototype.isEllipseCurve = !0
        class Gh extends Hh {
          constructor(t, e, n, i, r, s) {
            super(t, e, n, n, i, r, s), (this.type = 'ArcCurve')
          }
        }
        function Vh() {
          let t = 0,
            e = 0,
            n = 0,
            i = 0
          function r(r, s, o, a) {
            ;(t = r), (e = o), (n = -3 * r + 3 * s - 2 * o - a), (i = 2 * r - 2 * s + o + a)
          }
          return {
            initCatmullRom: function (t, e, n, i, s) {
              r(e, n, s * (n - t), s * (i - e))
            },
            initNonuniformCatmullRom: function (t, e, n, i, s, o, a) {
              let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                c = (n - e) / o - (i - e) / (o + a) + (i - n) / a
              ;(l *= o), (c *= o), r(e, n, l, c)
            },
            calc: function (r) {
              const s = r * r
              return t + e * r + n * s + i * (s * r)
            }
          }
        }
        Gh.prototype.isArcCurve = !0
        const Wh = new ei(),
          jh = new Vh(),
          qh = new Vh(),
          Xh = new Vh()
        class Yh extends Uh {
          constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
            super(),
              (this.type = 'CatmullRomCurve3'),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = i)
          }
          getPoint(t, e = new ei()) {
            const n = e,
              i = this.points,
              r = i.length,
              s = (r - (this.closed ? 0 : 1)) * t
            let o,
              a,
              l = Math.floor(s),
              c = s - l
            this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
              : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
              this.closed || l > 0 ? (o = i[(l - 1) % r]) : (Wh.subVectors(i[0], i[1]).add(i[0]), (o = Wh))
            const h = i[l % r],
              u = i[(l + 1) % r]
            if (
              (this.closed || l + 2 < r
                ? (a = i[(l + 2) % r])
                : (Wh.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = Wh)),
              'centripetal' === this.curveType || 'chordal' === this.curveType)
            ) {
              const t = 'chordal' === this.curveType ? 0.5 : 0.25
              let e = Math.pow(o.distanceToSquared(h), t),
                n = Math.pow(h.distanceToSquared(u), t),
                i = Math.pow(u.distanceToSquared(a), t)
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                i < 1e-4 && (i = n),
                jh.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i),
                qh.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i),
                Xh.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
            } else
              'catmullrom' === this.curveType &&
                (jh.initCatmullRom(o.x, h.x, u.x, a.x, this.tension),
                qh.initCatmullRom(o.y, h.y, u.y, a.y, this.tension),
                Xh.initCatmullRom(o.z, h.z, u.z, a.z, this.tension))
            return n.set(jh.calc(c), qh.calc(c), Xh.calc(c)), n
          }
          copy(t) {
            super.copy(t), (this.points = [])
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e]
              this.points.push(n.clone())
            }
            return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
          }
          toJSON() {
            const t = super.toJSON()
            t.points = []
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e]
              t.points.push(n.toArray())
            }
            return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = [])
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e]
              this.points.push(new ei().fromArray(n))
            }
            return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
          }
        }
        function Zh(t, e, n, i, r) {
          const s = 0.5 * (i - e),
            o = 0.5 * (r - n),
            a = t * t
          return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
        }
        function Jh(t, e, n, i) {
          return (
            (function (t, e) {
              const n = 1 - t
              return n * n * e
            })(t, e) +
            (function (t, e) {
              return 2 * (1 - t) * t * e
            })(t, n) +
            (function (t, e) {
              return t * t * e
            })(t, i)
          )
        }
        function Kh(t, e, n, i, r) {
          return (
            (function (t, e) {
              const n = 1 - t
              return n * n * n * e
            })(t, e) +
            (function (t, e) {
              const n = 1 - t
              return 3 * n * n * t * e
            })(t, n) +
            (function (t, e) {
              return 3 * (1 - t) * t * t * e
            })(t, i) +
            (function (t, e) {
              return t * t * t * e
            })(t, r)
          )
        }
        Yh.prototype.isCatmullRomCurve3 = !0
        class Qh extends Uh {
          constructor(t = new Wn(), e = new Wn(), n = new Wn(), i = new Wn()) {
            super(), (this.type = 'CubicBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = n), (this.v3 = i)
          }
          getPoint(t, e = new Wn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              o = this.v3
            return n.set(Kh(t, i.x, r.x, s.x, o.x), Kh(t, i.y, r.y, s.y, o.y)), n
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
          }
          toJSON() {
            const t = super.toJSON()
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            )
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            )
          }
        }
        Qh.prototype.isCubicBezierCurve = !0
        class $h extends Uh {
          constructor(t = new ei(), e = new ei(), n = new ei(), i = new ei()) {
            super(), (this.type = 'CubicBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = n), (this.v3 = i)
          }
          getPoint(t, e = new ei()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              o = this.v3
            return n.set(Kh(t, i.x, r.x, s.x, o.x), Kh(t, i.y, r.y, s.y, o.y), Kh(t, i.z, r.z, s.z, o.z)), n
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
          }
          toJSON() {
            const t = super.toJSON()
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            )
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            )
          }
        }
        $h.prototype.isCubicBezierCurve3 = !0
        class tu extends Uh {
          constructor(t = new Wn(), e = new Wn()) {
            super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e)
          }
          getPoint(t, e = new Wn()) {
            const n = e
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
          }
          getPointAt(t, e) {
            return this.getPoint(t, e)
          }
          getTangent(t, e) {
            const n = e || new Wn()
            return n.copy(this.v2).sub(this.v1).normalize(), n
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
          }
        }
        tu.prototype.isLineCurve = !0
        class eu extends Uh {
          constructor(t = new ei(), e = new ei()) {
            super(), (this.type = 'LineCurve3'), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e)
          }
          getPoint(t, e = new ei()) {
            const n = e
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
          }
          getPointAt(t, e) {
            return this.getPoint(t, e)
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
          }
        }
        class nu extends Uh {
          constructor(t = new Wn(), e = new Wn(), n = new Wn()) {
            super(), (this.type = 'QuadraticBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = n)
          }
          getPoint(t, e = new Wn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2
            return n.set(Jh(t, i.x, r.x, s.x), Jh(t, i.y, r.y, s.y)), n
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
          }
        }
        nu.prototype.isQuadraticBezierCurve = !0
        class iu extends Uh {
          constructor(t = new ei(), e = new ei(), n = new ei()) {
            super(), (this.type = 'QuadraticBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = n)
          }
          getPoint(t, e = new ei()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2
            return n.set(Jh(t, i.x, r.x, s.x), Jh(t, i.y, r.y, s.y), Jh(t, i.z, r.z, s.z)), n
          }
          copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
          }
        }
        iu.prototype.isQuadraticBezierCurve3 = !0
        class ru extends Uh {
          constructor(t = []) {
            super(), (this.type = 'SplineCurve'), (this.points = t)
          }
          getPoint(t, e = new Wn()) {
            const n = e,
              i = this.points,
              r = (i.length - 1) * t,
              s = Math.floor(r),
              o = r - s,
              a = i[0 === s ? s : s - 1],
              l = i[s],
              c = i[s > i.length - 2 ? i.length - 1 : s + 1],
              h = i[s > i.length - 3 ? i.length - 1 : s + 2]
            return n.set(Zh(o, a.x, l.x, c.x, h.x), Zh(o, a.y, l.y, c.y, h.y)), n
          }
          copy(t) {
            super.copy(t), (this.points = [])
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e]
              this.points.push(n.clone())
            }
            return this
          }
          toJSON() {
            const t = super.toJSON()
            t.points = []
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e]
              t.points.push(n.toArray())
            }
            return t
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = [])
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e]
              this.points.push(new Wn().fromArray(n))
            }
            return this
          }
        }
        ru.prototype.isSplineCurve = !0
        var su = Object.freeze({
          __proto__: null,
          ArcCurve: Gh,
          CatmullRomCurve3: Yh,
          CubicBezierCurve: Qh,
          CubicBezierCurve3: $h,
          EllipseCurve: Hh,
          LineCurve: tu,
          LineCurve3: eu,
          QuadraticBezierCurve: nu,
          QuadraticBezierCurve3: iu,
          SplineCurve: ru
        })
        class ou extends Uh {
          constructor() {
            super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1)
          }
          add(t) {
            this.curves.push(t)
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1)
            t.equals(e) || this.curves.push(new tu(e, t))
          }
          getPoint(t) {
            const e = t * this.getLength(),
              n = this.getCurveLengths()
            let i = 0
            for (; i < n.length; ) {
              if (n[i] >= e) {
                const t = n[i] - e,
                  r = this.curves[i],
                  s = r.getLength(),
                  o = 0 === s ? 0 : 1 - t / s
                return r.getPointAt(o)
              }
              i++
            }
            return null
          }
          getLength() {
            const t = this.getCurveLengths()
            return t[t.length - 1]
          }
          updateArcLengths() {
            ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
          }
          getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths
            const t = []
            let e = 0
            for (let n = 0, i = this.curves.length; n < i; n++) (e += this.curves[n].getLength()), t.push(e)
            return (this.cacheLengths = t), t
          }
          getSpacedPoints(t = 40) {
            const e = []
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
            return this.autoClose && e.push(e[0]), e
          }
          getPoints(t = 12) {
            const e = []
            let n
            for (let i = 0, r = this.curves; i < r.length; i++) {
              const s = r[i],
                o =
                  s && s.isEllipseCurve
                    ? 2 * t
                    : s && (s.isLineCurve || s.isLineCurve3)
                    ? 1
                    : s && s.isSplineCurve
                    ? t * s.points.length
                    : t,
                a = s.getPoints(o)
              for (let t = 0; t < a.length; t++) {
                const i = a[t]
                ;(n && n.equals(i)) || (e.push(i), (n = i))
              }
            }
            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
          }
          copy(t) {
            super.copy(t), (this.curves = [])
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e]
              this.curves.push(n.clone())
            }
            return (this.autoClose = t.autoClose), this
          }
          toJSON() {
            const t = super.toJSON()
            ;(t.autoClose = this.autoClose), (t.curves = [])
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e]
              t.curves.push(n.toJSON())
            }
            return t
          }
          fromJSON(t) {
            super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e]
              this.curves.push(new su[n.type]().fromJSON(n))
            }
            return this
          }
        }
        class au extends ou {
          constructor(t) {
            super(), (this.type = 'Path'), (this.currentPoint = new Wn()), t && this.setFromPoints(t)
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y)
            for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
            return this
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this
          }
          lineTo(t, e) {
            const n = new tu(this.currentPoint.clone(), new Wn(t, e))
            return this.curves.push(n), this.currentPoint.set(t, e), this
          }
          quadraticCurveTo(t, e, n, i) {
            const r = new nu(this.currentPoint.clone(), new Wn(t, e), new Wn(n, i))
            return this.curves.push(r), this.currentPoint.set(n, i), this
          }
          bezierCurveTo(t, e, n, i, r, s) {
            const o = new Qh(this.currentPoint.clone(), new Wn(t, e), new Wn(n, i), new Wn(r, s))
            return this.curves.push(o), this.currentPoint.set(r, s), this
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new ru(e)
            return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
          }
          arc(t, e, n, i, r, s) {
            const o = this.currentPoint.x,
              a = this.currentPoint.y
            return this.absarc(t + o, e + a, n, i, r, s), this
          }
          absarc(t, e, n, i, r, s) {
            return this.absellipse(t, e, n, n, i, r, s), this
          }
          ellipse(t, e, n, i, r, s, o, a) {
            const l = this.currentPoint.x,
              c = this.currentPoint.y
            return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
          }
          absellipse(t, e, n, i, r, s, o, a) {
            const l = new Hh(t, e, n, i, r, s, o, a)
            if (this.curves.length > 0) {
              const t = l.getPoint(0)
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
            }
            this.curves.push(l)
            const c = l.getPoint(1)
            return this.currentPoint.copy(c), this
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.currentPoint = this.currentPoint.toArray()), t
          }
          fromJSON(t) {
            return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          }
        }
        class lu extends au {
          constructor(t) {
            super(t), (this.uuid = Vn.generateUUID()), (this.type = 'Shape'), (this.holes = [])
          }
          getPointsHoles(t) {
            const e = []
            for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t)
            return e
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
          }
          copy(t) {
            super.copy(t), (this.holes = [])
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e]
              this.holes.push(n.clone())
            }
            return this
          }
          toJSON() {
            const t = super.toJSON()
            ;(t.uuid = this.uuid), (t.holes = [])
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e]
              t.holes.push(n.toJSON())
            }
            return t
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e]
              this.holes.push(new au().fromJSON(n))
            }
            return this
          }
        }
        class cu extends ir {
          constructor(t, e = 1) {
            super(), (this.type = 'Light'), (this.color = new Ar(t)), (this.intensity = e)
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
              e
            )
          }
        }
        cu.prototype.isLight = !0
        class hu extends cu {
          constructor(t, e, n) {
            super(t, n),
              (this.type = 'HemisphereLight'),
              this.position.copy(ir.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new Ar(e))
          }
          copy(t) {
            return cu.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
          }
        }
        hu.prototype.isHemisphereLight = !0
        const uu = new Ii(),
          du = new ei(),
          pu = new ei()
        class mu {
          constructor(t) {
            ;(this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.mapSize = new Wn(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Ii()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new Is()),
              (this._frameExtents = new Wn(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new Kn(0, 0, 1, 1)])
          }
          getViewportCount() {
            return this._viewportCount
          }
          getFrustum() {
            return this._frustum
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix
            du.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(du),
              pu.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(pu),
              e.updateMatrixWorld(),
              uu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(uu),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(e.projectionMatrix),
              n.multiply(e.matrixWorldInverse)
          }
          getViewport(t) {
            return this._viewports[t]
          }
          getFrameExtents() {
            return this._frameExtents
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            )
          }
          clone() {
            return new this.constructor().copy(this)
          }
          toJSON() {
            const t = {}
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            )
          }
        }
        class fu extends mu {
          constructor() {
            super(new Ts(50, 1, 0.5, 500)), (this.focus = 1)
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * Vn.RAD2DEG * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far
            ;(n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
              super.updateMatrices(t)
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this
          }
        }
        fu.prototype.isSpotLightShadow = !0
        class gu extends cu {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
            super(t, e),
              (this.type = 'SpotLight'),
              this.position.copy(ir.DefaultUp),
              this.updateMatrix(),
              (this.target = new ir()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = s),
              (this.shadow = new fu())
          }
          get power() {
            return this.intensity * Math.PI
          }
          set power(t) {
            this.intensity = t / Math.PI
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            )
          }
        }
        gu.prototype.isSpotLight = !0
        const vu = new Ii(),
          yu = new ei(),
          xu = new ei()
        class bu extends mu {
          constructor() {
            super(new Ts(90, 1, 0.5, 500)),
              (this._frameExtents = new Wn(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new Kn(2, 1, 1, 1),
                new Kn(0, 1, 1, 1),
                new Kn(3, 1, 1, 1),
                new Kn(1, 1, 1, 1),
                new Kn(3, 0, 1, 1),
                new Kn(1, 0, 1, 1)
              ]),
              (this._cubeDirections = [
                new ei(1, 0, 0),
                new ei(-1, 0, 0),
                new ei(0, 0, 1),
                new ei(0, 0, -1),
                new ei(0, 1, 0),
                new ei(0, -1, 0)
              ]),
              (this._cubeUps = [
                new ei(0, 1, 0),
                new ei(0, 1, 0),
                new ei(0, 1, 0),
                new ei(0, 1, 0),
                new ei(0, 0, 1),
                new ei(0, 0, -1)
              ])
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              yu.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(yu),
              xu.copy(n.position),
              xu.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(xu),
              n.updateMatrixWorld(),
              i.makeTranslation(-yu.x, -yu.y, -yu.z),
              vu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(vu)
          }
        }
        bu.prototype.isPointLightShadow = !0
        class wu extends cu {
          constructor(t, e, n = 0, i = 1) {
            super(t, e), (this.type = 'PointLight'), (this.distance = n), (this.decay = i), (this.shadow = new bu())
          }
          get power() {
            return 4 * this.intensity * Math.PI
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI)
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            )
          }
        }
        wu.prototype.isPointLight = !0
        class _u extends Ms {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
            super(),
              (this.type = 'OrthographicCamera'),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = s),
              this.updateProjectionMatrix()
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            )
          }
          setViewOffset(t, e, n, i, r, s) {
            null === this.view &&
              (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix()
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2
            let r = n - t,
              s = n + t,
              o = i + e,
              a = i - e
            if (null !== this.view && this.view.enabled) {
              const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom
              ;(r += t * this.view.offsetX),
                (s = r + t * this.view.width),
                (o -= e * this.view.offsetY),
                (a = o - e * this.view.height)
            }
            this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
          }
          toJSON(t) {
            const e = ir.prototype.toJSON.call(this, t)
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view && (e.object.view = Object.assign({}, this.view)),
              e
            )
          }
        }
        _u.prototype.isOrthographicCamera = !0
        class Mu extends mu {
          constructor() {
            super(new _u(-5, 5, 5, -5, 0.5, 500))
          }
        }
        Mu.prototype.isDirectionalLightShadow = !0
        class Tu extends cu {
          constructor(t, e) {
            super(t, e),
              (this.type = 'DirectionalLight'),
              this.position.copy(ir.DefaultUp),
              this.updateMatrix(),
              (this.target = new ir()),
              (this.shadow = new Mu())
          }
          copy(t) {
            return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this
          }
        }
        Tu.prototype.isDirectionalLight = !0
        class Su extends cu {
          constructor(t, e) {
            super(t, e), (this.type = 'AmbientLight')
          }
        }
        Su.prototype.isAmbientLight = !0
        class Eu extends cu {
          constructor(t, e, n = 10, i = 10) {
            super(t, e), (this.type = 'RectAreaLight'), (this.width = n), (this.height = i)
          }
          copy(t) {
            return super.copy(t), (this.width = t.width), (this.height = t.height), this
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (e.object.width = this.width), (e.object.height = this.height), e
          }
        }
        Eu.prototype.isRectAreaLight = !0
        class Au {
          constructor() {
            this.coefficients = []
            for (let t = 0; t < 9; t++) this.coefficients.push(new ei())
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
            return this
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0)
            return this
          }
          getAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients
            return (
              e.copy(s[0]).multiplyScalar(0.282095),
              e.addScaledVector(s[1], 0.488603 * i),
              e.addScaledVector(s[2], 0.488603 * r),
              e.addScaledVector(s[3], 0.488603 * n),
              e.addScaledVector(s[4], n * i * 1.092548),
              e.addScaledVector(s[5], i * r * 1.092548),
              e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
              e.addScaledVector(s[7], n * r * 1.092548),
              e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
              e
            )
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients
            return (
              e.copy(s[0]).multiplyScalar(0.886227),
              e.addScaledVector(s[1], 1.023328 * i),
              e.addScaledVector(s[2], 1.023328 * r),
              e.addScaledVector(s[3], 1.023328 * n),
              e.addScaledVector(s[4], 0.858086 * n * i),
              e.addScaledVector(s[5], 0.858086 * i * r),
              e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
              e.addScaledVector(s[7], 0.858086 * n * r),
              e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
              e
            )
          }
          add(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e])
            return this
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e)
            return this
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t)
            return this
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e)
            return this
          }
          equals(t) {
            for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1
            return !0
          }
          copy(t) {
            return this.set(t.coefficients)
          }
          clone() {
            return new this.constructor().copy(this)
          }
          fromArray(t, e = 0) {
            const n = this.coefficients
            for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i)
            return this
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients
            for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i)
            return t
          }
          static getBasisAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z
            ;(e[0] = 0.282095),
              (e[1] = 0.488603 * i),
              (e[2] = 0.488603 * r),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * i),
              (e[5] = 1.092548 * i * r),
              (e[6] = 0.315392 * (3 * r * r - 1)),
              (e[7] = 1.092548 * n * r),
              (e[8] = 0.546274 * (n * n - i * i))
          }
        }
        Au.prototype.isSphericalHarmonics3 = !0
        class Lu extends cu {
          constructor(t = new Au(), e = 1) {
            super(void 0, e), (this.sh = t)
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this
          }
          fromJSON(t) {
            return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
          }
          toJSON(t) {
            const e = super.toJSON(t)
            return (e.object.sh = this.sh.toArray()), e
          }
        }
        Lu.prototype.isLightProbe = !0
        class Ru extends Ch {
          constructor(t) {
            super(t), (this.textures = {})
          }
          load(t, e, n, i) {
            const r = this,
              s = new Dh(r.manager)
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)))
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                  }
                },
                n,
                i
              )
          }
          parse(t) {
            const e = this.textures
            function n(t) {
              return void 0 === e[t] && console.warn('THREE.MaterialLoader: Undefined texture', t), e[t]
            }
            const i = new dh[t.type]()
            if (
              (void 0 !== t.uuid && (i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
              void 0 !== t.roughness && (i.roughness = t.roughness),
              void 0 !== t.metalness && (i.metalness = t.metalness),
              void 0 !== t.sheen && (i.sheen = new Ar().setHex(t.sheen)),
              void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive),
              void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular),
              void 0 !== t.shininess && (i.shininess = t.shininess),
              void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
              void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness),
              void 0 !== t.fog && (i.fog = t.fog),
              void 0 !== t.flatShading && (i.flatShading = t.flatShading),
              void 0 !== t.blending && (i.blending = t.blending),
              void 0 !== t.combine && (i.combine = t.combine),
              void 0 !== t.side && (i.side = t.side),
              void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
              void 0 !== t.opacity && (i.opacity = t.opacity),
              void 0 !== t.transparent && (i.transparent = t.transparent),
              void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
              void 0 !== t.depthTest && (i.depthTest = t.depthTest),
              void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
              void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
              void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
              void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask),
              void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
              void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
              void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
              void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
              void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
              void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
              void 0 !== t.wireframe && (i.wireframe = t.wireframe),
              void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth),
              void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap),
              void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin),
              void 0 !== t.rotation && (i.rotation = t.rotation),
              1 !== t.linewidth && (i.linewidth = t.linewidth),
              void 0 !== t.dashSize && (i.dashSize = t.dashSize),
              void 0 !== t.gapSize && (i.gapSize = t.gapSize),
              void 0 !== t.scale && (i.scale = t.scale),
              void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
              void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor),
              void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits),
              void 0 !== t.skinning && (i.skinning = t.skinning),
              void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
              void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
              void 0 !== t.dithering && (i.dithering = t.dithering),
              void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage),
              void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha),
              void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.vertexColors &&
                ('number' == typeof t.vertexColors
                  ? (i.vertexColors = t.vertexColors > 0)
                  : (i.vertexColors = t.vertexColors)),
              void 0 !== t.uniforms)
            )
              for (const e in t.uniforms) {
                const r = t.uniforms[e]
                switch (((i.uniforms[e] = {}), r.type)) {
                  case 't':
                    i.uniforms[e].value = n(r.value)
                    break
                  case 'c':
                    i.uniforms[e].value = new Ar().setHex(r.value)
                    break
                  case 'v2':
                    i.uniforms[e].value = new Wn().fromArray(r.value)
                    break
                  case 'v3':
                    i.uniforms[e].value = new ei().fromArray(r.value)
                    break
                  case 'v4':
                    i.uniforms[e].value = new Kn().fromArray(r.value)
                    break
                  case 'm3':
                    i.uniforms[e].value = new jn().fromArray(r.value)
                    break
                  case 'm4':
                    i.uniforms[e].value = new Ii().fromArray(r.value)
                    break
                  default:
                    i.uniforms[e].value = r.value
                }
              }
            if (
              (void 0 !== t.defines && (i.defines = t.defines),
              void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
              void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
              void 0 !== t.extensions)
            )
              for (const e in t.extensions) i.extensions[e] = t.extensions[e]
            if (
              (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
              void 0 !== t.size && (i.size = t.size),
              void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
              void 0 !== t.map && (i.map = n(t.map)),
              void 0 !== t.matcap && (i.matcap = n(t.matcap)),
              void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
              void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
              void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
              void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
              void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
              void 0 !== t.normalScale)
            ) {
              let e = t.normalScale
              !1 === Array.isArray(e) && (e = [e, e]), (i.normalScale = new Wn().fromArray(e))
            }
            return (
              void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
              void 0 !== t.envMap && (i.envMap = n(t.envMap)),
              void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
              void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
              void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
              void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
              void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
              void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
              void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
              void 0 !== t.clearcoatNormalScale &&
                (i.clearcoatNormalScale = new Wn().fromArray(t.clearcoatNormalScale)),
              void 0 !== t.transmission && (i.transmission = t.transmission),
              void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)),
              i
            )
          }
          setTextures(t) {
            return (this.textures = t), this
          }
        }
        const Pu = {
          decodeText: function (t) {
            if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t)
            let e = ''
            for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n])
            try {
              return decodeURIComponent(escape(e))
            } catch (t) {
              return e
            }
          },
          extractUrlBase: function (t) {
            const e = t.lastIndexOf('/')
            return -1 === e ? './' : t.substr(0, e + 1)
          }
        }
        function Cu() {
          Qr.call(this), (this.type = 'InstancedBufferGeometry'), (this.instanceCount = 1 / 0)
        }
        function Iu(t, e, n, i) {
          'number' == typeof n &&
            ((i = n),
            (n = !1),
            console.error(
              'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.'
            )),
            Cr.call(this, t, e, n),
            (this.meshPerAttribute = i || 1)
        }
        ;(Cu.prototype = Object.assign(Object.create(Qr.prototype), {
          constructor: Cu,
          isInstancedBufferGeometry: !0,
          copy: function (t) {
            return Qr.prototype.copy.call(this, t), (this.instanceCount = t.instanceCount), this
          },
          clone: function () {
            return new this.constructor().copy(this)
          },
          toJSON: function () {
            const t = Qr.prototype.toJSON.call(this)
            return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t
          }
        })),
          (Iu.prototype = Object.assign(Object.create(Cr.prototype), {
            constructor: Iu,
            isInstancedBufferAttribute: !0,
            copy: function (t) {
              return Cr.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this
            },
            toJSON: function () {
              const t = Cr.prototype.toJSON.call(this)
              return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
            }
          }))
        class Du extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = this,
              s = new Dh(r.manager)
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)))
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                  }
                },
                n,
                i
              )
          }
          parse(t) {
            const e = {},
              n = {}
            function i(t, i) {
              if (void 0 !== e[i]) return e[i]
              const r = t.interleavedBuffers[i],
                s = (function (t, e) {
                  if (void 0 !== n[e]) return n[e]
                  const i = t.arrayBuffers[e],
                    r = new Uint32Array(i).buffer
                  return (n[e] = r), r
                })(t, r.buffer),
                o = new Qa(Wr(r.type, s), r.stride)
              return (o.uuid = r.uuid), (e[i] = o), o
            }
            const r = t.isInstancedBufferGeometry ? new Cu() : new Qr(),
              s = t.data.index
            if (void 0 !== s) {
              const t = Wr(s.type, s.array)
              r.setIndex(new Cr(t, 1))
            }
            const o = t.data.attributes
            for (const e in o) {
              const n = o[e]
              let s
              if (n.isInterleavedBufferAttribute) s = new tl(i(t.data, n.data), n.itemSize, n.offset, n.normalized)
              else {
                const t = Wr(n.type, n.array)
                s = new (n.isInstancedBufferAttribute ? Iu : Cr)(t, n.itemSize, n.normalized)
              }
              void 0 !== n.name && (s.name = n.name),
                void 0 !== n.usage && s.setUsage(n.usage),
                void 0 !== n.updateRange &&
                  ((s.updateRange.offset = n.updateRange.offset), (s.updateRange.count = n.updateRange.count)),
                r.setAttribute(e, s)
            }
            const a = t.data.morphAttributes
            if (a)
              for (const e in a) {
                const n = a[e],
                  s = []
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e]
                  let o
                  ;(o = r.isInterleavedBufferAttribute
                    ? new tl(i(t.data, r.data), r.itemSize, r.offset, r.normalized)
                    : new Cr(Wr(r.type, r.array), r.itemSize, r.normalized)),
                    void 0 !== r.name && (o.name = r.name),
                    s.push(o)
                }
                r.morphAttributes[e] = s
              }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0)
            const l = t.data.groups || t.data.drawcalls || t.data.offsets
            if (void 0 !== l)
              for (let t = 0, e = l.length; t !== e; ++t) {
                const e = l[t]
                r.addGroup(e.start, e.count, e.materialIndex)
              }
            const c = t.data.boundingSphere
            if (void 0 !== c) {
              const t = new ei()
              void 0 !== c.center && t.fromArray(c.center), (r.boundingSphere = new Mi(t, c.radius))
            }
            return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
          }
        }
        class Ou extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = this,
              s = '' === this.path ? Pu.extractUrlBase(t) : this.path
            this.resourcePath = this.resourcePath || s
            const o = new Dh(this.manager)
            o.setPath(this.path),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(this.withCredentials),
              o.load(
                t,
                function (n) {
                  let s = null
                  try {
                    s = JSON.parse(n)
                  } catch (e) {
                    return (
                      void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + '.', e.message)
                    )
                  }
                  const o = s.metadata
                  void 0 !== o && void 0 !== o.type && 'geometry' !== o.type.toLowerCase()
                    ? r.parse(s, e)
                    : console.error("THREE.ObjectLoader: Can't load " + t)
                },
                n,
                i
              )
          }
          parse(t, e) {
            const n = this.parseAnimations(t.animations),
              i = this.parseShapes(t.shapes),
              r = this.parseGeometries(t.geometries, i),
              s = this.parseImages(t.images, function () {
                void 0 !== e && e(l)
              }),
              o = this.parseTextures(t.textures, s),
              a = this.parseMaterials(t.materials, o),
              l = this.parseObject(t.object, r, a, n),
              c = this.parseSkeletons(t.skeletons, l)
            if ((this.bindSkeletons(l, c), void 0 !== e)) {
              let t = !1
              for (const e in s)
                if (s[e] instanceof HTMLImageElement) {
                  t = !0
                  break
                }
              !1 === t && e(l)
            }
            return l
          }
          parseShapes(t) {
            const e = {}
            if (void 0 !== t)
              for (let n = 0, i = t.length; n < i; n++) {
                const i = new lu().fromJSON(t[n])
                e[i.uuid] = i
              }
            return e
          }
          parseSkeletons(t, e) {
            const n = {},
              i = {}
            if (
              (e.traverse(function (t) {
                t.isBone && (i[t.uuid] = t)
              }),
              void 0 !== t)
            )
              for (let e = 0, r = t.length; e < r; e++) {
                const r = new Rl().fromJSON(t[e], i)
                n[r.uuid] = r
              }
            return n
          }
          parseGeometries(t, e) {
            const n = {}
            let i
            if (void 0 !== t) {
              const r = new Du()
              for (let s = 0, o = t.length; s < o; s++) {
                let o
                const a = t[s]
                switch (a.type) {
                  case 'PlaneGeometry':
                  case 'PlaneBufferGeometry':
                    o = new eh[a.type](a.width, a.height, a.widthSegments, a.heightSegments)
                    break
                  case 'BoxGeometry':
                  case 'BoxBufferGeometry':
                    o = new eh[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments)
                    break
                  case 'CircleGeometry':
                  case 'CircleBufferGeometry':
                    o = new eh[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength)
                    break
                  case 'CylinderGeometry':
                  case 'CylinderBufferGeometry':
                    o = new eh[a.type](
                      a.radiusTop,
                      a.radiusBottom,
                      a.height,
                      a.radialSegments,
                      a.heightSegments,
                      a.openEnded,
                      a.thetaStart,
                      a.thetaLength
                    )
                    break
                  case 'ConeGeometry':
                  case 'ConeBufferGeometry':
                    o = new eh[a.type](
                      a.radius,
                      a.height,
                      a.radialSegments,
                      a.heightSegments,
                      a.openEnded,
                      a.thetaStart,
                      a.thetaLength
                    )
                    break
                  case 'SphereGeometry':
                  case 'SphereBufferGeometry':
                    o = new eh[a.type](
                      a.radius,
                      a.widthSegments,
                      a.heightSegments,
                      a.phiStart,
                      a.phiLength,
                      a.thetaStart,
                      a.thetaLength
                    )
                    break
                  case 'DodecahedronGeometry':
                  case 'DodecahedronBufferGeometry':
                  case 'IcosahedronGeometry':
                  case 'IcosahedronBufferGeometry':
                  case 'OctahedronGeometry':
                  case 'OctahedronBufferGeometry':
                  case 'TetrahedronGeometry':
                  case 'TetrahedronBufferGeometry':
                    o = new eh[a.type](a.radius, a.detail)
                    break
                  case 'RingGeometry':
                  case 'RingBufferGeometry':
                    o = new eh[a.type](
                      a.innerRadius,
                      a.outerRadius,
                      a.thetaSegments,
                      a.phiSegments,
                      a.thetaStart,
                      a.thetaLength
                    )
                    break
                  case 'TorusGeometry':
                  case 'TorusBufferGeometry':
                    o = new eh[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc)
                    break
                  case 'TorusKnotGeometry':
                  case 'TorusKnotBufferGeometry':
                    o = new eh[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q)
                    break
                  case 'TubeGeometry':
                  case 'TubeBufferGeometry':
                    o = new eh[a.type](
                      new su[a.path.type]().fromJSON(a.path),
                      a.tubularSegments,
                      a.radius,
                      a.radialSegments,
                      a.closed
                    )
                    break
                  case 'LatheGeometry':
                  case 'LatheBufferGeometry':
                    o = new eh[a.type](a.points, a.segments, a.phiStart, a.phiLength)
                    break
                  case 'PolyhedronGeometry':
                  case 'PolyhedronBufferGeometry':
                    o = new eh[a.type](a.vertices, a.indices, a.radius, a.details)
                    break
                  case 'ShapeGeometry':
                  case 'ShapeBufferGeometry':
                    i = []
                    for (let t = 0, n = a.shapes.length; t < n; t++) {
                      const n = e[a.shapes[t]]
                      i.push(n)
                    }
                    o = new eh[a.type](i, a.curveSegments)
                    break
                  case 'ExtrudeGeometry':
                  case 'ExtrudeBufferGeometry':
                    i = []
                    for (let t = 0, n = a.shapes.length; t < n; t++) {
                      const n = e[a.shapes[t]]
                      i.push(n)
                    }
                    const t = a.options.extrudePath
                    void 0 !== t && (a.options.extrudePath = new su[t.type]().fromJSON(t)),
                      (o = new eh[a.type](i, a.options))
                    break
                  case 'BufferGeometry':
                  case 'InstancedBufferGeometry':
                    o = r.parse(a)
                    break
                  case 'Geometry':
                    console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.')
                    break
                  default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"')
                    continue
                }
                ;(o.uuid = a.uuid),
                  void 0 !== a.name && (o.name = a.name),
                  !0 === o.isBufferGeometry && void 0 !== a.userData && (o.userData = a.userData),
                  (n[a.uuid] = o)
              }
            }
            return n
          }
          parseMaterials(t, e) {
            const n = {},
              i = {}
            if (void 0 !== t) {
              const r = new Ru()
              r.setTextures(e)
              for (let e = 0, s = t.length; e < s; e++) {
                const s = t[e]
                if ('MultiMaterial' === s.type) {
                  const t = []
                  for (let e = 0; e < s.materials.length; e++) {
                    const i = s.materials[e]
                    void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid])
                  }
                  i[s.uuid] = t
                } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), (i[s.uuid] = n[s.uuid])
              }
            }
            return i
          }
          parseAnimations(t) {
            const e = {}
            if (void 0 !== t)
              for (let n = 0; n < t.length; n++) {
                const i = t[n],
                  r = Eh.parse(i)
                e[r.uuid] = r
              }
            return e
          }
          parseImages(t, e) {
            const n = this,
              i = {}
            let r
            function s(t) {
              if ('string' == typeof t) {
                const e = t
                return (function (t) {
                  return (
                    n.manager.itemStart(t),
                    r.load(
                      t,
                      function () {
                        n.manager.itemEnd(t)
                      },
                      void 0,
                      function () {
                        n.manager.itemError(t), n.manager.itemEnd(t)
                      }
                    )
                  )
                })(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
              }
              return t.data ? { data: Wr(t.type, t.data), width: t.width, height: t.height } : null
            }
            if (void 0 !== t && t.length > 0) {
              const n = new Rh(e)
              ;(r = new Bh(n)), r.setCrossOrigin(this.crossOrigin)
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e],
                  r = n.url
                if (Array.isArray(r)) {
                  i[n.uuid] = []
                  for (let t = 0, e = r.length; t < e; t++) {
                    const e = s(r[t])
                    null !== e &&
                      (e instanceof HTMLImageElement
                        ? i[n.uuid].push(e)
                        : i[n.uuid].push(new Rs(e.data, e.width, e.height)))
                  }
                } else {
                  const t = s(n.url)
                  null !== t && (i[n.uuid] = t)
                }
              }
            }
            return i
          }
          parseTextures(t, e) {
            function n(t, e) {
              return 'number' == typeof t
                ? t
                : (console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', t), e[t])
            }
            const i = {}
            if (void 0 !== t)
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r]
                let o
                void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                  void 0 === e[s.image] && console.warn('THREE.ObjectLoader: Undefined image', s.image)
                const a = e[s.image]
                Array.isArray(a)
                  ? ((o = new As(a)), 6 === a.length && (o.needsUpdate = !0))
                  : ((o = a && a.data ? new Rs(a.data, a.width, a.height) : new Zn(a)), a && (o.needsUpdate = !0)),
                  (o.uuid = s.uuid),
                  void 0 !== s.name && (o.name = s.name),
                  void 0 !== s.mapping && (o.mapping = n(s.mapping, Nu)),
                  void 0 !== s.offset && o.offset.fromArray(s.offset),
                  void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
                  void 0 !== s.center && o.center.fromArray(s.center),
                  void 0 !== s.rotation && (o.rotation = s.rotation),
                  void 0 !== s.wrap && ((o.wrapS = n(s.wrap[0], Bu)), (o.wrapT = n(s.wrap[1], Bu))),
                  void 0 !== s.format && (o.format = s.format),
                  void 0 !== s.type && (o.type = s.type),
                  void 0 !== s.encoding && (o.encoding = s.encoding),
                  void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, Fu)),
                  void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, Fu)),
                  void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
                  void 0 !== s.flipY && (o.flipY = s.flipY),
                  void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha),
                  void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment),
                  (i[s.uuid] = o)
              }
            return i
          }
          parseObject(t, e, n, i) {
            let r, s, o
            function a(t) {
              return void 0 === e[t] && console.warn('THREE.ObjectLoader: Undefined geometry', t), e[t]
            }
            function l(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  const e = []
                  for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i]
                    void 0 === n[r] && console.warn('THREE.ObjectLoader: Undefined material', r), e.push(n[r])
                  }
                  return e
                }
                return void 0 === n[t] && console.warn('THREE.ObjectLoader: Undefined material', t), n[t]
              }
            }
            switch (t.type) {
              case 'Scene':
                ;(r = new Ka()),
                  void 0 !== t.background && Number.isInteger(t.background) && (r.background = new Ar(t.background)),
                  void 0 !== t.fog &&
                    ('Fog' === t.fog.type
                      ? (r.fog = new Ja(t.fog.color, t.fog.near, t.fog.far))
                      : 'FogExp2' === t.fog.type && (r.fog = new Za(t.fog.color, t.fog.density)))
                break
              case 'PerspectiveCamera':
                ;(r = new Ts(t.fov, t.aspect, t.near, t.far)),
                  void 0 !== t.focus && (r.focus = t.focus),
                  void 0 !== t.zoom && (r.zoom = t.zoom),
                  void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
                  void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
                  void 0 !== t.view && (r.view = Object.assign({}, t.view))
                break
              case 'OrthographicCamera':
                ;(r = new _u(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                  void 0 !== t.zoom && (r.zoom = t.zoom),
                  void 0 !== t.view && (r.view = Object.assign({}, t.view))
                break
              case 'AmbientLight':
                r = new Su(t.color, t.intensity)
                break
              case 'DirectionalLight':
                r = new Tu(t.color, t.intensity)
                break
              case 'PointLight':
                r = new wu(t.color, t.intensity, t.distance, t.decay)
                break
              case 'RectAreaLight':
                r = new Eu(t.color, t.intensity, t.width, t.height)
                break
              case 'SpotLight':
                r = new gu(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay)
                break
              case 'HemisphereLight':
                r = new hu(t.color, t.groundColor, t.intensity)
                break
              case 'LightProbe':
                r = new Lu().fromJSON(t)
                break
              case 'SkinnedMesh':
                ;(s = a(t.geometry)),
                  (o = l(t.material)),
                  (r = new Sl(s, o)),
                  void 0 !== t.bindMode && (r.bindMode = t.bindMode),
                  void 0 !== t.bindMatrix && r.bindMatrix.fromArray(t.bindMatrix),
                  void 0 !== t.skeleton && (r.skeleton = t.skeleton)
                break
              case 'Mesh':
                ;(s = a(t.geometry)), (o = l(t.material)), (r = new gs(s, o))
                break
              case 'InstancedMesh':
                ;(s = a(t.geometry)), (o = l(t.material))
                const e = t.count,
                  n = t.instanceMatrix,
                  i = t.instanceColor
                ;(r = new Ol(s, o, e)),
                  (r.instanceMatrix = new Cr(new Float32Array(n.array), 16)),
                  void 0 !== i && (r.instanceColor = new Cr(new Float32Array(i.array), i.itemSize))
                break
              case 'LOD':
                r = new xl()
                break
              case 'Line':
                r = new Hl(a(t.geometry), l(t.material))
                break
              case 'LineLoop':
                r = new jl(a(t.geometry), l(t.material))
                break
              case 'LineSegments':
                r = new Wl(a(t.geometry), l(t.material))
                break
              case 'PointCloud':
              case 'Points':
                r = new Kl(a(t.geometry), l(t.material))
                break
              case 'Sprite':
                r = new fl(l(t.material))
                break
              case 'Group':
                r = new Va()
                break
              case 'Bone':
                r = new El()
                break
              default:
                r = new ir()
            }
            if (
              ((r.uuid = t.uuid),
              void 0 !== t.name && (r.name = t.name),
              void 0 !== t.matrix
                ? (r.matrix.fromArray(t.matrix),
                  void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate),
                  r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale))
                : (void 0 !== t.position && r.position.fromArray(t.position),
                  void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
                  void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion),
                  void 0 !== t.scale && r.scale.fromArray(t.scale)),
              void 0 !== t.castShadow && (r.castShadow = t.castShadow),
              void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
              t.shadow &&
                (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
                void 0 !== t.shadow.normalBias && (r.shadow.normalBias = t.shadow.normalBias),
                void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius),
                void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize),
                void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))),
              void 0 !== t.visible && (r.visible = t.visible),
              void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled),
              void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
              void 0 !== t.userData && (r.userData = t.userData),
              void 0 !== t.layers && (r.layers.mask = t.layers),
              void 0 !== t.children)
            ) {
              const s = t.children
              for (let t = 0; t < s.length; t++) r.add(this.parseObject(s[t], e, n, i))
            }
            if (void 0 !== t.animations) {
              const e = t.animations
              for (let t = 0; t < e.length; t++) {
                const n = e[t]
                r.animations.push(i[n])
              }
            }
            if ('LOD' === t.type) {
              void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate)
              const e = t.levels
              for (let t = 0; t < e.length; t++) {
                const n = e[t],
                  i = r.getObjectByProperty('uuid', n.object)
                void 0 !== i && r.addLevel(i, n.distance)
              }
            }
            return r
          }
          bindSkeletons(t, e) {
            0 !== Object.keys(e).length &&
              t.traverse(function (t) {
                if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                  const n = e[t.skeleton]
                  void 0 === n
                    ? console.warn('THREE.ObjectLoader: No skeleton found with UUID:', t.skeleton)
                    : t.bind(n, t.bindMatrix)
                }
              })
          }
          setTexturePath(t) {
            return (
              console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().'),
              this.setResourcePath(t)
            )
          }
        }
        const Nu = {
            UVMapping: lt,
            CubeReflectionMapping: ct,
            CubeRefractionMapping: ht,
            EquirectangularReflectionMapping: ut,
            EquirectangularRefractionMapping: dt,
            CubeUVReflectionMapping: pt,
            CubeUVRefractionMapping: mt
          },
          Bu = { RepeatWrapping: ft, ClampToEdgeWrapping: gt, MirroredRepeatWrapping: vt },
          Fu = {
            NearestFilter: yt,
            NearestMipmapNearestFilter: xt,
            NearestMipmapLinearFilter: wt,
            LinearFilter: Mt,
            LinearMipmapNearestFilter: Tt,
            LinearMipmapLinearFilter: Et
          }
        function zu(t) {
          'undefined' == typeof createImageBitmap &&
            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
            'undefined' == typeof fetch && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
            Ch.call(this, t),
            (this.options = { premultiplyAlpha: 'none' })
        }
        zu.prototype = Object.assign(Object.create(Ch.prototype), {
          constructor: zu,
          isImageBitmapLoader: !0,
          setOptions: function (t) {
            return (this.options = t), this
          },
          load: function (t, e, n, i) {
            void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
            const r = this,
              s = Lh.get(t)
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t)
                }, 0),
                s
              )
            const o = {}
            ;(o.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
              (o.headers = this.requestHeader),
              fetch(t, o)
                .then(function (t) {
                  return t.blob()
                })
                .then(function (t) {
                  return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: 'none' }))
                })
                .then(function (n) {
                  Lh.add(t, n), e && e(n), r.manager.itemEnd(t)
                })
                .catch(function (e) {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }),
              r.manager.itemStart(t)
          }
        })
        class ku {
          constructor() {
            ;(this.type = 'ShapePath'), (this.color = new Ar()), (this.subPaths = []), (this.currentPath = null)
          }
          moveTo(t, e) {
            return (
              (this.currentPath = new au()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
            )
          }
          lineTo(t, e) {
            return this.currentPath.lineTo(t, e), this
          }
          quadraticCurveTo(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i), this
          }
          bezierCurveTo(t, e, n, i, r, s) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this
          }
          splineThru(t) {
            return this.currentPath.splineThru(t), this
          }
          toShapes(t, e) {
            function n(t) {
              const e = []
              for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n],
                  r = new lu()
                ;(r.curves = i.curves), e.push(r)
              }
              return e
            }
            function i(t, e) {
              const n = e.length
              let i = !1
              for (let r = n - 1, s = 0; s < n; r = s++) {
                let n = e[r],
                  o = e[s],
                  a = o.x - n.x,
                  l = o.y - n.y
                if (Math.abs(l) > Number.EPSILON) {
                  if ((l < 0 && ((n = e[s]), (a = -a), (o = e[r]), (l = -l)), t.y < n.y || t.y > o.y)) continue
                  if (t.y === n.y) {
                    if (t.x === n.x) return !0
                  } else {
                    const e = l * (t.x - n.x) - a * (t.y - n.y)
                    if (0 === e) return !0
                    if (e < 0) continue
                    i = !i
                  }
                } else {
                  if (t.y !== n.y) continue
                  if ((o.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= o.x)) return !0
                }
              }
              return i
            }
            const r = Fc.isClockWise,
              s = this.subPaths
            if (0 === s.length) return []
            if (!0 === e) return n(s)
            let o, a, l
            const c = []
            if (1 === s.length) return (a = s[0]), (l = new lu()), (l.curves = a.curves), c.push(l), c
            let h = !r(s[0].getPoints())
            h = t ? !h : h
            const u = [],
              d = []
            let p,
              m,
              f = [],
              g = 0
            ;(d[g] = void 0), (f[g] = [])
            for (let e = 0, n = s.length; e < n; e++)
              (a = s[e]),
                (p = a.getPoints()),
                (o = r(p)),
                (o = t ? !o : o),
                o
                  ? (!h && d[g] && g++, (d[g] = { s: new lu(), p }), (d[g].s.curves = a.curves), h && g++, (f[g] = []))
                  : f[g].push({ h: a, p: p[0] })
            if (!d[0]) return n(s)
            if (d.length > 1) {
              let t = !1
              const e = []
              for (let t = 0, e = d.length; t < e; t++) u[t] = []
              for (let n = 0, r = d.length; n < r; n++) {
                const r = f[n]
                for (let s = 0; s < r.length; s++) {
                  const o = r[s]
                  let a = !0
                  for (let r = 0; r < d.length; r++)
                    i(o.p, d[r].p) &&
                      (n !== r && e.push({ froms: n, tos: r, hole: s }), a ? ((a = !1), u[r].push(o)) : (t = !0))
                  a && u[n].push(o)
                }
              }
              e.length > 0 && (t || (f = u))
            }
            for (let t = 0, e = d.length; t < e; t++) {
              ;(l = d[t].s), c.push(l), (m = f[t])
              for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h)
            }
            return c
          }
        }
        class Uu {
          constructor(t) {
            ;(this.type = 'Font'), (this.data = t)
          }
          generateShapes(t, e = 100) {
            const n = [],
              i = (function (t, e, n) {
                const i = Array.from(t),
                  r = e / n.resolution,
                  s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                  o = []
                let a = 0,
                  l = 0
                for (let t = 0; t < i.length; t++) {
                  const e = i[t]
                  if ('\n' === e) (a = 0), (l -= s)
                  else {
                    const t = Hu(e, r, a, l, n)
                    ;(a += t.offsetX), o.push(t.path)
                  }
                }
                return o
              })(t, e, this.data)
            for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes())
            return n
          }
        }
        function Hu(t, e, n, i, r) {
          const s = r.glyphs[t] || r.glyphs['?']
          if (!s)
            return void console.error(
              'THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + '.'
            )
          const o = new ku()
          let a, l, c, h, u, d, p, m
          if (s.o) {
            const t = s._cachedOutline || (s._cachedOutline = s.o.split(' '))
            for (let r = 0, s = t.length; r < s; )
              switch (t[r++]) {
                case 'm':
                  ;(a = t[r++] * e + n), (l = t[r++] * e + i), o.moveTo(a, l)
                  break
                case 'l':
                  ;(a = t[r++] * e + n), (l = t[r++] * e + i), o.lineTo(a, l)
                  break
                case 'q':
                  ;(c = t[r++] * e + n),
                    (h = t[r++] * e + i),
                    (u = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    o.quadraticCurveTo(u, d, c, h)
                  break
                case 'b':
                  ;(c = t[r++] * e + n),
                    (h = t[r++] * e + i),
                    (u = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    (p = t[r++] * e + n),
                    (m = t[r++] * e + i),
                    o.bezierCurveTo(u, d, p, m, c, h)
              }
          }
          return { offsetX: s.ha * e, path: o }
        }
        Uu.prototype.isFont = !0
        class Gu extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = this,
              s = new Dh(this.manager)
            s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (t) {
                  let n
                  try {
                    n = JSON.parse(t)
                  } catch (e) {
                    console.warn(
                      'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.'
                    ),
                      (n = JSON.parse(t.substring(65, t.length - 2)))
                  }
                  const i = r.parse(n)
                  e && e(i)
                },
                n,
                i
              )
          }
          parse(t) {
            return new Uu(t)
          }
        }
        let Vu
        const Wu = {
          getContext: function () {
            return void 0 === Vu && (Vu = new (window.AudioContext || window.webkitAudioContext)()), Vu
          },
          setContext: function (t) {
            Vu = t
          }
        }
        class ju extends Ch {
          constructor(t) {
            super(t)
          }
          load(t, e, n, i) {
            const r = this,
              s = new Dh(this.manager)
            s.setResponseType('arraybuffer'),
              s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    const t = n.slice(0)
                    Wu.getContext().decodeAudioData(t, function (t) {
                      e(t)
                    })
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                  }
                },
                n,
                i
              )
          }
        }
        class qu extends Lu {
          constructor(t, e, n = 1) {
            super(void 0, n)
            const i = new Ar().set(t),
              r = new Ar().set(e),
              s = new ei(i.r, i.g, i.b),
              o = new ei(r.r, r.g, r.b),
              a = Math.sqrt(Math.PI),
              l = a * Math.sqrt(0.75)
            this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
              this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
          }
        }
        qu.prototype.isHemisphereLightProbe = !0
        class Xu extends Lu {
          constructor(t, e = 1) {
            super(void 0, e)
            const n = new Ar().set(t)
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
          }
        }
        Xu.prototype.isAmbientLightProbe = !0
        const Yu = new Ii(),
          Zu = new Ii()
        class Ju {
          constructor() {
            ;(this.type = 'StereoCamera'),
              (this.aspect = 1),
              (this.eyeSep = 0.064),
              (this.cameraL = new Ts()),
              this.cameraL.layers.enable(1),
              (this.cameraL.matrixAutoUpdate = !1),
              (this.cameraR = new Ts()),
              this.cameraR.layers.enable(2),
              (this.cameraR.matrixAutoUpdate = !1),
              (this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null })
          }
          update(t) {
            const e = this._cache
            if (
              e.focus !== t.focus ||
              e.fov !== t.fov ||
              e.aspect !== t.aspect * this.aspect ||
              e.near !== t.near ||
              e.far !== t.far ||
              e.zoom !== t.zoom ||
              e.eyeSep !== this.eyeSep
            ) {
              ;(e.focus = t.focus),
                (e.fov = t.fov),
                (e.aspect = t.aspect * this.aspect),
                (e.near = t.near),
                (e.far = t.far),
                (e.zoom = t.zoom),
                (e.eyeSep = this.eyeSep)
              const n = t.projectionMatrix.clone(),
                i = e.eyeSep / 2,
                r = (i * e.near) / e.focus,
                s = (e.near * Math.tan(Vn.DEG2RAD * e.fov * 0.5)) / e.zoom
              let o, a
              ;(Zu.elements[12] = -i),
                (Yu.elements[12] = i),
                (o = -s * e.aspect + r),
                (a = s * e.aspect + r),
                (n.elements[0] = (2 * e.near) / (a - o)),
                (n.elements[8] = (a + o) / (a - o)),
                this.cameraL.projectionMatrix.copy(n),
                (o = -s * e.aspect - r),
                (a = s * e.aspect - r),
                (n.elements[0] = (2 * e.near) / (a - o)),
                (n.elements[8] = (a + o) / (a - o)),
                this.cameraR.projectionMatrix.copy(n)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Zu),
              this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Yu)
          }
        }
        class Ku {
          constructor(t) {
            ;(this.autoStart = void 0 === t || t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1)
          }
          start() {
            ;(this.startTime = Qu()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0)
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime
          }
          getDelta() {
            let t = 0
            if (this.autoStart && !this.running) return this.start(), 0
            if (this.running) {
              const e = Qu()
              ;(t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t)
            }
            return t
          }
        }
        function Qu() {
          return ('undefined' == typeof performance ? Date : performance).now()
        }
        const $u = new ei(),
          td = new ti(),
          ed = new ei(),
          nd = new ei()
        class id extends ir {
          constructor() {
            super(),
              (this.type = 'AudioListener'),
              (this.context = Wu.getContext()),
              (this.gain = this.context.createGain()),
              this.gain.connect(this.context.destination),
              (this.filter = null),
              (this.timeDelta = 0),
              (this._clock = new Ku())
          }
          getInput() {
            return this.gain
          }
          removeFilter() {
            return (
              null !== this.filter &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            )
          }
          getFilter() {
            return this.filter
          }
          setFilter(t) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = t),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            )
          }
          getMasterVolume() {
            return this.gain.gain.value
          }
          setMasterVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t)
            const e = this.context.listener,
              n = this.up
            if (
              ((this.timeDelta = this._clock.getDelta()),
              this.matrixWorld.decompose($u, td, ed),
              nd.set(0, 0, -1).applyQuaternion(td),
              e.positionX)
            ) {
              const t = this.context.currentTime + this.timeDelta
              e.positionX.linearRampToValueAtTime($u.x, t),
                e.positionY.linearRampToValueAtTime($u.y, t),
                e.positionZ.linearRampToValueAtTime($u.z, t),
                e.forwardX.linearRampToValueAtTime(nd.x, t),
                e.forwardY.linearRampToValueAtTime(nd.y, t),
                e.forwardZ.linearRampToValueAtTime(nd.z, t),
                e.upX.linearRampToValueAtTime(n.x, t),
                e.upY.linearRampToValueAtTime(n.y, t),
                e.upZ.linearRampToValueAtTime(n.z, t)
            } else e.setPosition($u.x, $u.y, $u.z), e.setOrientation(nd.x, nd.y, nd.z, n.x, n.y, n.z)
          }
        }
        class rd extends ir {
          constructor(t) {
            super(),
              (this.type = 'Audio'),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = 'empty'),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = [])
          }
          getOutput() {
            return this.gain
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1), (this.sourceType = 'audioNode'), (this.source = t), this.connect(), this
            )
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaNode'),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            )
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaStreamNode'),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            )
          }
          setBuffer(t) {
            return (this.buffer = t), (this.sourceType = 'buffer'), this.autoplay && this.play(), this
          }
          play(t = 0) {
            if (!0 === this.isPlaying) return void console.warn('THREE.Audio: Audio is already playing.')
            if (!1 === this.hasPlaybackControl)
              return void console.warn('THREE.Audio: this Audio has no playback control.')
            this._startedAt = this.context.currentTime + t
            const e = this.context.createBufferSource()
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(this._startedAt, this._progress + this.offset, this.duration),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            )
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
                  !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (this._progress = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t])
              this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput())
            return (this._connected = !0), this
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t])
              this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput())
            return (this._connected = !1), this
          }
          getFilters() {
            return this.filters
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(), (this.filters = t.slice()), this.connect())
                : (this.filters = t.slice()),
              this
            )
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
                this
              )
          }
          getDetune() {
            return this.detune
          }
          getFilter() {
            return this.getFilters()[0]
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : [])
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          getPlaybackRate() {
            return this.playbackRate
          }
          onEnded() {
            this.isPlaying = !1
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
              : this.loop
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          setLoopStart(t) {
            return (this.loopStart = t), this
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this
          }
          getVolume() {
            return this.gain.gain.value
          }
          setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
          }
        }
        const sd = new ei(),
          od = new ti(),
          ad = new ei(),
          ld = new ei()
        class cd extends rd {
          constructor(t) {
            super(t),
              (this.panner = this.context.createPanner()),
              (this.panner.panningModel = 'HRTF'),
              this.panner.connect(this.gain)
          }
          getOutput() {
            return this.panner
          }
          getRefDistance() {
            return this.panner.refDistance
          }
          setRefDistance(t) {
            return (this.panner.refDistance = t), this
          }
          getRolloffFactor() {
            return this.panner.rolloffFactor
          }
          setRolloffFactor(t) {
            return (this.panner.rolloffFactor = t), this
          }
          getDistanceModel() {
            return this.panner.distanceModel
          }
          setDistanceModel(t) {
            return (this.panner.distanceModel = t), this
          }
          getMaxDistance() {
            return this.panner.maxDistance
          }
          setMaxDistance(t) {
            return (this.panner.maxDistance = t), this
          }
          setDirectionalCone(t, e, n) {
            return (
              (this.panner.coneInnerAngle = t), (this.panner.coneOuterAngle = e), (this.panner.coneOuterGain = n), this
            )
          }
          updateMatrixWorld(t) {
            if ((super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying)) return
            this.matrixWorld.decompose(sd, od, ad), ld.set(0, 0, 1).applyQuaternion(od)
            const e = this.panner
            if (e.positionX) {
              const t = this.context.currentTime + this.listener.timeDelta
              e.positionX.linearRampToValueAtTime(sd.x, t),
                e.positionY.linearRampToValueAtTime(sd.y, t),
                e.positionZ.linearRampToValueAtTime(sd.z, t),
                e.orientationX.linearRampToValueAtTime(ld.x, t),
                e.orientationY.linearRampToValueAtTime(ld.y, t),
                e.orientationZ.linearRampToValueAtTime(ld.z, t)
            } else e.setPosition(sd.x, sd.y, sd.z), e.setOrientation(ld.x, ld.y, ld.z)
          }
        }
        class hd {
          constructor(t, e = 2048) {
            ;(this.analyser = t.context.createAnalyser()),
              (this.analyser.fftSize = e),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              t.getOutput().connect(this.analyser)
          }
          getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data
          }
          getAverageFrequency() {
            let t = 0
            const e = this.getFrequencyData()
            for (let n = 0; n < e.length; n++) t += e[n]
            return t / e.length
          }
        }
        class ud {
          constructor(t, e, n) {
            let i, r, s
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case 'quaternion':
                ;(i = this._slerp),
                  (r = this._slerpAdditive),
                  (s = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5)
                break
              case 'string':
              case 'bool':
                ;(i = this._select),
                  (r = this._select),
                  (s = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n))
                break
              default:
                ;(i = this._lerp),
                  (r = this._lerpAdditive),
                  (s = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n))
            }
            ;(this._mixBufferRegion = i),
              (this._mixBufferRegionAdditive = r),
              (this._setIdentity = s),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0)
          }
          accumulate(t, e) {
            const n = this.buffer,
              i = this.valueSize,
              r = t * i + i
            let s = this.cumulativeWeight
            if (0 === s) {
              for (let t = 0; t !== i; ++t) n[r + t] = n[t]
              s = e
            } else {
              s += e
              const t = e / s
              this._mixBufferRegion(n, r, 0, t, i)
            }
            this.cumulativeWeight = s
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              i = n * this._addIndex
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, i, 0, t, n),
              (this.cumulativeWeightAdditive += t)
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              o = this.binding
            if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
              const t = e * this._origIndex
              this._mixBufferRegion(n, i, t, 1 - r, e)
            }
            s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e)
            for (let t = e, r = e + e; t !== r; ++t)
              if (n[t] !== n[t + e]) {
                o.setValue(n, i)
                break
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = n * this._origIndex
            t.getValue(e, i)
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)]
            this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0)
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize
            this.binding.setValue(this.buffer, t)
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize
            for (let n = t; n < e; n++) this.buffer[n] = 0
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1)
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize
            for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
          }
          _select(t, e, n, i, r) {
            if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
          }
          _slerp(t, e, n, i) {
            ti.slerpFlat(t, e, t, e, t, n, i)
          }
          _slerpAdditive(t, e, n, i, r) {
            const s = this._workIndex * r
            ti.multiplyQuaternionsFlat(t, s, t, e, t, n), ti.slerpFlat(t, e, t, e, t, s, i)
          }
          _lerp(t, e, n, i, r) {
            const s = 1 - i
            for (let o = 0; o !== r; ++o) {
              const r = e + o
              t[r] = t[r] * s + t[n + o] * i
            }
          }
          _lerpAdditive(t, e, n, i, r) {
            for (let s = 0; s !== r; ++s) {
              const r = e + s
              t[r] = t[r] + t[n + s] * i
            }
          }
        }
        const dd = new RegExp('[\\[\\]\\.:\\/]', 'g'),
          pd = '[^\\[\\]\\.:\\/]',
          md = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
          fd = /((?:WC+[\/:])*)/.source.replace('WC', pd),
          gd = /(WCOD+)?/.source.replace('WCOD', md),
          vd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', pd),
          yd = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', pd),
          xd = new RegExp('^' + fd + gd + vd + yd + '$'),
          bd = ['material', 'materials', 'bones']
        function wd(t, e, n) {
          const i = n || _d.parseTrackName(e)
          ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, i))
        }
        function _d(t, e, n) {
          ;(this.path = e),
            (this.parsedPath = n || _d.parseTrackName(e)),
            (this.node = _d.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t)
        }
        Object.assign(wd.prototype, {
          getValue: function (t, e) {
            this.bind()
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n]
            void 0 !== i && i.getValue(t, e)
          },
          setValue: function (t, e) {
            const n = this._bindings
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
          },
          bind: function () {
            const t = this._bindings
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
          },
          unbind: function () {
            const t = this._bindings
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
          }
        }),
          Object.assign(_d, {
            Composite: wd,
            create: function (t, e, n) {
              return t && t.isAnimationObjectGroup ? new _d.Composite(t, e, n) : new _d(t, e, n)
            },
            sanitizeNodeName: function (t) {
              return t.replace(/\s/g, '_').replace(dd, '')
            },
            parseTrackName: function (t) {
              const e = xd.exec(t)
              if (!e) throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
              const n = {
                  nodeName: e[2],
                  objectName: e[3],
                  objectIndex: e[4],
                  propertyName: e[5],
                  propertyIndex: e[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf('.')
              if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1)
                ;-1 !== bd.indexOf(t) && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t))
              }
              if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + t)
              return n
            },
            findNode: function (t, e) {
              if (!e || '' === e || '.' === e || -1 === e || e === t.name || e === t.uuid) return t
              if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e)
                if (void 0 !== n) return n
              }
              if (t.children) {
                const n = function (t) {
                    for (let i = 0; i < t.length; i++) {
                      const r = t[i]
                      if (r.name === e || r.uuid === e) return r
                      const s = n(r.children)
                      if (s) return s
                    }
                    return null
                  },
                  i = n(t.children)
                if (i) return i
              }
              return null
            }
          }),
          Object.assign(_d.prototype, {
            _getValue_unavailable: function () {},
            _setValue_unavailable: function () {},
            BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
            Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
            GetterByBindingType: [
              function (t, e) {
                t[e] = this.node[this.propertyName]
              },
              function (t, e) {
                const n = this.resolvedProperty
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
              },
              function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
              },
              function (t, e) {
                this.resolvedProperty.toArray(t, e)
              }
            ],
            SetterByBindingTypeAndVersioning: [
              [
                function (t, e) {
                  this.targetObject[this.propertyName] = t[e]
                },
                function (t, e) {
                  ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0)
                },
                function (t, e) {
                  ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
                }
              ],
              [
                function (t, e) {
                  const n = this.resolvedProperty
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                },
                function (t, e) {
                  const n = this.resolvedProperty
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                  this.targetObject.needsUpdate = !0
                },
                function (t, e) {
                  const n = this.resolvedProperty
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                  this.targetObject.matrixWorldNeedsUpdate = !0
                }
              ],
              [
                function (t, e) {
                  this.resolvedProperty[this.propertyIndex] = t[e]
                },
                function (t, e) {
                  ;(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0)
                },
                function (t, e) {
                  ;(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
                }
              ],
              [
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e)
                },
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0)
                },
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0)
                }
              ]
            ],
            getValue: function (t, e) {
              this.bind(), this.getValue(t, e)
            },
            setValue: function (t, e) {
              this.bind(), this.setValue(t, e)
            },
            bind: function () {
              let t = this.node
              const e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName
              let r = e.propertyIndex
              if (
                (t || ((t = _d.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)),
                (this.getValue = this._getValue_unavailable),
                (this.setValue = this._setValue_unavailable),
                !t)
              )
                return void console.error(
                  'THREE.PropertyBinding: Trying to update node for track: ' + this.path + " but it wasn't found."
                )
              if (n) {
                let i = e.objectIndex
                switch (n) {
                  case 'materials':
                    if (!t.material)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                        this
                      )
                    if (!t.material.materials)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                        this
                      )
                    t = t.material.materials
                    break
                  case 'bones':
                    if (!t.skeleton)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                        this
                      )
                    t = t.skeleton.bones
                    for (let e = 0; e < t.length; e++)
                      if (t[e].name === i) {
                        i = e
                        break
                      }
                    break
                  default:
                    if (void 0 === t[n])
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                        this
                      )
                    t = t[n]
                }
                if (void 0 !== i) {
                  if (void 0 === t[i])
                    return void console.error(
                      'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                      this,
                      t
                    )
                  t = t[i]
                }
              }
              const s = t[i]
              if (void 0 === s) {
                const n = e.nodeName
                return void console.error(
                  'THREE.PropertyBinding: Trying to update property for track: ' +
                    n +
                    '.' +
                    i +
                    " but it wasn't found.",
                  t
                )
              }
              let o = this.Versioning.None
              ;(this.targetObject = t),
                void 0 !== t.needsUpdate
                  ? (o = this.Versioning.NeedsUpdate)
                  : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate)
              let a = this.BindingType.Direct
              if (void 0 !== r) {
                if ('morphTargetInfluences' === i) {
                  if (!t.geometry)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                      this
                    )
                  if (!t.geometry.isBufferGeometry)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
                      this
                    )
                  if (!t.geometry.morphAttributes)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                      this
                    )
                  void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                ;(a = this.BindingType.ArrayElement), (this.resolvedProperty = s), (this.propertyIndex = r)
              } else
                void 0 !== s.fromArray && void 0 !== s.toArray
                  ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                  : Array.isArray(s)
                  ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = s))
                  : (this.propertyName = i)
              ;(this.getValue = this.GetterByBindingType[a]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[a][o])
            },
            unbind: function () {
              ;(this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound)
            }
          }),
          Object.assign(_d.prototype, {
            _getValue_unbound: _d.prototype.getValue,
            _setValue_unbound: _d.prototype.setValue
          })
        class Md {
          constructor() {
            ;(this.uuid = Vn.generateUUID()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0)
            const t = {}
            this._indicesByUUID = t
            for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e
            ;(this._paths = []), (this._parsedPaths = []), (this._bindings = []), (this._bindingsIndicesByPath = {})
            const e = this
            this.stats = {
              objects: {
                get total() {
                  return e._objects.length
                },
                get inUse() {
                  return this.total - e.nCachedObjects_
                }
              },
              get bindingsPerObject() {
                return e._bindings.length
              }
            }
          }
          add() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._paths,
              i = this._parsedPaths,
              r = this._bindings,
              s = r.length
            let o,
              a = t.length,
              l = this.nCachedObjects_
            for (let c = 0, h = arguments.length; c !== h; ++c) {
              const h = arguments[c],
                u = h.uuid
              let d = e[u]
              if (void 0 === d) {
                ;(d = a++), (e[u] = d), t.push(h)
                for (let t = 0, e = s; t !== e; ++t) r[t].push(new _d(h, n[t], i[t]))
              } else if (d < l) {
                o = t[d]
                const a = --l,
                  c = t[a]
                ;(e[c.uuid] = d), (t[d] = c), (e[u] = a), (t[a] = h)
                for (let t = 0, e = s; t !== e; ++t) {
                  const e = r[t],
                    s = e[a]
                  let o = e[d]
                  ;(e[d] = s), void 0 === o && (o = new _d(h, n[t], i[t])), (e[a] = o)
                }
              } else
                t[d] !== o &&
                  console.error(
                    'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
                  )
            }
            this.nCachedObjects_ = l
          }
          remove() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length
            let r = this.nCachedObjects_
            for (let s = 0, o = arguments.length; s !== o; ++s) {
              const o = arguments[s],
                a = o.uuid,
                l = e[a]
              if (void 0 !== l && l >= r) {
                const s = r++,
                  c = t[s]
                ;(e[c.uuid] = l), (t[l] = c), (e[a] = s), (t[s] = o)
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[s],
                    r = e[l]
                  ;(e[l] = i), (e[s] = r)
                }
              }
            }
            this.nCachedObjects_ = r
          }
          uncache() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length
            let r = this.nCachedObjects_,
              s = t.length
            for (let o = 0, a = arguments.length; o !== a; ++o) {
              const a = arguments[o].uuid,
                l = e[a]
              if (void 0 !== l)
                if ((delete e[a], l < r)) {
                  const o = --r,
                    a = t[o],
                    c = --s,
                    h = t[c]
                  ;(e[a.uuid] = l), (t[l] = a), (e[h.uuid] = o), (t[o] = h), t.pop()
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[o],
                      r = e[c]
                    ;(e[l] = i), (e[o] = r), e.pop()
                  }
                } else {
                  const r = --s,
                    o = t[r]
                  r > 0 && (e[o.uuid] = l), (t[l] = o), t.pop()
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t]
                    ;(e[l] = e[r]), e.pop()
                  }
                }
            }
            this.nCachedObjects_ = r
          }
          subscribe_(t, e) {
            const n = this._bindingsIndicesByPath
            let i = n[t]
            const r = this._bindings
            if (void 0 !== i) return r[i]
            const s = this._paths,
              o = this._parsedPaths,
              a = this._objects,
              l = a.length,
              c = this.nCachedObjects_,
              h = new Array(l)
            ;(i = r.length), (n[t] = i), s.push(t), o.push(e), r.push(h)
            for (let n = c, i = a.length; n !== i; ++n) {
              const i = a[n]
              h[n] = new _d(i, t, e)
            }
            return h
          }
          unsubscribe_(t) {
            const e = this._bindingsIndicesByPath,
              n = e[t]
            if (void 0 !== n) {
              const i = this._paths,
                r = this._parsedPaths,
                s = this._bindings,
                o = s.length - 1,
                a = s[o]
              ;(e[t[o]] = n), (s[n] = a), s.pop(), (r[n] = r[o]), r.pop(), (i[n] = i[o]), i.pop()
            }
          }
        }
        Md.prototype.isAnimationObjectGroup = !0
        class Td {
          constructor(t, e, n = null, i = e.blendMode) {
            ;(this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i)
            const r = e.tracks,
              s = r.length,
              o = new Array(s),
              a = { endingStart: qe, endingEnd: qe }
            for (let t = 0; t !== s; ++t) {
              const e = r[t].createInterpolant(null)
              ;(o[t] = e), (e.settings = a)
            }
            ;(this._interpolantSettings = a),
              (this._interpolants = o),
              (this._propertyBindings = new Array(s)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = He),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0)
          }
          play() {
            return this._mixer._activateAction(this), this
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset()
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            )
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            )
          }
          isScheduled() {
            return this._mixer._isActiveAction(this)
          }
          startAt(t) {
            return (this._startTime = t), this
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this
          }
          setEffectiveWeight(t) {
            return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading()
          }
          getEffectiveWeight() {
            return this._effectiveWeight
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1)
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0)
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                i = t._clip.duration,
                r = i / n,
                s = n / i
              t.warp(1, r, e), this.warp(s, 1, e)
            }
            return this
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n)
          }
          stopFading() {
            const t = this._weightInterpolant
            return null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this
          }
          setEffectiveTimeScale(t) {
            return (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping()
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale
          }
          setDuration(t) {
            return (this.timeScale = this._clip.duration / t), this.stopWarping()
          }
          syncWith(t) {
            return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
          }
          warp(t, e, n) {
            const i = this._mixer,
              r = i.time,
              s = this.timeScale
            let o = this._timeScaleInterpolant
            null === o && ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o))
            const a = o.parameterPositions,
              l = o.sampleValues
            return (a[0] = r), (a[1] = r + n), (l[0] = t / s), (l[1] = e / s), this
          }
          stopWarping() {
            const t = this._timeScaleInterpolant
            return null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this
          }
          getMixer() {
            return this._mixer
          }
          getClip() {
            return this._clip
          }
          getRoot() {
            return this._localRoot || this._mixer._root
          }
          _update(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t)
            const r = this._startTime
            if (null !== r) {
              const i = (t - r) * n
              if (i < 0 || 0 === n) return
              ;(this._startTime = null), (e = n * i)
            }
            e *= this._updateTimeScale(t)
            const s = this._updateTime(e),
              o = this._updateWeight(t)
            if (o > 0) {
              const t = this._interpolants,
                e = this._propertyBindings
              switch (this.blendMode) {
                case Je:
                  for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o)
                  break
                case Ze:
                default:
                  for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
              }
            }
          }
          _updateWeight(t) {
            let e = 0
            if (this.enabled) {
              e = this.weight
              const n = this._weightInterpolant
              if (null !== n) {
                const i = n.evaluate(t)[0]
                ;(e *= i), t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
              }
            }
            return (this._effectiveWeight = e), e
          }
          _updateTimeScale(t) {
            let e = 0
            if (!this.paused) {
              e = this.timeScale
              const n = this._timeScaleInterpolant
              null !== n &&
                ((e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)))
            }
            return (this._effectiveTimeScale = e), e
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop
            let i = this.time + t,
              r = this._loopCount
            const s = n === Ge
            if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i
            if (n === Ue) {
              ;-1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
              t: {
                if (i >= e) i = e
                else {
                  if (!(i < 0)) {
                    this.time = i
                    break t
                  }
                  i = 0
                }
                this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                  (this.time = i),
                  this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t < 0 ? -1 : 1 })
              }
            } else {
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                    : this._setEndings(0 === this.repetitions, !0, s)),
                i >= e || i < 0)
              ) {
                const n = Math.floor(i / e)
                ;(i -= e * n), (r += Math.abs(n))
                const o = this.repetitions - r
                if (o <= 0)
                  this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                    (i = t > 0 ? e : 0),
                    (this.time = i),
                    this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t > 0 ? 1 : -1 })
                else {
                  if (1 === o) {
                    const e = t < 0
                    this._setEndings(e, !e, s)
                  } else this._setEndings(!1, !1, s)
                  ;(this._loopCount = r),
                    (this.time = i),
                    this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: n })
                }
              } else this.time = i
              if (s && 1 == (1 & r)) return e - i
            }
            return i
          }
          _setEndings(t, e, n) {
            const i = this._interpolantSettings
            n
              ? ((i.endingStart = Xe), (i.endingEnd = Xe))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Xe : qe) : Ye),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Xe : qe) : Ye))
          }
          _scheduleFading(t, e, n) {
            const i = this._mixer,
              r = i.time
            let s = this._weightInterpolant
            null === s && ((s = i._lendControlInterpolant()), (this._weightInterpolant = s))
            const o = s.parameterPositions,
              a = s.sampleValues
            return (o[0] = r), (a[0] = e), (o[1] = r + t), (a[1] = n), this
          }
        }
        class Sd extends Un {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1)
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              i = t._clip.tracks,
              r = i.length,
              s = t._propertyBindings,
              o = t._interpolants,
              a = n.uuid,
              l = this._bindingsByRootAndName
            let c = l[a]
            void 0 === c && ((c = {}), (l[a] = c))
            for (let t = 0; t !== r; ++t) {
              const r = i[t],
                l = r.name
              let h = c[l]
              if (void 0 !== h) s[t] = h
              else {
                if (((h = s[t]), void 0 !== h)) {
                  null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l))
                  continue
                }
                const i = e && e._propertyBindings[t].binding.parsedPath
                ;(h = new ud(_d.create(n, l, i), r.ValueTypeName, r.getValueSize())),
                  ++h.referenceCount,
                  this._addInactiveBinding(h, a, l),
                  (s[t] = h)
              }
              o[t].resultBuffer = h.buffer
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  i = this._actionsByClip[n]
                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
              }
              const e = t._propertyBindings
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t]
                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
              }
              this._lendAction(t)
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t]
                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
              }
              this._takeBackAction(t)
            }
          }
          _initMemoryManager() {
            ;(this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0)
            const t = this
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length
                },
                get inUse() {
                  return t._nActiveActions
                }
              },
              bindings: {
                get total() {
                  return t._bindings.length
                },
                get inUse() {
                  return t._nActiveBindings
                }
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length
                },
                get inUse() {
                  return t._nActiveControlInterpolants
                }
              }
            }
          }
          _isActiveAction(t) {
            const e = t._cacheIndex
            return null !== e && e < this._nActiveActions
          }
          _addInactiveAction(t, e, n) {
            const i = this._actions,
              r = this._actionsByClip
            let s = r[e]
            if (void 0 === s) (s = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (r[e] = s)
            else {
              const e = s.knownActions
              ;(t._byClipCacheIndex = e.length), e.push(t)
            }
            ;(t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t)
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              i = t._cacheIndex
            ;(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null)
            const r = t._clip.uuid,
              s = this._actionsByClip,
              o = s[r],
              a = o.knownActions,
              l = a[a.length - 1],
              c = t._byClipCacheIndex
            ;(l._byClipCacheIndex = c),
              (a[c] = l),
              a.pop(),
              (t._byClipCacheIndex = null),
              delete o.actionByRoot[(t._localRoot || this._root).uuid],
              0 === a.length && delete s[r],
              this._removeInactiveBindingsForAction(t)
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t]
              0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = this._nActiveActions++,
              r = e[i]
            ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = --this._nActiveActions,
              r = e[i]
            ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
          }
          _addInactiveBinding(t, e, n) {
            const i = this._bindingsByRootAndName,
              r = this._bindings
            let s = i[e]
            void 0 === s && ((s = {}), (i[e] = s)), (s[n] = t), (t._cacheIndex = r.length), r.push(t)
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              i = n.rootNode.uuid,
              r = n.path,
              s = this._bindingsByRootAndName,
              o = s[i],
              a = e[e.length - 1],
              l = t._cacheIndex
            ;(a._cacheIndex = l), (e[l] = a), e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = this._nActiveBindings++,
              r = e[i]
            ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = --this._nActiveBindings,
              r = e[i]
            ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++
            let n = t[e]
            return (
              void 0 === n &&
                ((n = new gh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            )
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              i = --this._nActiveControlInterpolants,
              r = e[i]
            ;(t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r)
          }
          clipAction(t, e, n) {
            const i = e || this._root,
              r = i.uuid
            let s = 'string' == typeof t ? Eh.findByName(i, t) : t
            const o = null !== s ? s.uuid : t,
              a = this._actionsByClip[o]
            let l = null
            if ((void 0 === n && (n = null !== s ? s.blendMode : Ze), void 0 !== a)) {
              const t = a.actionByRoot[r]
              if (void 0 !== t && t.blendMode === n) return t
              ;(l = a.knownActions[0]), null === s && (s = l._clip)
            }
            if (null === s) return null
            const c = new Td(this, s, e, n)
            return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
          }
          existingAction(t, e) {
            const n = e || this._root,
              i = n.uuid,
              r = 'string' == typeof t ? Eh.findByName(n, t) : t,
              s = r ? r.uuid : t,
              o = this._actionsByClip[s]
            return (void 0 !== o && o.actionByRoot[i]) || null
          }
          stopAllAction() {
            const t = this._actions
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop()
            return this
          }
          update(t) {
            t *= this.timeScale
            const e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              s = (this._accuIndex ^= 1)
            for (let o = 0; o !== n; ++o) e[o]._update(i, t, r, s)
            const o = this._bindings,
              a = this._nActiveBindings
            for (let t = 0; t !== a; ++t) o[t].apply(s)
            return this
          }
          setTime(t) {
            this.time = 0
            for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0
            return this.update(t)
          }
          getRoot() {
            return this._root
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              i = this._actionsByClip,
              r = i[n]
            if (void 0 !== r) {
              const t = r.knownActions
              for (let n = 0, i = t.length; n !== i; ++n) {
                const i = t[n]
                this._deactivateAction(i)
                const r = i._cacheIndex,
                  s = e[e.length - 1]
                ;(i._cacheIndex = null),
                  (i._byClipCacheIndex = null),
                  (s._cacheIndex = r),
                  (e[r] = s),
                  e.pop(),
                  this._removeInactiveBindingsForAction(i)
              }
              delete i[n]
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip
            for (const t in n) {
              const i = n[t].actionByRoot[e]
              void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            const i = this._bindingsByRootAndName[e]
            if (void 0 !== i)
              for (const t in i) {
                const e = i[t]
                e.restoreOriginalState(), this._removeInactiveBinding(e)
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e)
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
          }
        }
        Sd.prototype._controlInterpolantsResultBuffer = new Float32Array(1)
        class Ed {
          constructor(t) {
            'string' == typeof t &&
              (console.warn('THREE.Uniform: Type parameter is no longer needed.'), (t = arguments[1])),
              (this.value = t)
          }
          clone() {
            return new Ed(void 0 === this.value.clone ? this.value : this.value.clone())
          }
        }
        function Ad(t, e, n) {
          Qa.call(this, t, e), (this.meshPerAttribute = n || 1)
        }
        function Ld(t, e, n, i, r) {
          ;(this.buffer = t),
            (this.type = e),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0)
        }
        function Rd(t, e, n = 0, i = 1 / 0) {
          ;(this.ray = new Ci(t, e)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Vi()),
            (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }),
            Object.defineProperties(this.params, {
              PointCloud: {
                get: function () {
                  return (
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.'), this.Points
                  )
                }
              }
            })
        }
        function Pd(t, e) {
          return t.distance - e.distance
        }
        function Cd(t, e, n, i) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
            const i = t.children
            for (let t = 0, r = i.length; t < r; t++) Cd(i[t], e, n, !0)
          }
        }
        ;(Ad.prototype = Object.assign(Object.create(Qa.prototype), {
          constructor: Ad,
          isInstancedInterleavedBuffer: !0,
          copy: function (t) {
            return Qa.prototype.copy.call(this, t), (this.meshPerAttribute = t.meshPerAttribute), this
          },
          clone: function (t) {
            const e = Qa.prototype.clone.call(this, t)
            return (e.meshPerAttribute = this.meshPerAttribute), e
          },
          toJSON: function (t) {
            const e = Qa.prototype.toJSON.call(this, t)
            return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e
          }
        })),
          Object.defineProperty(Ld.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++
            }
          }),
          Object.assign(Ld.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function (t) {
              return (this.buffer = t), this
            },
            setType: function (t, e) {
              return (this.type = t), (this.elementSize = e), this
            },
            setItemSize: function (t) {
              return (this.itemSize = t), this
            },
            setCount: function (t) {
              return (this.count = t), this
            }
          }),
          Object.assign(Rd.prototype, {
            set: function (t, e) {
              this.ray.set(t, e)
            },
            setFromCamera: function (t, e) {
              e && e.isPerspectiveCamera
                ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                  this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(),
                  (this.camera = e))
                : e && e.isOrthographicCamera
                ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                  this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error('THREE.Raycaster: Unsupported camera type: ' + e.type)
            },
            intersectObject: function (t, e = !1, n = []) {
              return Cd(t, this, n, e), n.sort(Pd), n
            },
            intersectObjects: function (t, e = !1, n = []) {
              for (let i = 0, r = t.length; i < r; i++) Cd(t[i], this, n, e)
              return n.sort(Pd), n
            }
          })
        class Id {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this
          }
          set(t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this
          }
          copy(t) {
            return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
          }
          makeSafe() {
            const t = 1e-6
            return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)), (this.phi = Math.acos(Vn.clamp(e / this.radius, -1, 1)))),
              this
            )
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        class Dd {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.theta = e), (this.y = n), this
          }
          set(t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this
          }
          copy(t) {
            return (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
          }
          setFromCartesianCoords(t, e, n) {
            return (this.radius = Math.sqrt(t * t + n * n)), (this.theta = Math.atan2(t, n)), (this.y = e), this
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        const Od = new Wn()
        class Nd {
          constructor(t = new Wn(1 / 0, 1 / 0), e = new Wn(-1 / 0, -1 / 0)) {
            ;(this.min = t), (this.max = e)
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this
          }
          setFromPoints(t) {
            this.makeEmpty()
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
            return this
          }
          setFromCenterAndSize(t, e) {
            const n = Od.copy(e).multiplyScalar(0.5)
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
          }
          makeEmpty() {
            return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y
          }
          getCenter(t) {
            return (
              void 0 === t && (console.warn('THREE.Box2: .getCenter() target is now required'), (t = new Wn())),
              this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            )
          }
          getSize(t) {
            return (
              void 0 === t && (console.warn('THREE.Box2: .getSize() target is now required'), (t = new Wn())),
              this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            )
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
          }
          containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
          }
          containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
          }
          getParameter(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Box2: .getParameter() target is now required'), (e = new Wn())),
              e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            )
          }
          intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
          }
          clampPoint(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Box2: .clampPoint() target is now required'), (e = new Wn())),
              e.copy(t).clamp(this.min, this.max)
            )
          }
          distanceToPoint(t) {
            return Od.copy(t).clamp(this.min, this.max).sub(t).length()
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
          }
        }
        Nd.prototype.isBox2 = !0
        const Bd = new ei(),
          Fd = new ei()
        class zd {
          constructor(t = new ei(), e = new ei()) {
            ;(this.start = t), (this.end = e)
          }
          set(t, e) {
            return this.start.copy(t), this.end.copy(e), this
          }
          copy(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
          }
          getCenter(t) {
            return (
              void 0 === t && (console.warn('THREE.Line3: .getCenter() target is now required'), (t = new ei())),
              t.addVectors(this.start, this.end).multiplyScalar(0.5)
            )
          }
          delta(t) {
            return (
              void 0 === t && (console.warn('THREE.Line3: .delta() target is now required'), (t = new ei())),
              t.subVectors(this.end, this.start)
            )
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end)
          }
          distance() {
            return this.start.distanceTo(this.end)
          }
          at(t, e) {
            return (
              void 0 === e && (console.warn('THREE.Line3: .at() target is now required'), (e = new ei())),
              this.delta(e).multiplyScalar(t).add(this.start)
            )
          }
          closestPointToPointParameter(t, e) {
            Bd.subVectors(t, this.start), Fd.subVectors(this.end, this.start)
            const n = Fd.dot(Fd)
            let i = Fd.dot(Bd) / n
            return e && (i = Vn.clamp(i, 0, 1)), i
          }
          closestPointToPoint(t, e, n) {
            const i = this.closestPointToPointParameter(t, e)
            return (
              void 0 === n &&
                (console.warn('THREE.Line3: .closestPointToPoint() target is now required'), (n = new ei())),
              this.delta(n).multiplyScalar(i).add(this.start)
            )
          }
          applyMatrix4(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
          }
          equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
          }
          clone() {
            return new this.constructor().copy(this)
          }
        }
        function kd(t) {
          ir.call(this),
            (this.material = t),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0)
        }
        ;(kd.prototype = Object.create(ir.prototype)),
          (kd.prototype.constructor = kd),
          (kd.prototype.isImmediateRenderObject = !0)
        const Ud = new ei()
        class Hd extends ir {
          constructor(t, e) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = e)
            const n = new Qr(),
              i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]
            for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
              const r = (t / n) * Math.PI * 2,
                s = (e / n) * Math.PI * 2
              i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
            }
            n.setAttribute('position', new Ur(i, 3))
            const r = new Nl({ fog: !1, toneMapped: !1 })
            ;(this.cone = new Wl(n, r)), this.add(this.cone), this.update()
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
          }
          update() {
            this.light.updateMatrixWorld()
            const t = this.light.distance ? this.light.distance : 1e3,
              e = t * Math.tan(this.light.angle)
            this.cone.scale.set(e, e, t),
              Ud.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(Ud),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color)
          }
        }
        const Gd = new ei(),
          Vd = new Ii(),
          Wd = new Ii()
        class jd extends Wl {
          constructor(t) {
            const e = qd(t),
              n = new Qr(),
              i = [],
              r = [],
              s = new Ar(0, 0, 1),
              o = new Ar(0, 1, 0)
            for (let t = 0; t < e.length; t++) {
              const n = e[t]
              n.parent &&
                n.parent.isBone &&
                (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
            }
            n.setAttribute('position', new Ur(i, 3)),
              n.setAttribute('color', new Ur(r, 3)),
              super(n, new Nl({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })),
              (this.type = 'SkeletonHelper'),
              (this.isSkeletonHelper = !0),
              (this.root = t),
              (this.bones = e),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1)
          }
          updateMatrixWorld(t) {
            const e = this.bones,
              n = this.geometry,
              i = n.getAttribute('position')
            Wd.copy(this.root.matrixWorld).invert()
            for (let t = 0, n = 0; t < e.length; t++) {
              const r = e[t]
              r.parent &&
                r.parent.isBone &&
                (Vd.multiplyMatrices(Wd, r.matrixWorld),
                Gd.setFromMatrixPosition(Vd),
                i.setXYZ(n, Gd.x, Gd.y, Gd.z),
                Vd.multiplyMatrices(Wd, r.parent.matrixWorld),
                Gd.setFromMatrixPosition(Vd),
                i.setXYZ(n + 1, Gd.x, Gd.y, Gd.z),
                (n += 2))
            }
            ;(n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(t)
          }
        }
        function qd(t) {
          const e = []
          t && t.isBone && e.push(t)
          for (let n = 0; n < t.children.length; n++) e.push.apply(e, qd(t.children[n]))
          return e
        }
        class Xd extends gs {
          constructor(t, e, n) {
            super(new Yc(e, 4, 2), new Lr({ wireframe: !0, fog: !1, toneMapped: !1 })),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.color = n),
              (this.type = 'PointLightHelper'),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update()
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose()
          }
          update() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
          }
        }
        const Yd = new ei(),
          Zd = new Ar(),
          Jd = new Ar()
        class Kd extends ir {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n)
            const i = new Wc(e)
            i.rotateY(0.5 * Math.PI),
              (this.material = new Lr({ wireframe: !0, fog: !1, toneMapped: !1 })),
              void 0 === this.color && (this.material.vertexColors = !0)
            const r = i.getAttribute('position'),
              s = new Float32Array(3 * r.count)
            i.setAttribute('color', new Cr(s, 3)), this.add(new gs(i, this.material)), this.update()
          }
          dispose() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
          }
          update() {
            const t = this.children[0]
            if (void 0 !== this.color) this.material.color.set(this.color)
            else {
              const e = t.geometry.getAttribute('color')
              Zd.copy(this.light.color), Jd.copy(this.light.groundColor)
              for (let t = 0, n = e.count; t < n; t++) {
                const i = t < n / 2 ? Zd : Jd
                e.setXYZ(t, i.r, i.g, i.b)
              }
              e.needsUpdate = !0
            }
            t.lookAt(Yd.setFromMatrixPosition(this.light.matrixWorld).negate())
          }
        }
        class Qd extends Wl {
          constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
            ;(n = new Ar(n)), (i = new Ar(i))
            const r = e / 2,
              s = t / e,
              o = t / 2,
              a = [],
              l = []
            for (let t = 0, c = 0, h = -o; t <= e; t++, h += s) {
              a.push(-o, 0, h, o, 0, h), a.push(h, 0, -o, h, 0, o)
              const e = t === r ? n : i
              e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3)
            }
            const c = new Qr()
            c.setAttribute('position', new Ur(a, 3)),
              c.setAttribute('color', new Ur(l, 3)),
              super(c, new Nl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'GridHelper')
          }
        }
        class $d extends Wl {
          constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
            ;(r = new Ar(r)), (s = new Ar(s))
            const o = [],
              a = []
            for (let n = 0; n <= e; n++) {
              const i = (n / e) * (2 * Math.PI),
                l = Math.sin(i) * t,
                c = Math.cos(i) * t
              o.push(0, 0, 0), o.push(l, 0, c)
              const h = 1 & n ? r : s
              a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
            }
            for (let e = 0; e <= n; e++) {
              const l = 1 & e ? r : s,
                c = t - (t / n) * e
              for (let t = 0; t < i; t++) {
                let e = (t / i) * (2 * Math.PI),
                  n = Math.sin(e) * c,
                  r = Math.cos(e) * c
                o.push(n, 0, r),
                  a.push(l.r, l.g, l.b),
                  (e = ((t + 1) / i) * (2 * Math.PI)),
                  (n = Math.sin(e) * c),
                  (r = Math.cos(e) * c),
                  o.push(n, 0, r),
                  a.push(l.r, l.g, l.b)
              }
            }
            const l = new Qr()
            l.setAttribute('position', new Ur(o, 3)),
              l.setAttribute('color', new Ur(a, 3)),
              super(l, new Nl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'PolarGridHelper')
          }
        }
        const tp = new ei(),
          ep = new ei(),
          np = new ei()
        class ip extends ir {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n),
              void 0 === e && (e = 1)
            let i = new Qr()
            i.setAttribute('position', new Ur([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3))
            const r = new Nl({ fog: !1, toneMapped: !1 })
            ;(this.lightPlane = new Hl(i, r)),
              this.add(this.lightPlane),
              (i = new Qr()),
              i.setAttribute('position', new Ur([0, 0, 0, 0, 0, 1], 3)),
              (this.targetLine = new Hl(i, r)),
              this.add(this.targetLine),
              this.update()
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose()
          }
          update() {
            tp.setFromMatrixPosition(this.light.matrixWorld),
              ep.setFromMatrixPosition(this.light.target.matrixWorld),
              np.subVectors(ep, tp),
              this.lightPlane.lookAt(ep),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(ep),
              (this.targetLine.scale.z = np.length())
          }
        }
        const rp = new ei(),
          sp = new Ms()
        class op extends Wl {
          constructor(t) {
            const e = new Qr(),
              n = new Nl({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              i = [],
              r = [],
              s = {},
              o = new Ar(16755200),
              a = new Ar(16711680),
              l = new Ar(43775),
              c = new Ar(16777215),
              h = new Ar(3355443)
            function u(t, e, n) {
              d(t, n), d(e, n)
            }
            function d(t, e) {
              i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1)
            }
            u('n1', 'n2', o),
              u('n2', 'n4', o),
              u('n4', 'n3', o),
              u('n3', 'n1', o),
              u('f1', 'f2', o),
              u('f2', 'f4', o),
              u('f4', 'f3', o),
              u('f3', 'f1', o),
              u('n1', 'f1', o),
              u('n2', 'f2', o),
              u('n3', 'f3', o),
              u('n4', 'f4', o),
              u('p', 'n1', a),
              u('p', 'n2', a),
              u('p', 'n3', a),
              u('p', 'n4', a),
              u('u1', 'u2', l),
              u('u2', 'u3', l),
              u('u3', 'u1', l),
              u('c', 't', c),
              u('p', 'c', h),
              u('cn1', 'cn2', h),
              u('cn3', 'cn4', h),
              u('cf1', 'cf2', h),
              u('cf3', 'cf4', h),
              e.setAttribute('position', new Ur(i, 3)),
              e.setAttribute('color', new Ur(r, 3)),
              super(e, n),
              (this.type = 'CameraHelper'),
              (this.camera = t),
              this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = s),
              this.update()
          }
          update() {
            const t = this.geometry,
              e = this.pointMap
            sp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
              ap('c', e, t, sp, 0, 0, -1),
              ap('t', e, t, sp, 0, 0, 1),
              ap('n1', e, t, sp, -1, -1, -1),
              ap('n2', e, t, sp, 1, -1, -1),
              ap('n3', e, t, sp, -1, 1, -1),
              ap('n4', e, t, sp, 1, 1, -1),
              ap('f1', e, t, sp, -1, -1, 1),
              ap('f2', e, t, sp, 1, -1, 1),
              ap('f3', e, t, sp, -1, 1, 1),
              ap('f4', e, t, sp, 1, 1, 1),
              ap('u1', e, t, sp, 0.7, 1.1, -1),
              ap('u2', e, t, sp, -0.7, 1.1, -1),
              ap('u3', e, t, sp, 0, 2, -1),
              ap('cf1', e, t, sp, -1, 0, 1),
              ap('cf2', e, t, sp, 1, 0, 1),
              ap('cf3', e, t, sp, 0, -1, 1),
              ap('cf4', e, t, sp, 0, 1, 1),
              ap('cn1', e, t, sp, -1, 0, -1),
              ap('cn2', e, t, sp, 1, 0, -1),
              ap('cn3', e, t, sp, 0, -1, -1),
              ap('cn4', e, t, sp, 0, 1, -1),
              (t.getAttribute('position').needsUpdate = !0)
          }
        }
        function ap(t, e, n, i, r, s, o) {
          rp.set(r, s, o).unproject(i)
          const a = e[t]
          if (void 0 !== a) {
            const t = n.getAttribute('position')
            for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], rp.x, rp.y, rp.z)
          }
        }
        const lp = new ri()
        class cp extends Wl {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
              i = new Float32Array(24),
              r = new Qr()
            r.setIndex(new Cr(n, 1)),
              r.setAttribute('position', new Cr(i, 3)),
              super(r, new Nl({ color: e, toneMapped: !1 })),
              (this.object = t),
              (this.type = 'BoxHelper'),
              (this.matrixAutoUpdate = !1),
              this.update()
          }
          update(t) {
            if (
              (void 0 !== t && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
              void 0 !== this.object && lp.setFromObject(this.object),
              lp.isEmpty())
            )
              return
            const e = lp.min,
              n = lp.max,
              i = this.geometry.attributes.position,
              r = i.array
            ;(r[0] = n.x),
              (r[1] = n.y),
              (r[2] = n.z),
              (r[3] = e.x),
              (r[4] = n.y),
              (r[5] = n.z),
              (r[6] = e.x),
              (r[7] = e.y),
              (r[8] = n.z),
              (r[9] = n.x),
              (r[10] = e.y),
              (r[11] = n.z),
              (r[12] = n.x),
              (r[13] = n.y),
              (r[14] = e.z),
              (r[15] = e.x),
              (r[16] = n.y),
              (r[17] = e.z),
              (r[18] = e.x),
              (r[19] = e.y),
              (r[20] = e.z),
              (r[21] = n.x),
              (r[22] = e.y),
              (r[23] = e.z),
              (i.needsUpdate = !0),
              this.geometry.computeBoundingSphere()
          }
          setFromObject(t) {
            return (this.object = t), this.update(), this
          }
          copy(t) {
            return Wl.prototype.copy.call(this, t), (this.object = t.object), this
          }
        }
        class hp extends Wl {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
              i = new Qr()
            i.setIndex(new Cr(n, 1)),
              i.setAttribute(
                'position',
                new Ur([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)
              ),
              super(i, new Nl({ color: e, toneMapped: !1 })),
              (this.box = t),
              (this.type = 'Box3Helper'),
              this.geometry.computeBoundingSphere()
          }
          updateMatrixWorld(t) {
            const e = this.box
            e.isEmpty() ||
              (e.getCenter(this.position),
              e.getSize(this.scale),
              this.scale.multiplyScalar(0.5),
              super.updateMatrixWorld(t))
          }
        }
        class up extends Hl {
          constructor(t, e = 1, n = 16776960) {
            const i = n,
              r = new Qr()
            r.setAttribute(
              'position',
              new Ur(
                [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                3
              )
            ),
              r.computeBoundingSphere(),
              super(r, new Nl({ color: i, toneMapped: !1 })),
              (this.type = 'PlaneHelper'),
              (this.plane = t),
              (this.size = e)
            const s = new Qr()
            s.setAttribute('position', new Ur([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)),
              s.computeBoundingSphere(),
              this.add(new gs(s, new Lr({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })))
          }
          updateMatrixWorld(t) {
            let e = -this.plane.constant
            Math.abs(e) < 1e-8 && (e = 1e-8),
              this.scale.set(0.5 * this.size, 0.5 * this.size, e),
              (this.children[0].material.side = e < 0 ? x : y),
              this.lookAt(this.plane.normal),
              super.updateMatrixWorld(t)
          }
        }
        const dp = new ei()
        let pp, mp
        class fp extends ir {
          constructor(t = new ei(0, 0, 1), e = new ei(0, 0, 0), n = 1, i = 16776960, r = 0.2 * n, s = 0.2 * r) {
            super(),
              (this.type = 'ArrowHelper'),
              void 0 === pp &&
                ((pp = new Qr()),
                pp.setAttribute('position', new Ur([0, 0, 0, 0, 1, 0], 3)),
                (mp = new rc(0, 0.5, 1, 5, 1)),
                mp.translate(0, -0.5, 0)),
              this.position.copy(e),
              (this.line = new Hl(pp, new Nl({ color: i, toneMapped: !1 }))),
              (this.line.matrixAutoUpdate = !1),
              this.add(this.line),
              (this.cone = new gs(mp, new Lr({ color: i, toneMapped: !1 }))),
              (this.cone.matrixAutoUpdate = !1),
              this.add(this.cone),
              this.setDirection(t),
              this.setLength(n, r, s)
          }
          setDirection(t) {
            if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
            else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
            else {
              dp.set(t.z, 0, -t.x).normalize()
              const e = Math.acos(t.y)
              this.quaternion.setFromAxisAngle(dp, e)
            }
          }
          setLength(t, e = 0.2 * t, n = 0.2 * e) {
            this.line.scale.set(1, Math.max(1e-4, t - e), 1),
              this.line.updateMatrix(),
              this.cone.scale.set(n, e, n),
              (this.cone.position.y = t),
              this.cone.updateMatrix()
          }
          setColor(t) {
            this.line.material.color.set(t), this.cone.material.color.set(t)
          }
          copy(t) {
            return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
          }
        }
        class gp extends Wl {
          constructor(t = 1) {
            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              n = new Qr()
            n.setAttribute('position', new Ur(e, 3)),
              n.setAttribute('color', new Ur([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)),
              super(n, new Nl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'AxesHelper')
          }
        }
        const vp = new Float32Array(1),
          yp = new Int32Array(vp.buffer),
          xp = {
            toHalfFloat: function (t) {
              vp[0] = t
              const e = yp[0]
              let n = (e >> 16) & 32768,
                i = (e >> 12) & 2047
              const r = (e >> 23) & 255
              return r < 103
                ? n
                : r > 142
                ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)
                : r < 113
                ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)
                : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n)
            }
          },
          bp = Math.pow(2, 8),
          wp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          _p = 5 + wp.length,
          Mp = { [tn]: 0, [en]: 1, [rn]: 2, [on]: 3, [an]: 4, [ln]: 5, [nn]: 6 },
          Tp = new Lr({ side: x, depthWrite: !1, depthTest: !1 }),
          Sp = new gs(new ys(), Tp),
          Ep = new _u(),
          { _lodPlanes: Ap, _sizeLods: Lp, _sigmas: Rp } = zp(),
          Pp = new Ar()
        let Cp = null
        const Ip = (1 + Math.sqrt(5)) / 2,
          Dp = 1 / Ip,
          Op = [
            new ei(1, 1, 1),
            new ei(-1, 1, 1),
            new ei(1, 1, -1),
            new ei(-1, 1, -1),
            new ei(0, Ip, Dp),
            new ei(0, Ip, -Dp),
            new ei(Dp, 0, Ip),
            new ei(-Dp, 0, Ip),
            new ei(Ip, Dp, 0),
            new ei(-Ip, Dp, 0)
          ]
        function Np(t) {
          const e = Math.max(t.r, t.g, t.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127)
          return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255
        }
        class Bp {
          constructor(t) {
            ;(this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._blurMaterial = (function (t) {
                const e = new Float32Array(20),
                  n = new ei(0, 1, 0)
                return new ih({
                  name: 'SphericalGaussianBlur',
                  defines: { n: 20 },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: e },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: n },
                    inputEncoding: { value: Mp[tn] },
                    outputEncoding: { value: Mp[tn] }
                  },
                  vertexShader:
                    '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                  blending: M,
                  depthTest: !1,
                  depthWrite: !1
                })
              })()),
              (this._equirectShader = null),
              (this._cubemapShader = null),
              this._compileMaterial(this._blurMaterial)
          }
          fromScene(t, e = 0, n = 0.1, i = 100) {
            Cp = this._renderer.getRenderTarget()
            const r = this._allocateTargets()
            return (
              this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            )
          }
          fromEquirectangular(t) {
            return this._fromTexture(t)
          }
          fromCubemap(t) {
            return this._fromTexture(t)
          }
          compileCubemapShader() {
            null === this._cubemapShader && ((this._cubemapShader = Gp()), this._compileMaterial(this._cubemapShader))
          }
          compileEquirectangularShader() {
            null === this._equirectShader &&
              ((this._equirectShader = Hp()), this._compileMaterial(this._equirectShader))
          }
          dispose() {
            this._blurMaterial.dispose(),
              null !== this._cubemapShader && this._cubemapShader.dispose(),
              null !== this._equirectShader && this._equirectShader.dispose()
            for (let t = 0; t < Ap.length; t++) Ap[t].dispose()
          }
          _cleanup(t) {
            this._pingPongRenderTarget.dispose(),
              this._renderer.setRenderTarget(Cp),
              (t.scissorTest = !1),
              Up(t, 0, 0, t.width, t.height)
          }
          _fromTexture(t) {
            Cp = this._renderer.getRenderTarget()
            const e = this._allocateTargets(t)
            return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
          }
          _allocateTargets(t) {
            const e = {
                magFilter: yt,
                minFilter: yt,
                generateMipmaps: !1,
                type: Lt,
                format: jt,
                encoding: Fp(t) ? t.encoding : rn,
                depthBuffer: !1
              },
              n = kp(e)
            return (n.depthBuffer = !t), (this._pingPongRenderTarget = kp(e)), n
          }
          _compileMaterial(t) {
            const e = new gs(Ap[0], t)
            this._renderer.compile(e, Ep)
          }
          _sceneToCubeUV(t, e, n, i) {
            const r = new Ts(90, 1, e, n),
              s = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              a = this._renderer,
              l = a.autoClear,
              c = a.outputEncoding,
              h = a.toneMapping
            a.getClearColor(Pp), (a.toneMapping = nt), (a.outputEncoding = tn), (a.autoClear = !1)
            let u = !1
            const d = t.background
            if (d) {
              if (d.isColor) {
                Tp.color.copy(d).convertSRGBToLinear(), (t.background = null)
                const e = Np(Tp.color)
                ;(Tp.opacity = e), (u = !0)
              }
            } else {
              Tp.color.copy(Pp).convertSRGBToLinear()
              const t = Np(Tp.color)
              ;(Tp.opacity = t), (u = !0)
            }
            for (let e = 0; e < 6; e++) {
              const n = e % 3
              0 == n
                ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
                : 1 == n
                ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
                : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])),
                Up(i, n * bp, e > 2 ? bp : 0, bp, bp),
                a.setRenderTarget(i),
                u && a.render(Sp, r),
                a.render(t, r)
            }
            ;(a.toneMapping = h), (a.outputEncoding = c), (a.autoClear = l)
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer
            t.isCubeTexture
              ? null == this._cubemapShader && (this._cubemapShader = Gp())
              : null == this._equirectShader && (this._equirectShader = Hp())
            const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
              r = new gs(Ap[0], i),
              s = i.uniforms
            ;(s.envMap.value = t),
              t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
              (s.inputEncoding.value = Mp[t.encoding]),
              (s.outputEncoding.value = Mp[e.texture.encoding]),
              Up(e, 0, 0, 3 * bp, 2 * bp),
              n.setRenderTarget(e),
              n.render(r, Ep)
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear
            e.autoClear = !1
            for (let e = 1; e < _p; e++) {
              const n = Math.sqrt(Rp[e] * Rp[e] - Rp[e - 1] * Rp[e - 1]),
                i = Op[(e - 1) % Op.length]
              this._blur(t, e - 1, e, n, i)
            }
            e.autoClear = n
          }
          _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget
            this._halfBlur(t, s, e, n, i, 'latitudinal', r), this._halfBlur(s, t, n, n, i, 'longitudinal', r)
          }
          _halfBlur(t, e, n, i, r, s, o) {
            const a = this._renderer,
              l = this._blurMaterial
            'latitudinal' !== s &&
              'longitudinal' !== s &&
              console.error('blur direction must be either latitudinal or longitudinal!')
            const c = new gs(Ap[i], l),
              h = l.uniforms,
              u = Lp[n] - 1,
              d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
              p = r / d,
              m = isFinite(r) ? 1 + Math.floor(3 * p) : 20
            m > 20 &&
              console.warn(
                `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
              )
            const f = []
            let g = 0
            for (let t = 0; t < 20; ++t) {
              const e = t / p,
                n = Math.exp((-e * e) / 2)
              f.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n)
            }
            for (let t = 0; t < f.length; t++) f[t] = f[t] / g
            ;(h.envMap.value = t.texture),
              (h.samples.value = m),
              (h.weights.value = f),
              (h.latitudinal.value = 'latitudinal' === s),
              o && (h.poleAxis.value = o),
              (h.dTheta.value = d),
              (h.mipInt.value = 8 - n),
              (h.inputEncoding.value = Mp[t.texture.encoding]),
              (h.outputEncoding.value = Mp[t.texture.encoding])
            const v = Lp[i]
            Up(e, 3 * Math.max(0, bp - 2 * v), (0 === i ? 0 : 2 * bp) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v),
              a.setRenderTarget(e),
              a.render(c, Ep)
          }
        }
        function Fp(t) {
          return void 0 !== t && t.type === Lt && (t.encoding === tn || t.encoding === en || t.encoding === nn)
        }
        function zp() {
          const t = [],
            e = [],
            n = []
          let i = 8
          for (let r = 0; r < _p; r++) {
            const s = Math.pow(2, i)
            e.push(s)
            let o = 1 / s
            r > 4 ? (o = wp[r - 8 + 4 - 1]) : 0 == r && (o = 0), n.push(o)
            const a = 1 / (s - 1),
              l = -a / 2,
              c = 1 + a / 2,
              h = [l, l, c, l, c, c, l, l, c, c, l, c],
              u = 6,
              d = 6,
              p = 3,
              m = 2,
              f = 1,
              g = new Float32Array(p * d * u),
              v = new Float32Array(m * d * u),
              y = new Float32Array(f * d * u)
            for (let t = 0; t < u; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]
              g.set(i, p * d * t), v.set(h, m * d * t)
              const r = [t, t, t, t, t, t]
              y.set(r, f * d * t)
            }
            const x = new Qr()
            x.setAttribute('position', new Cr(g, p)),
              x.setAttribute('uv', new Cr(v, m)),
              x.setAttribute('faceIndex', new Cr(y, f)),
              t.push(x),
              i > 4 && i--
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
        }
        function kp(t) {
          const e = new Qn(3 * bp, 3 * bp, t)
          return (e.texture.mapping = pt), (e.texture.name = 'PMREM.cubeUv'), (e.scissorTest = !0), e
        }
        function Up(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
        }
        function Hp() {
          const t = new Wn(1, 1)
          return new ih({
            name: 'EquirectangularToCubeUV',
            uniforms: {
              envMap: { value: null },
              texelSize: { value: t },
              inputEncoding: { value: Mp[tn] },
              outputEncoding: { value: Mp[tn] }
            },
            vertexShader:
              '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
            fragmentShader:
              '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
            blending: M,
            depthTest: !1,
            depthWrite: !1
          })
        }
        function Gp() {
          return new ih({
            name: 'CubemapToCubeUV',
            uniforms: { envMap: { value: null }, inputEncoding: { value: Mp[tn] }, outputEncoding: { value: Mp[tn] } },
            vertexShader:
              '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
            fragmentShader:
              '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
            blending: M,
            depthTest: !1,
            depthWrite: !1
          })
        }
        const Vp = 0,
          Wp = 1,
          jp = 0,
          qp = 1,
          Xp = 2
        function Yp(t) {
          return console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.'), t
        }
        function Zp(t = []) {
          return (
            console.warn('THREE.MultiMaterial has been removed. Use an Array instead.'),
            (t.isMultiMaterial = !0),
            (t.materials = t),
            (t.clone = function () {
              return t.slice()
            }),
            t
          )
        }
        function Jp(t, e) {
          return console.warn('THREE.PointCloud has been renamed to THREE.Points.'), new Kl(t, e)
        }
        function Kp(t) {
          return console.warn('THREE.Particle has been renamed to THREE.Sprite.'), new fl(t)
        }
        function Qp(t, e) {
          return console.warn('THREE.ParticleSystem has been renamed to THREE.Points.'), new Kl(t, e)
        }
        function $p(t) {
          return console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.'), new ql(t)
        }
        function tm(t) {
          return console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.'), new ql(t)
        }
        function em(t) {
          return console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.'), new ql(t)
        }
        function nm(t, e, n) {
          return console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.'), new ei(t, e, n)
        }
        function im(t, e) {
          return (
            console.warn(
              'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.'
            ),
            new Cr(t, e).setUsage(Pn)
          )
        }
        function rm(t, e) {
          return (
            console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.'),
            new Ir(t, e)
          )
        }
        function sm(t, e) {
          return (
            console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.'),
            new Dr(t, e)
          )
        }
        function om(t, e) {
          return (
            console.warn(
              'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.'
            ),
            new Or(t, e)
          )
        }
        function am(t, e) {
          return (
            console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.'),
            new Nr(t, e)
          )
        }
        function lm(t, e) {
          return (
            console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.'),
            new Br(t, e)
          )
        }
        function cm(t, e) {
          return (
            console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.'),
            new Fr(t, e)
          )
        }
        function hm(t, e) {
          return (
            console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.'),
            new zr(t, e)
          )
        }
        function um(t, e) {
          return (
            console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.'),
            new Ur(t, e)
          )
        }
        function dm(t, e) {
          return (
            console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.'),
            new Hr(t, e)
          )
        }
        function pm(t) {
          return console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.'), new gp(t)
        }
        function mm(t, e) {
          return (
            console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.'),
            new cp(t, e)
          )
        }
        function fm(t, e) {
          return (
            console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.'),
            new Wl(new dc(t.geometry), new Nl({ color: void 0 !== e ? e : 16777215 }))
          )
        }
        function gm(t, e) {
          return (
            console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.'),
            new Wl(new th(t.geometry), new Nl({ color: void 0 !== e ? e : 16777215 }))
          )
        }
        function vm(t) {
          return console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.'), new Dh(t)
        }
        function ym(t) {
          return console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.'), new zh(t)
        }
        function xm(t, e, n) {
          return (
            console.warn(
              'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).'
            ),
            new Ls(t, n)
          )
        }
        function bm() {
          console.error('THREE.CanvasRenderer has been removed')
        }
        function wm() {
          console.error('THREE.JSONLoader has been removed.')
        }
        ;(Uh.create = function (t, e) {
          return (
            console.log('THREE.Curve.create() has been deprecated'),
            (t.prototype = Object.create(Uh.prototype)),
            (t.prototype.constructor = t),
            (t.prototype.getPoint = e),
            t
          )
        }),
          (au.prototype.fromPoints = function (t) {
            return (
              console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'), this.setFromPoints(t)
            )
          }),
          (Qd.prototype.setColors = function () {
            console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.')
          }),
          (jd.prototype.update = function () {
            console.error('THREE.SkeletonHelper: update() no longer needs to be called.')
          }),
          (Ch.prototype.extractUrlBase = function (t) {
            return (
              console.warn(
                'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.'
              ),
              Pu.extractUrlBase(t)
            )
          }),
          (Ch.Handlers = {
            add: function () {
              console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.')
            },
            get: function () {
              console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.')
            }
          }),
          (Nd.prototype.center = function (t) {
            return console.warn('THREE.Box2: .center() has been renamed to .getCenter().'), this.getCenter(t)
          }),
          (Nd.prototype.empty = function () {
            return console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'), this.isEmpty()
          }),
          (Nd.prototype.isIntersectionBox = function (t) {
            return (
              console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().'),
              this.intersectsBox(t)
            )
          }),
          (Nd.prototype.size = function (t) {
            return console.warn('THREE.Box2: .size() has been renamed to .getSize().'), this.getSize(t)
          }),
          (ri.prototype.center = function (t) {
            return console.warn('THREE.Box3: .center() has been renamed to .getCenter().'), this.getCenter(t)
          }),
          (ri.prototype.empty = function () {
            return console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'), this.isEmpty()
          }),
          (ri.prototype.isIntersectionBox = function (t) {
            return (
              console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'),
              this.intersectsBox(t)
            )
          }),
          (ri.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
              this.intersectsSphere(t)
            )
          }),
          (ri.prototype.size = function (t) {
            return console.warn('THREE.Box3: .size() has been renamed to .getSize().'), this.getSize(t)
          }),
          (Mi.prototype.empty = function () {
            return console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().'), this.isEmpty()
          }),
          (Is.prototype.setFromMatrix = function (t) {
            return (
              console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().'),
              this.setFromProjectionMatrix(t)
            )
          }),
          (zd.prototype.center = function (t) {
            return console.warn('THREE.Line3: .center() has been renamed to .getCenter().'), this.getCenter(t)
          }),
          (Vn.random16 = function () {
            return (
              console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.'), Math.random()
            )
          }),
          (Vn.nearestPowerOfTwo = function (t) {
            return (
              console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().'),
              Vn.floorPowerOfTwo(t)
            )
          }),
          (Vn.nextPowerOfTwo = function (t) {
            return (
              console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().'), Vn.ceilPowerOfTwo(t)
            )
          }),
          (jn.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'),
              this.toArray(t, e)
            )
          }),
          (jn.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
              ),
              t.applyMatrix3(this)
            )
          }),
          (jn.prototype.multiplyVector3Array = function () {
            console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.')
          }),
          (jn.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.'
              ),
              t.applyMatrix3(this)
            )
          }),
          (jn.prototype.applyToVector3Array = function () {
            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.')
          }),
          (jn.prototype.getInverse = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
              ),
              this.copy(t).invert()
            )
          }),
          (Ii.prototype.extractPosition = function (t) {
            return (
              console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'),
              this.copyPosition(t)
            )
          }),
          (Ii.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'),
              this.toArray(t, e)
            )
          }),
          (Ii.prototype.getPosition = function () {
            return (
              console.warn(
                'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
              ),
              new ei().setFromMatrixColumn(this, 3)
            )
          }),
          (Ii.prototype.setRotationFromQuaternion = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
              ),
              this.makeRotationFromQuaternion(t)
            )
          }),
          (Ii.prototype.multiplyToArray = function () {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.')
          }),
          (Ii.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
              ),
              t.applyMatrix4(this)
            )
          }),
          (Ii.prototype.multiplyVector4 = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
              ),
              t.applyMatrix4(this)
            )
          }),
          (Ii.prototype.multiplyVector3Array = function () {
            console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.')
          }),
          (Ii.prototype.rotateAxis = function (t) {
            console.warn(
              'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
            ),
              t.transformDirection(this)
          }),
          (Ii.prototype.crossVector = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'
              ),
              t.applyMatrix4(this)
            )
          }),
          (Ii.prototype.translate = function () {
            console.error('THREE.Matrix4: .translate() has been removed.')
          }),
          (Ii.prototype.rotateX = function () {
            console.error('THREE.Matrix4: .rotateX() has been removed.')
          }),
          (Ii.prototype.rotateY = function () {
            console.error('THREE.Matrix4: .rotateY() has been removed.')
          }),
          (Ii.prototype.rotateZ = function () {
            console.error('THREE.Matrix4: .rotateZ() has been removed.')
          }),
          (Ii.prototype.rotateByAxis = function () {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.')
          }),
          (Ii.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.'
              ),
              t.applyMatrix4(this)
            )
          }),
          (Ii.prototype.applyToVector3Array = function () {
            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.')
          }),
          (Ii.prototype.makeFrustum = function (t, e, n, i, r, s) {
            return (
              console.warn(
                'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
              ),
              this.makePerspective(t, e, i, n, r, s)
            )
          }),
          (Ii.prototype.getInverse = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
              ),
              this.copy(t).invert()
            )
          }),
          (ar.prototype.isIntersectionLine = function (t) {
            return (
              console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'),
              this.intersectsLine(t)
            )
          }),
          (ti.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
              ),
              t.applyQuaternion(this)
            )
          }),
          (ti.prototype.inverse = function () {
            return console.warn('THREE.Quaternion: .inverse() has been renamed to invert().'), this.invert()
          }),
          (Ci.prototype.isIntersectionBox = function (t) {
            return (
              console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'),
              this.intersectsBox(t)
            )
          }),
          (Ci.prototype.isIntersectionPlane = function (t) {
            return (
              console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'),
              this.intersectsPlane(t)
            )
          }),
          (Ci.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
              this.intersectsSphere(t)
            )
          }),
          (yr.prototype.area = function () {
            return console.warn('THREE.Triangle: .area() has been renamed to .getArea().'), this.getArea()
          }),
          (yr.prototype.barycoordFromPoint = function (t, e) {
            return (
              console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
              this.getBarycoord(t, e)
            )
          }),
          (yr.prototype.midpoint = function (t) {
            return console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'), this.getMidpoint(t)
          }),
          (yr.prototypenormal = function (t) {
            return console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'), this.getNormal(t)
          }),
          (yr.prototype.plane = function (t) {
            return console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().'), this.getPlane(t)
          }),
          (yr.barycoordFromPoint = function (t, e, n, i, r) {
            return (
              console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
              yr.getBarycoord(t, e, n, i, r)
            )
          }),
          (yr.normal = function (t, e, n, i) {
            return console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'), yr.getNormal(t, e, n, i)
          }),
          (lu.prototype.extractAllPoints = function (t) {
            return (
              console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'),
              this.extractPoints(t)
            )
          }),
          (lu.prototype.extrude = function (t) {
            return (
              console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'), new Uc(this, t)
            )
          }),
          (lu.prototype.makeGeometry = function (t) {
            return (
              console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'),
              new Xc(this, t)
            )
          }),
          (Wn.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'),
              this.fromBufferAttribute(t, e, n)
            )
          }),
          (Wn.prototype.distanceToManhattan = function (t) {
            return (
              console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'),
              this.manhattanDistanceTo(t)
            )
          }),
          (Wn.prototype.lengthManhattan = function () {
            return (
              console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'),
              this.manhattanLength()
            )
          }),
          (ei.prototype.setEulerFromRotationMatrix = function () {
            console.error(
              'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
            )
          }),
          (ei.prototype.setEulerFromQuaternion = function () {
            console.error(
              'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
            )
          }),
          (ei.prototype.getPositionFromMatrix = function (t) {
            return (
              console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'),
              this.setFromMatrixPosition(t)
            )
          }),
          (ei.prototype.getScaleFromMatrix = function (t) {
            return (
              console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'),
              this.setFromMatrixScale(t)
            )
          }),
          (ei.prototype.getColumnFromMatrix = function (t, e) {
            return (
              console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'),
              this.setFromMatrixColumn(e, t)
            )
          }),
          (ei.prototype.applyProjection = function (t) {
            return (
              console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'),
              this.applyMatrix4(t)
            )
          }),
          (ei.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'),
              this.fromBufferAttribute(t, e, n)
            )
          }),
          (ei.prototype.distanceToManhattan = function (t) {
            return (
              console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'),
              this.manhattanDistanceTo(t)
            )
          }),
          (ei.prototype.lengthManhattan = function () {
            return (
              console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'),
              this.manhattanLength()
            )
          }),
          (Kn.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'),
              this.fromBufferAttribute(t, e, n)
            )
          }),
          (Kn.prototype.lengthManhattan = function () {
            return (
              console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'),
              this.manhattanLength()
            )
          }),
          (ir.prototype.getChildByName = function (t) {
            return (
              console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'),
              this.getObjectByName(t)
            )
          }),
          (ir.prototype.renderDepth = function () {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.')
          }),
          (ir.prototype.translate = function (t, e) {
            return (
              console.warn(
                'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
              ),
              this.translateOnAxis(e, t)
            )
          }),
          (ir.prototype.getWorldRotation = function () {
            console.error(
              'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.'
            )
          }),
          (ir.prototype.applyMatrix = function (t) {
            return (
              console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().'), this.applyMatrix4(t)
            )
          }),
          Object.defineProperties(ir.prototype, {
            eulerOrder: {
              get: function () {
                return console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), this.rotation.order
              },
              set: function (t) {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), (this.rotation.order = t)
              }
            },
            useQuaternion: {
              get: function () {
                console.warn(
                  'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
                )
              },
              set: function () {
                console.warn(
                  'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
                )
              }
            }
          }),
          (gs.prototype.setDrawMode = function () {
            console.error(
              'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
            )
          }),
          Object.defineProperties(gs.prototype, {
            drawMode: {
              get: function () {
                return (
                  console.error(
                    'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.'
                  ),
                  Ke
                )
              },
              set: function () {
                console.error(
                  'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
                )
              }
            }
          }),
          (Sl.prototype.initBones = function () {
            console.error('THREE.SkinnedMesh: initBones() has been removed.')
          }),
          Object.defineProperty(Uh.prototype, '__arcLengthDivisions', {
            get: function () {
              return (
                console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'), this.arcLengthDivisions
              )
            },
            set: function (t) {
              console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
                (this.arcLengthDivisions = t)
            }
          }),
          (Ts.prototype.setLens = function (t, e) {
            console.warn(
              'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
            ),
              void 0 !== e && (this.filmGauge = e),
              this.setFocalLength(t)
          }),
          Object.defineProperties(cu.prototype, {
            onlyShadow: {
              set: function () {
                console.warn('THREE.Light: .onlyShadow has been removed.')
              }
            },
            shadowCameraFov: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'), (this.shadow.camera.fov = t)
              }
            },
            shadowCameraLeft: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'),
                  (this.shadow.camera.left = t)
              }
            },
            shadowCameraRight: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
                  (this.shadow.camera.right = t)
              }
            },
            shadowCameraTop: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'), (this.shadow.camera.top = t)
              }
            },
            shadowCameraBottom: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
                  (this.shadow.camera.bottom = t)
              }
            },
            shadowCameraNear: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'),
                  (this.shadow.camera.near = t)
              }
            },
            shadowCameraFar: {
              set: function (t) {
                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'), (this.shadow.camera.far = t)
              }
            },
            shadowCameraVisible: {
              set: function () {
                console.warn(
                  'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
                )
              }
            },
            shadowBias: {
              set: function (t) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.'), (this.shadow.bias = t)
              }
            },
            shadowDarkness: {
              set: function () {
                console.warn('THREE.Light: .shadowDarkness has been removed.')
              }
            },
            shadowMapWidth: {
              set: function (t) {
                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'),
                  (this.shadow.mapSize.width = t)
              }
            },
            shadowMapHeight: {
              set: function (t) {
                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
                  (this.shadow.mapSize.height = t)
              }
            }
          }),
          Object.defineProperties(Cr.prototype, {
            length: {
              get: function () {
                return (
                  console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.'),
                  this.array.length
                )
              }
            },
            dynamic: {
              get: function () {
                return (
                  console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'),
                  this.usage === Pn
                )
              },
              set: function () {
                console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'),
                  this.setUsage(Pn)
              }
            }
          }),
          (Cr.prototype.setDynamic = function (t) {
            return (
              console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.'),
              this.setUsage(!0 === t ? Pn : Rn),
              this
            )
          }),
          (Cr.prototype.copyIndicesArray = function () {
            console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.')
          }),
          (Cr.prototype.setArray = function () {
            console.error(
              'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
            )
          }),
          (Qr.prototype.addIndex = function (t) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'), this.setIndex(t)
          }),
          (Qr.prototype.addAttribute = function (t, e) {
            return (
              console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().'),
              (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
                ? 'index' === t
                  ? (console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'),
                    this.setIndex(e),
                    this)
                  : this.setAttribute(t, e)
                : (console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),
                  this.setAttribute(t, new Cr(arguments[1], arguments[2])))
            )
          }),
          (Qr.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n && console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'),
              console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
              this.addGroup(t, e)
          }),
          (Qr.prototype.clearDrawCalls = function () {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'), this.clearGroups()
          }),
          (Qr.prototype.computeOffsets = function () {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.')
          }),
          (Qr.prototype.removeAttribute = function (t) {
            return (
              console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().'),
              this.deleteAttribute(t)
            )
          }),
          (Qr.prototype.applyMatrix = function (t) {
            return (
              console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().'),
              this.applyMatrix4(t)
            )
          }),
          Object.defineProperties(Qr.prototype, {
            drawcalls: {
              get: function () {
                return console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.'), this.groups
              }
            },
            offsets: {
              get: function () {
                return console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'), this.groups
              }
            }
          }),
          Object.defineProperties(Cu.prototype, {
            maxInstancedCount: {
              get: function () {
                return (
                  console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.'),
                  this.instanceCount
                )
              },
              set: function (t) {
                console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.'),
                  (this.instanceCount = t)
              }
            }
          }),
          Object.defineProperties(Rd.prototype, {
            linePrecision: {
              get: function () {
                return (
                  console.warn(
                    'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.'
                  ),
                  this.params.Line.threshold
                )
              },
              set: function (t) {
                console.warn(
                  'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.'
                ),
                  (this.params.Line.threshold = t)
              }
            }
          }),
          Object.defineProperties(Qa.prototype, {
            dynamic: {
              get: function () {
                return (
                  console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.'),
                  this.usage === Pn
                )
              },
              set: function (t) {
                console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.'),
                  this.setUsage(t)
              }
            }
          }),
          (Qa.prototype.setDynamic = function (t) {
            return (
              console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.'),
              this.setUsage(!0 === t ? Pn : Rn),
              this
            )
          }),
          (Qa.prototype.setArray = function () {
            console.error(
              'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
            )
          }),
          (Uc.prototype.getArrays = function () {
            console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.')
          }),
          (Uc.prototype.addShapeList = function () {
            console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.')
          }),
          (Uc.prototype.addShape = function () {
            console.error('THREE.ExtrudeGeometry: .addShape() has been removed.')
          }),
          (Ka.prototype.dispose = function () {
            console.error('THREE.Scene: .dispose() has been removed.')
          }),
          (Ed.prototype.onUpdate = function () {
            return (
              console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.'), this
            )
          }),
          Object.defineProperties(br.prototype, {
            wrapAround: {
              get: function () {
                console.warn('THREE.Material: .wrapAround has been removed.')
              },
              set: function () {
                console.warn('THREE.Material: .wrapAround has been removed.')
              }
            },
            overdraw: {
              get: function () {
                console.warn('THREE.Material: .overdraw has been removed.')
              },
              set: function () {
                console.warn('THREE.Material: .overdraw has been removed.')
              }
            },
            wrapRGB: {
              get: function () {
                return console.warn('THREE.Material: .wrapRGB has been removed.'), new Ar()
              }
            },
            shading: {
              get: function () {
                console.error(
                  'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.'
                )
              },
              set: function (t) {
                console.warn(
                  'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.'
                ),
                  (this.flatShading = t === w)
              }
            },
            stencilMask: {
              get: function () {
                return (
                  console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.'),
                  this.stencilFuncMask
                )
              },
              set: function (t) {
                console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.'),
                  (this.stencilFuncMask = t)
              }
            }
          }),
          Object.defineProperties(sh.prototype, {
            transparency: {
              get: function () {
                return (
                  console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.'),
                  this.transmission
                )
              },
              set: function (t) {
                console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.'),
                  (this.transmission = t)
              }
            }
          }),
          Object.defineProperties(_s.prototype, {
            derivatives: {
              get: function () {
                return (
                  console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'),
                  this.extensions.derivatives
                )
              },
              set: function (t) {
                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'),
                  (this.extensions.derivatives = t)
              }
            }
          }),
          (Xa.prototype.clearTarget = function (t, e, n, i) {
            console.warn(
              'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.'
            ),
              this.setRenderTarget(t),
              this.clear(e, n, i)
          }),
          (Xa.prototype.animate = function (t) {
            console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'), this.setAnimationLoop(t)
          }),
          (Xa.prototype.getCurrentRenderTarget = function () {
            return (
              console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'),
              this.getRenderTarget()
            )
          }),
          (Xa.prototype.getMaxAnisotropy = function () {
            return (
              console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'),
              this.capabilities.getMaxAnisotropy()
            )
          }),
          (Xa.prototype.getPrecision = function () {
            return (
              console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'),
              this.capabilities.precision
            )
          }),
          (Xa.prototype.resetGLState = function () {
            return console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'), this.state.reset()
          }),
          (Xa.prototype.supportsFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get('OES_texture_float')
            )
          }),
          (Xa.prototype.supportsHalfFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get('OES_texture_half_float')
            )
          }),
          (Xa.prototype.supportsStandardDerivatives = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get('OES_standard_derivatives')
            )
          }),
          (Xa.prototype.supportsCompressedTextureS3TC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get('WEBGL_compressed_texture_s3tc')
            )
          }),
          (Xa.prototype.supportsCompressedTexturePVRTC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get('WEBGL_compressed_texture_pvrtc')
            )
          }),
          (Xa.prototype.supportsBlendMinMax = function () {
            return (
              console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
              this.extensions.get('EXT_blend_minmax')
            )
          }),
          (Xa.prototype.supportsVertexTextures = function () {
            return (
              console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'),
              this.capabilities.vertexTextures
            )
          }),
          (Xa.prototype.supportsInstancedArrays = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get('ANGLE_instanced_arrays')
            )
          }),
          (Xa.prototype.enableScissorTest = function (t) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'), this.setScissorTest(t)
          }),
          (Xa.prototype.initMaterial = function () {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.')
          }),
          (Xa.prototype.addPrePlugin = function () {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.')
          }),
          (Xa.prototype.addPostPlugin = function () {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.')
          }),
          (Xa.prototype.updateShadowMap = function () {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.')
          }),
          (Xa.prototype.setFaceCulling = function () {
            console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.')
          }),
          (Xa.prototype.allocTextureUnit = function () {
            console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.')
          }),
          (Xa.prototype.setTexture = function () {
            console.warn('THREE.WebGLRenderer: .setTexture() has been removed.')
          }),
          (Xa.prototype.setTexture2D = function () {
            console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.')
          }),
          (Xa.prototype.setTextureCube = function () {
            console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.')
          }),
          (Xa.prototype.getActiveMipMapLevel = function () {
            return (
              console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().'),
              this.getActiveMipmapLevel()
            )
          }),
          Object.defineProperties(Xa.prototype, {
            shadowMapEnabled: {
              get: function () {
                return this.shadowMap.enabled
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'),
                  (this.shadowMap.enabled = t)
              }
            },
            shadowMapType: {
              get: function () {
                return this.shadowMap.type
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'), (this.shadowMap.type = t)
              }
            },
            shadowMapCullFace: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
                )
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
                )
              }
            },
            context: {
              get: function () {
                return (
                  console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.'),
                  this.getContext()
                )
              }
            },
            vr: {
              get: function () {
                return console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr'), this.xr
              }
            },
            gammaInput: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
                  ),
                  !1
                )
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
                )
              }
            },
            gammaOutput: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
                  ),
                  !1
                )
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
                ),
                  (this.outputEncoding = !0 === t ? en : tn)
              }
            },
            toneMappingWhitePoint: {
              get: function () {
                return console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'), 1
              },
              set: function () {
                console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.')
              }
            }
          }),
          Object.defineProperties(za.prototype, {
            cullFace: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
                )
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
                )
              }
            },
            renderReverseSided: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
                )
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
                )
              }
            },
            renderSingleSided: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
                )
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
                )
              }
            }
          }),
          Object.defineProperties(Qn.prototype, {
            wrapS: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'), this.texture.wrapS
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'), (this.texture.wrapS = t)
              }
            },
            wrapT: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'), this.texture.wrapT
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'), (this.texture.wrapT = t)
              }
            },
            magFilter: {
              get: function () {
                return (
                  console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'), this.texture.magFilter
                )
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
                  (this.texture.magFilter = t)
              }
            },
            minFilter: {
              get: function () {
                return (
                  console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'), this.texture.minFilter
                )
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
                  (this.texture.minFilter = t)
              }
            },
            anisotropy: {
              get: function () {
                return (
                  console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                  this.texture.anisotropy
                )
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
                  (this.texture.anisotropy = t)
              }
            },
            offset: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'), this.texture.offset
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'), (this.texture.offset = t)
              }
            },
            repeat: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'), this.texture.repeat
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'), (this.texture.repeat = t)
              }
            },
            format: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'), this.texture.format
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'), (this.texture.format = t)
              }
            },
            type: {
              get: function () {
                return console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), this.texture.type
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), (this.texture.type = t)
              }
            },
            generateMipmaps: {
              get: function () {
                return (
                  console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
                  this.texture.generateMipmaps
                )
              },
              set: function (t) {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
                  (this.texture.generateMipmaps = t)
              }
            }
          }),
          (rd.prototype.load = function (t) {
            console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.')
            const e = this
            return (
              new ju().load(t, function (t) {
                e.setBuffer(t)
              }),
              this
            )
          }),
          (hd.prototype.getData = function () {
            return console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().'), this.getFrequencyData()
          }),
          (Es.prototype.updateCubeMap = function (t, e) {
            return console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'), this.update(t, e)
          }),
          (Es.prototype.clear = function (t, e, n, i) {
            return (
              console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().'),
              this.renderTarget.clear(t, e, n, i)
            )
          }),
          (Xn.crossOrigin = void 0),
          (Xn.loadTexture = function (t, e, n, i) {
            console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.')
            const r = new kh()
            r.setCrossOrigin(this.crossOrigin)
            const s = r.load(t, n, void 0, i)
            return e && (s.mapping = e), s
          }),
          (Xn.loadTextureCube = function (t, e, n, i) {
            console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.')
            const r = new Fh()
            r.setCrossOrigin(this.crossOrigin)
            const s = r.load(t, n, void 0, i)
            return e && (s.mapping = e), s
          }),
          (Xn.loadCompressedTexture = function () {
            console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.')
          }),
          (Xn.loadCompressedTextureCube = function () {
            console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.')
          })
        const _m = {
          createMultiMaterialObject: function () {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')
          },
          detach: function () {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')
          },
          attach: function () {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js')
          }
        }
        function Mm() {
          console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js')
        }
        'undefined' != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: a } })),
          'undefined' != typeof window &&
            (window.__THREE__
              ? console.warn('WARNING: Multiple instances of Three.js being imported.')
              : (window.__THREE__ = a))
        class Tm {
          perspectiveCamera(t = {}) {
            return Tm.Perspective(t)
          }
          orthographicCamera(t = {}) {
            return Tm.Orthographic(t)
          }
          static Perspective(t = {}) {
            const {
                fov: e = 50,
                aspect: n = window.innerWidth / window.innerHeight,
                near: i = 0.1,
                far: r = 2e3,
                x: s = 0,
                y: o = 5,
                z: a = 25
              } = t,
              l = new Ts(e, n, i, r)
            return l.position.set(s, o, a), l
          }
          static Orthographic(t = {}) {
            const e = window.innerWidth,
              n = window.innerHeight,
              {
                left: i = e / -2,
                right: r = e / 2,
                top: s = n / 2,
                bottom: o = n / -2,
                near: a = 1,
                far: l = 1e3,
                x: c = 0,
                y: h = 0,
                z: u = 10
              } = t,
              d = new _u(i, r, s, o, a, l)
            return d.position.set(c, h, u), d
          }
        }
        const Sm = t => {
          console.error(`%c [enable3d] ${t} `, 'background: #222; color: #bada55')
        }
        var Em = r(197)
        class Am {
          constructor(t, e) {
            ;(this.worldTransform = t), (this.physicsWorld = e), (this.tmpBtVector3 = new Ammo.btVector3())
          }
          toAmmoV3(t, e = 0) {
            return new Ammo.btVector3(
              void 0 !== (null == t ? void 0 : t.x) ? t.x : e,
              void 0 !== (null == t ? void 0 : t.y) ? t.y : e,
              void 0 !== (null == t ? void 0 : t.z) ? t.z : e
            )
          }
          get addConstraints() {
            return {
              lock: (t, e, n) => this.lock(t, e, n),
              fixed: (t, e, n) => this.fixed(t, e, n),
              pointToPoint: (t, e, n, i) => this.pointToPoint(t, e, n, i),
              hinge: (t, e, n, i) => this.hinge(t, e, n, i),
              slider: (t, e, n = {}, i) => this.slider(t, e, n, i),
              spring: (t, e, n = {}, i) => this.spring(t, e, n, i),
              coneTwist: (t, e, n = { frameA: {}, frameB: {} }, i) => this.coneTwist(t, e, n, i),
              dof: (t, e, n, i) => this.dof(t, e, n, i)
            }
          }
          getTransform(t, e, n = { x: 0, y: 0, z: 0 }, i = !1) {
            n = Object.assign({ x: 0, y: 0, z: 0 }, n)
            const r = new Ammo.btTransform()
            if ((r.setIdentity(), i)) {
              const i =
                  ((s = t.getWorldTransform().getOrigin()),
                  (o = e.getWorldTransform().getOrigin()),
                  (a = (s.x() - o.x()) / 2 + n.x),
                  (l = (s.y() - o.y()) / 2 + n.y),
                  (c = (s.z() - o.z()) / 2 + n.z),
                  new Ammo.btVector3(a, l, c)),
                r = new Ammo.btTransform()
              r.setIdentity(), r.setOrigin(i)
              const h = t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform())
              return h.op_mul(r), { transformA: h, transformB: r }
            }
            return (
              r.setOrigin(new Ammo.btVector3(n.x, n.y, n.z)),
              {
                transformA: t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(r),
                transformB: r
              }
            )
            var s, o, a, l, c
          }
          lock(t, e, n = !0) {
            const i = { x: 0, y: 0, z: 0 }
            return this.dof(t, e, { angularLowerLimit: i, angularUpperLimit: i }, n)
          }
          fixed(t, e, n = !0) {
            const i = this.getTransform(t.ammo, e.ammo)
            i.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),
              i.transformB.setRotation(e.ammo.getWorldTransform().getRotation())
            const r = new Ammo.btFixedConstraint(t.ammo, e.ammo, i.transformA, i.transformB)
            return this.physicsWorld.addConstraint(r, n), r
          }
          pointToPoint(t, e, n = {}, i = !0) {
            const { pivotA: r, pivotB: s } = n,
              o = new Ammo.btVector3(
                (null == r ? void 0 : r.x) || 0,
                (null == r ? void 0 : r.y) || 0,
                (null == r ? void 0 : r.z) || 0
              ),
              a = new Ammo.btVector3(
                (null == s ? void 0 : s.x) || 0,
                (null == s ? void 0 : s.y) || 0,
                (null == s ? void 0 : s.z) || 0
              ),
              l = new Ammo.btPoint2PointConstraint(t.ammo, e.ammo, o, a)
            return this.physicsWorld.addConstraint(l, i), l
          }
          hinge(t, e, n = {}, i = !0) {
            const { pivotA: r, pivotB: s, axisA: o, axisB: a } = n,
              l = new Ammo.btVector3(
                (null == r ? void 0 : r.x) || 0,
                (null == r ? void 0 : r.y) || 0,
                (null == r ? void 0 : r.z) || 0
              ),
              c = new Ammo.btVector3(
                (null == s ? void 0 : s.x) || 0,
                (null == s ? void 0 : s.y) || 0,
                (null == s ? void 0 : s.z) || 0
              ),
              h = new Ammo.btVector3(
                (null == o ? void 0 : o.x) || 0,
                (null == o ? void 0 : o.y) || 0,
                (null == o ? void 0 : o.z) || 0
              ),
              u = new Ammo.btVector3(
                (null == a ? void 0 : a.x) || 0,
                (null == a ? void 0 : a.y) || 0,
                (null == a ? void 0 : a.z) || 0
              ),
              d = new Ammo.btHingeConstraint(t.ammo, e.ammo, l, c, h, u, !0)
            return this.physicsWorld.addConstraint(d, i), d
          }
          slider(t, e, n = {}, i = !0) {
            const r = this.getTransform(t.ammo, e.ammo),
              {
                frameA: s = {},
                frameB: o = {},
                linearLowerLimit: a = 0,
                linearUpperLimit: l = 0,
                angularLowerLimit: c = 0,
                angularUpperLimit: h = 0
              } = n,
              u = r.transformA.getRotation()
            u.setEulerZYX(s.x || 0, s.y || 0, s.z || 0), r.transformA.setRotation(u)
            const d = r.transformB.getRotation()
            d.setEulerZYX(o.x || 0, o.y || 0, o.z || 0), r.transformB.setRotation(d)
            const p = new Ammo.btSliderConstraint(t.ammo, e.ammo, r.transformA, r.transformB, !0)
            return (
              p.setLowerLinLimit(a),
              p.setUpperLinLimit(l),
              p.setLowerAngLimit(c),
              p.setUpperAngLimit(h),
              this.physicsWorld.addConstraint(p, i),
              p
            )
          }
          spring(t, e, n = {}, i = !0) {
            const {
                stiffness: r = 50,
                damping: s = 0.01,
                angularLock: o = !1,
                linearLowerLimit: a = {},
                linearUpperLimit: l = {},
                angularLowerLimit: c = {},
                angularUpperLimit: h = {},
                offset: u = {},
                center: d = !1,
                enableSpring: p = !0
              } = n,
              m = Object.assign({ x: 0, y: 0, z: 0 }, u),
              f = this.getTransform(t.ammo, e.ammo, m, d),
              g = new Ammo.btGeneric6DofSpringConstraint(t.ammo, e.ammo, f.transformA, f.transformB, !0)
            this.tmpBtVector3.setValue(a.x || 0, a.y || 0, a.z || 0),
              g.setLinearLowerLimit(this.tmpBtVector3),
              this.tmpBtVector3.setValue(l.x || 0, l.y || 0, l.z || 0),
              g.setLinearUpperLimit(this.tmpBtVector3),
              o
                ? (this.tmpBtVector3.setValue(0, 0, 0),
                  g.setAngularLowerLimit(this.tmpBtVector3),
                  g.setAngularUpperLimit(this.tmpBtVector3))
                : (console.log(c, h),
                  g.setAngularLowerLimit(this.toAmmoV3(c, -Math.PI)),
                  g.setAngularUpperLimit(this.toAmmoV3(h, Math.PI)))
            for (let t = 0; t < 3; t++) g.enableSpring(t, p), g.setStiffness(t, r), g.setDamping(t, s)
            return this.physicsWorld.addConstraint(g, i), g
          }
          coneTwist(t, e, n, i = !0) {
            const { frameA: r, frameB: s } = n,
              o = new Ammo.btTransform()
            o.setIdentity(),
              o
                .getOrigin()
                .setValue(
                  (null == r ? void 0 : r.x) || 0,
                  (null == r ? void 0 : r.y) || 0,
                  (null == r ? void 0 : r.z) || 0
                )
            const a = new Ammo.btTransform()
            a.setIdentity(),
              a
                .getOrigin()
                .setValue(
                  (null == s ? void 0 : s.x) || 0,
                  (null == s ? void 0 : s.y) || 0,
                  (null == s ? void 0 : s.z) || 0
                ),
              this.getTransform(t.ammo, e.ammo)
            const l = new Ammo.btConeTwistConstraint(e.ammo, t.ammo, o, a)
            return l.setAngularOnly(!0), this.physicsWorld.addConstraint(l, i), l
          }
          dof(t, e, n = {}, i = !0) {
            const { offset: r, center: s = !1 } = n,
              o = Object.assign({ x: 0, y: 0, z: 0 }, r),
              a = this.getTransform(t.ammo, e.ammo, o, s),
              l = new Ammo.btGeneric6DofConstraint(t.ammo, e.ammo, a.transformA, a.transformB, !0),
              { linearLowerLimit: c, linearUpperLimit: h, angularLowerLimit: u, angularUpperLimit: d } = n,
              p = this.toAmmoV3(c),
              m = this.toAmmoV3(h),
              f = this.toAmmoV3(u, -Math.PI),
              g = this.toAmmoV3(d, Math.PI)
            return (
              l.setLinearLowerLimit(p),
              l.setLinearUpperLimit(m),
              l.setAngularLowerLimit(f),
              l.setAngularUpperLimit(g),
              Ammo.destroy(p),
              Ammo.destroy(m),
              Ammo.destroy(f),
              Ammo.destroy(g),
              this.physicsWorld.addConstraint(l, i),
              l
            )
          }
        }
        var Lm = r(650)
        const Rm = 'hull',
          Pm = 'manual',
          Cm = (function () {
            const t = new ei(),
              e = new ei(),
              n = new Ii()
            return function (i, r, s, o = {}) {
              if (((o.type = Rm), Nm(o), o.fit === Pm))
                return console.warn('cannot use fit: manual with type: hull'), null
              const a = km(i, r),
                l = new Ammo.btVector3(),
                c = new Ammo.btConvexHullShape()
              c.setMargin(o.margin), e.addVectors(a.max, a.min).multiplyScalar(0.5)
              let h = 0
              for (let t = 0; t < i.length; t++) h += i[t].length / 3
              const u = o.hullMaxVertices || 1e5
              h > u && console.warn(`too many vertices for hull shape; sampling ~${u} from ~${h} vertices`)
              const d = Math.min(1, u / h)
              for (let s = 0; s < i.length; s++) {
                const o = i[s]
                n.fromArray(r[s])
                for (let r = 0; r < o.length; r += 3) {
                  const a = s === i.length - 1 && r === o.length - 3
                  ;(Math.random() <= d || a) &&
                    (t
                      .set(o[r], o[r + 1], o[r + 2])
                      .applyMatrix4(n)
                      .sub(e),
                    l.setValue(t.x, t.y, t.z),
                    c.addPoint(l, a))
                }
              }
              let p = c
              if (c.getNumVertices() >= 100) {
                const t = new Ammo.btShapeHull(c)
                t.buildHull(o.margin),
                  Ammo.destroy(c),
                  (p = new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()), t.numVertices())),
                  Ammo.destroy(t)
              }
              return Ammo.destroy(l), Bm(p, o, zm(s, o)), p
            }
          })(),
          Im = (function () {
            const t = new ei(),
              e = new ei(),
              n = new Ii()
            return function (i, r, s, o, a = {}) {
              if (((a.type = 'hacd'), Nm(a), a.fit === Pm))
                return console.warn('cannot use fit: manual with type: hacd'), []
              if (!Ammo.hasOwnProperty('HACD'))
                return (
                  console.warn(
                    'HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.'
                  ),
                  []
                )
              const l = km(i, r),
                c = zm(o, a)
              let h = 0,
                u = 0
              e.addVectors(l.max, l.min).multiplyScalar(0.5)
              for (let t = 0; t < i.length; t++)
                (h += i[t].length / 3), s && s[t] ? (u += s[t].length / 3) : (u += i[t].length / 9)
              const d = new Ammo.HACD()
              a.hasOwnProperty('compacityWeight') && d.SetCompacityWeight(a.compacityWeight),
                a.hasOwnProperty('volumeWeight') && d.SetVolumeWeight(a.volumeWeight),
                a.hasOwnProperty('nClusters') && d.SetNClusters(a.nClusters),
                a.hasOwnProperty('nVerticesPerCH') && d.SetNVerticesPerCH(a.nVerticesPerCH),
                a.hasOwnProperty('concavity') && d.SetConcavity(a.concavity)
              const p = Ammo._malloc(3 * h * 8),
                m = Ammo._malloc(3 * u * 4)
              d.SetPoints(p), d.SetTriangles(m), d.SetNPoints(h), d.SetNTriangles(u)
              let f = p / 8,
                g = m / 4
              for (let o = 0; o < i.length; o++) {
                const a = i[o]
                n.fromArray(r[o])
                for (let i = 0; i < a.length; i += 3)
                  t
                    .set(a[i + 0], a[i + 1], a[i + 2])
                    .applyMatrix4(n)
                    .sub(e),
                    (Ammo.HEAPF64[f + 0] = t.x),
                    (Ammo.HEAPF64[f + 1] = t.y),
                    (Ammo.HEAPF64[f + 2] = t.z),
                    (f += 3)
                if (s[o]) {
                  const t = s[o]
                  for (let e = 0; e < t.length; e++) (Ammo.HEAP32[g] = t[e]), g++
                } else for (let t = 0; t < a.length / 3; t++) (Ammo.HEAP32[g] = t), g++
              }
              d.Compute(), Ammo._free(p), Ammo._free(m)
              const v = d.GetNClusters(),
                y = []
              for (let t = 0; t < v; t++) {
                const e = new Ammo.btConvexHullShape()
                e.setMargin(a.margin)
                const n = d.GetNPointsCH(t),
                  i = d.GetNTrianglesCH(t),
                  r = Ammo._malloc(3 * n * 8),
                  s = Ammo._malloc(3 * i * 4)
                d.GetCH(t, r, s)
                const o = r / 8
                for (let t = 0; t < n; t++) {
                  const i = new Ammo.btVector3(),
                    r = Ammo.HEAPF64[o + 3 * t + 0],
                    s = Ammo.HEAPF64[o + 3 * t + 1],
                    a = Ammo.HEAPF64[o + 3 * t + 2]
                  i.setValue(r, s, a), e.addPoint(i, t === n - 1), Ammo.destroy(i)
                }
                Bm(e, a, c), y.push(e)
              }
              return y
            }
          })(),
          Dm = (function () {
            const t = new ei(),
              e = new ei(),
              n = new Ii()
            return function (i, r, s, o, a = {}) {
              if (((a.type = 'vhacd'), Nm(a), a.fit === Pm))
                return console.warn('cannot use fit: manual with type: vhacd'), []
              if (!Ammo.hasOwnProperty('VHACD'))
                return (
                  console.warn(
                    'VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.'
                  ),
                  []
                )
              const l = km(i, r),
                c = zm(o, a)
              let h = 0,
                u = 0
              e.addVectors(l.max, l.min).multiplyScalar(0.5)
              for (let t = 0; t < i.length; t++)
                (h += i[t].length / 3), s && s[t] ? (u += s[t].length / 3) : (u += i[t].length / 9)
              const d = new Ammo.VHACD(),
                p = new Ammo.Parameters()
              a.hasOwnProperty('resolution') && p.set_m_resolution(a.resolution),
                a.hasOwnProperty('depth') && p.set_m_depth(a.depth),
                a.hasOwnProperty('concavity') && p.set_m_concavity(a.concavity),
                a.hasOwnProperty('planeDownsampling') && p.set_m_planeDownsampling(a.planeDownsampling),
                a.hasOwnProperty('convexhullDownsampling') && p.set_m_convexhullDownsampling(a.convexhullDownsampling),
                a.hasOwnProperty('alpha') && p.set_m_alpha(a.alpha),
                a.hasOwnProperty('beta') && p.set_m_beta(a.beta),
                a.hasOwnProperty('gamma') && p.set_m_gamma(a.gamma),
                a.hasOwnProperty('pca') && p.set_m_pca(a.pca),
                a.hasOwnProperty('mode') && p.set_m_mode(a.mode),
                a.hasOwnProperty('maxNumVerticesPerCH') && p.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),
                a.hasOwnProperty('minVolumePerCH') && p.set_m_minVolumePerCH(a.minVolumePerCH),
                a.hasOwnProperty('convexhullApproximation') &&
                  p.set_m_convexhullApproximation(a.convexhullApproximation),
                a.hasOwnProperty('oclAcceleration') && p.set_m_oclAcceleration(a.oclAcceleration)
              const m = Ammo._malloc(3 * h * 8 + 3),
                f = Ammo._malloc(3 * u * 4)
              let g = m / 8,
                v = f / 4
              for (let o = 0; o < i.length; o++) {
                const a = i[o]
                n.fromArray(r[o])
                for (let i = 0; i < a.length; i += 3)
                  t
                    .set(a[i + 0], a[i + 1], a[i + 2])
                    .applyMatrix4(n)
                    .sub(e),
                    (Ammo.HEAPF64[g + 0] = t.x),
                    (Ammo.HEAPF64[g + 1] = t.y),
                    (Ammo.HEAPF64[g + 2] = t.z),
                    (g += 3)
                if (s[o]) {
                  const t = s[o]
                  for (let e = 0; e < t.length; e++) (Ammo.HEAP32[v] = t[e]), v++
                } else for (let t = 0; t < a.length / 3; t++) (Ammo.HEAP32[v] = t), v++
              }
              d.Compute(m, 3, h, f, 3, u, p), Ammo._free(m), Ammo._free(f)
              const y = d.GetNConvexHulls(),
                x = [],
                b = new Ammo.ConvexHull()
              for (let t = 0; t < y; t++) {
                d.GetConvexHull(t, b)
                const e = b.get_m_nPoints(),
                  n = (b.get_m_points(), new Ammo.btConvexHullShape())
                n.setMargin(a.margin)
                for (let t = 0; t < e; t++) {
                  const i = new Ammo.btVector3(),
                    r = b.get_m_points(3 * t + 0),
                    s = b.get_m_points(3 * t + 1),
                    o = b.get_m_points(3 * t + 2)
                  i.setValue(r, s, o), n.addPoint(i, t === e - 1), Ammo.destroy(i)
                }
                Bm(n, a, c), x.push(n)
              }
              return Ammo.destroy(b), Ammo.destroy(d), x
            }
          })(),
          Om = (function () {
            const t = new ei(),
              e = new ei(),
              n = new ei(),
              i = new Ii()
            return function (r, s, o, a, l = {}) {
              if (((l.type = 'mesh'), Nm(l), l.fit === Pm))
                return console.warn('cannot use fit: manual with type: mesh'), null
              const c = zm(a, l),
                h = new Ammo.btVector3(),
                u = new Ammo.btVector3(),
                d = new Ammo.btVector3(),
                p = new Ammo.btTriangleMesh(!0, !1)
              for (let a = 0; a < r.length; a++) {
                const l = r[a],
                  c = o[a] ? o[a] : null
                if ((i.fromArray(s[a]), c))
                  for (let r = 0; r < c.length; r += 3) {
                    const s = 3 * c[r],
                      o = 3 * c[r + 1],
                      a = 3 * c[r + 2]
                    t.set(l[s], l[s + 1], l[s + 2]).applyMatrix4(i),
                      e.set(l[o], l[o + 1], l[o + 2]).applyMatrix4(i),
                      n.set(l[a], l[a + 1], l[a + 2]).applyMatrix4(i),
                      h.setValue(t.x, t.y, t.z),
                      u.setValue(e.x, e.y, e.z),
                      d.setValue(n.x, n.y, n.z),
                      p.addTriangle(h, u, d, !1)
                  }
                else
                  for (let r = 0; r < l.length; r += 9)
                    t.set(l[r + 0], l[r + 1], l[r + 2]).applyMatrix4(i),
                      e.set(l[r + 3], l[r + 4], l[r + 5]).applyMatrix4(i),
                      n.set(l[r + 6], l[r + 7], l[r + 8]).applyMatrix4(i),
                      h.setValue(t.x, t.y, t.z),
                      u.setValue(e.x, e.y, e.z),
                      d.setValue(n.x, n.y, n.z),
                      p.addTriangle(h, u, d, !1)
              }
              const m = new Ammo.btVector3(c.x, c.y, c.z)
              let f
              return (
                p.setScaling(m),
                Ammo.destroy(m),
                (f = l.concave
                  ? new Ammo.btBvhTriangleMeshShape(p, !0, !0)
                  : new Ammo.btConvexTriangleMeshShape(p, !0)),
                (f.resources = [p]),
                Ammo.destroy(h),
                Ammo.destroy(u),
                Ammo.destroy(d),
                Bm(f, l),
                f
              )
            }
          })()
        function Nm(t) {
          ;(t.type = t.type || Rm), (t.margin = t.hasOwnProperty('margin') ? t.margin : 0.01)
        }
        const Bm = function (t, e, n) {},
          Fm = (function () {
            const t = new Ii()
            return function (e, n, i) {
              parseInt(a) >= 123 ? t.copy(e.matrixWorld).invert() : t.getInverse(e.matrixWorld),
                new ei().setFromMatrixScale(e.matrixWorld),
                e.traverse(r => {
                  const s = new Ii()
                  r.isMesh &&
                    (n.includeInvisible || (r.el && r.el.object3D.visible) || r.visible) &&
                    (r === e ? s.identity() : (r.updateWorldMatrix(!0), s.multiplyMatrices(t, r.matrixWorld)),
                    i(
                      r.geometry.isBufferGeometry ? r.geometry.attributes.position.array : r.geometry.vertices,
                      s.elements,
                      r.geometry.index ? r.geometry.index.array : null
                    ))
                })
            }
          })(),
          zm = (function () {
            const t = new Ii()
            return function (e, n = {}) {
              const i = new ei(1, 1, 1)
              return 'all' === n.fit && (t.fromArray(e), i.setFromMatrixScale(t)), i
            }
          })(),
          km =
            (new ei(),
            function (t, e) {
              const n = new ri()
              let i = 1 / 0,
                r = 1 / 0,
                s = 1 / 0,
                o = -1 / 0,
                a = -1 / 0,
                l = -1 / 0
              return (
                n.min.set(0, 0, 0),
                n.max.set(0, 0, 0),
                Um(t, e, t => {
                  t.x < i && (i = t.x),
                    t.y < r && (r = t.y),
                    t.z < s && (s = t.z),
                    t.x > o && (o = t.x),
                    t.y > a && (a = t.y),
                    t.z > l && (l = t.z)
                }),
                n.min.set(i, r, s),
                n.max.set(o, a, l),
                n
              )
            }),
          Um = (function () {
            const t = new ei(),
              e = new Ii()
            return function (n, i, r) {
              for (let s = 0; s < n.length; s++) {
                e.fromArray(i[s])
                for (let i = 0; i < n[s].length; i += 3) t.set(n[s][i], n[s][i + 1], n[s][i + 2]).applyMatrix4(e), r(t)
              }
            }
          })()
        class Hm extends gs {
          constructor(t, e) {
            super(t, e),
              (this.isExtendedMesh = !0),
              (this.isGroup = !1),
              (this.vector3 = new ei()),
              (this.hasBody = !1),
              (this.fragmentDepth = 0),
              (this.breakable = !1),
              (this.fractureImpulse = 1),
              (this.name = `object-${this.id}`)
          }
          get world() {
            return { theta: this.worldTheta, phi: this.worldPhi }
          }
          get worldTheta() {
            return this.getWorldDirection(this.vector3), Math.atan2(this.vector3.x, this.vector3.z)
          }
          get worldPhi() {
            return this.getWorldDirection(this.vector3), Math.acos(this.vector3.y)
          }
        }
        const Gm = class {
          constructor() {
            this._defaultMaterial = new ch({ color: 13421772 })
          }
          get() {
            return this._defaultMaterial
          }
        }
        var Vm = function (t, e) {
          var n = {}
          for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i])
          if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
            var r = 0
            for (i = Object.getOwnPropertySymbols(t); r < i.length; r++)
              e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]])
          }
          return n
        }
        class Wm {
          constructor(t) {
            ;(this.scene = t), (this.isHeadless = 'headless' === t), (this.defaultMaterial = new Gm())
          }
          get make() {
            return {
              plane: (t = {}, e = {}) => this.makePlane(t, e),
              box: (t = {}, e = {}) => this.makeBox(t, e),
              sphere: (t = {}, e = {}) => this.makeSphere(t, e),
              cylinder: (t = {}, e = {}) => this.makeCylinder(t, e),
              cone: (t = {}, e = {}) => this.makeCone(t, e),
              torus: (t = {}, e = {}) => this.makeTorus(t, e),
              extrude: (t, e = {}) => this.makeExtrude(t, e)
            }
          }
          get add() {
            return {
              mesh: t => this.addMesh(t),
              existing: t => this.addExisting(t),
              plane: (t = {}, e = {}) => this.addPlane(t, e),
              box: (t = {}, e = {}) => this.addBox(t, e),
              ground: (t, e = {}) => this.addGround(t, e),
              sphere: (t = {}, e = {}) => this.addSphere(t, e),
              cylinder: (t = {}, e = {}) => this.addCylinder(t, e),
              cone: (t = {}, e = {}) => this.addCone(t, e),
              torus: (t = {}, e = {}) => this.addTorus(t, e),
              extrude: (t, e = {}) => this.addExtrude(t, e),
              material: (t = {}) => this.addMaterial(t)
            }
          }
          addExisting(...t) {
            'headless' !== this.scene && this.scene.add(...t)
          }
          addMesh(t) {
            if (Array.isArray(t)) for (let e = 0; e < t.length; e++) this.addExisting(t[e])
            else this.addExisting(t)
            return this
          }
          createMesh(t, e, n) {
            const { x: i = 0, y: r = 0, z: s = 0 } = n
            let o
            switch (!Array.isArray(e) && e.type) {
              case 'LineBasicMaterial':
                o = new Hl(t, e)
                break
              case 'PointsMaterial':
                o = new Kl(t, e)
                break
              default:
                o = new Hm(t, e)
            }
            return o.position.set(i, r, s), (o.castShadow = o.receiveShadow = !0), o
          }
          makeExtrude(t, e) {
            const { x: n, y: i, z: r, name: s, shape: o, autoCenter: a = !0, breakable: l = !1 } = t,
              c = Vm(t, ['x', 'y', 'z', 'name', 'shape', 'autoCenter', 'breakable']),
              { depth: h = 1, bevelEnabled: u = !1 } = c,
              d = new Uc(o, Object.assign({ depth: h, bevelEnabled: u }, c)),
              p = this.addMaterial(e),
              m = this.createMesh(d, p, { x: n, y: i, z: r })
            return a && m.geometry.center(), (m.name = s || `body_id_${m.id}`), (m.shape = 'extrude'), m
          }
          addExtrude(t, e = {}) {
            const n = this.makeExtrude(t, e)
            return this.addExisting(n), n
          }
          makePlane(t, e) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new Ns(a.width || 1, a.height || 1, a.widthSegments || 1, a.heightSegments || 1),
              c = this.addMaterial(e)
            c.side = b
            const h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'plane'), h
          }
          addPlane(t, e) {
            const n = this.makePlane(t, e)
            return this.addExisting(n), n
          }
          makeSphere(t, e) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new Yc(
                a.radius || 1,
                a.widthSegments || 16,
                a.heightSegments || 12,
                a.phiStart || void 0,
                a.phiLength || void 0,
                a.thetaStart || void 0,
                a.thetaLength || void 0
              ),
              c = this.addMaterial(e),
              h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'sphere'), h
          }
          addSphere(t = {}, e = {}) {
            const n = this.makeSphere(t, e)
            return this.addExisting(n), n
          }
          makeBox(t, e) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new ys(
                a.width || 1,
                a.height || 1,
                a.depth || 1,
                a.widthSegments || void 0,
                a.heightSegments || void 0,
                a.depthSegments || void 0
              ),
              c = this.addMaterial(e),
              h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'box'), h
          }
          addBox(t = {}, e = {}) {
            const n = this.makeBox(t, e)
            return this.addExisting(n), n
          }
          addGround(t, e = {}) {
            const n = this.makeBox(t, e)
            return n.rotateX(Vn.degToRad(90)), this.addExisting(n), n
          }
          makeCylinder(t = {}, e = {}) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new rc(
                a.radiusTop || 1,
                a.radiusBottom || 1,
                a.height || 1,
                a.radiusSegments || void 0,
                a.heightSegments || void 0,
                a.openEnded || void 0,
                a.thetaStart || void 0,
                a.thetaLength || void 0
              ),
              c = this.addMaterial(e),
              h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'cylinder'), h
          }
          addCylinder(t = {}, e = {}) {
            const n = this.makeCylinder(t, e)
            return this.addExisting(n), n
          }
          makeCone(t = {}, e = {}) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new sc(
                a.radius || 1,
                a.height || 1,
                a.radiusSegments || 8,
                a.heightSegments || 1,
                a.openEnded || !1,
                a.thetaStart || 0,
                a.thetaLength || 2 * Math.PI
              ),
              c = this.addMaterial(e),
              h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'cone'), h
          }
          addCone(t = {}, e = {}) {
            const n = this.makeCone(t, e)
            return this.addExisting(n), n
          }
          makeTorus(t = {}, e = {}) {
            const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t,
              a = Vm(t, ['x', 'y', 'z', 'name', 'breakable']),
              l = new Kc(
                a.radius || void 0,
                a.tube || void 0,
                a.radialSegments || void 0,
                a.tubularSegments || void 0,
                a.arc || void 0
              ),
              c = this.addMaterial(e),
              h = this.createMesh(l, c, { x: n, y: i, z: r })
            return (h.name = s || `body_id_${h.id}`), (h.shape = 'torus'), h
          }
          addTorus(t = {}, e = {}) {
            const n = this.makeTorus(t, e)
            return this.addExisting(n), n
          }
          addMaterial(t = {}) {
            const e = Object.keys(t)[0]
            let n
            if ('headless' === this.scene) return this.defaultMaterial.get()
            switch (e) {
              case 'basic':
                n = new Lr(t.basic)
                break
              case 'normal':
                n = new lh(t.normal)
                break
              case 'standard':
                n = new rh(t.standard)
                break
              case 'lambert':
                n = new ch(t.lambert)
                break
              case 'phong':
                n = new oh(t.phong)
                break
              case 'physical':
                void 0 !== t.physical
                  ? (n = new sh(t.physical))
                  : (Sm('You need to pass parameters to the physical material. (Fallback to default material)'),
                    (n = this.defaultMaterial.get()))
                break
              case 'toon':
                n = new ah(t.toon)
                break
              case 'line':
                n = new Nl(t.line)
                break
              case 'points':
                n = new ql(t.points)
                break
              case 'custom':
                n = t.custom || this.defaultMaterial.get()
                break
              default:
                n = this.defaultMaterial.get()
            }
            return n
          }
        }
        class jm extends Lm.Events {
          addCollider(t, e, n) {
            t.body &&
              e.body &&
              ((t.body.checkCollisions = !0),
              (e.body.checkCollisions = !0),
              this.on('collision', i => {
                var r, s
                const { bodies: o, event: a } = i
                ;(null === (r = o[0]) || void 0 === r ? void 0 : r.name) &&
                  (null === (s = o[1]) || void 0 === s ? void 0 : s.name) &&
                  (null == t ? void 0 : t.name) &&
                  (null == e ? void 0 : e.name) &&
                  ((o[0].name === t.name && o[1].name === e.name) || (o[1].name === t.name && o[0].name === e.name)) &&
                  n(a)
              }))
          }
        }
        var qm = (function () {
            var t,
              e,
              n,
              i,
              r = new ei()
            function s() {
              ;(this.tolerance = -1),
                (this.faces = []),
                (this.newFaces = []),
                (this.assigned = new c()),
                (this.unassigned = new c()),
                (this.vertices = [])
            }
            function o() {
              ;(this.normal = new ei()),
                (this.midpoint = new ei()),
                (this.area = 0),
                (this.constant = 0),
                (this.outside = null),
                (this.mark = 0),
                (this.edge = null)
            }
            function a(t, e) {
              ;(this.vertex = t), (this.prev = null), (this.next = null), (this.twin = null), (this.face = e)
            }
            function l(t) {
              ;(this.point = t), (this.prev = null), (this.next = null), (this.face = null)
            }
            function c() {
              ;(this.head = null), (this.tail = null)
            }
            return (
              Object.assign(s.prototype, {
                setFromPoints: function (t) {
                  !0 !== Array.isArray(t) && console.error('THREE.ConvexHull: Points parameter is not an array.'),
                    t.length < 4 && console.error('THREE.ConvexHull: The algorithm needs at least four points.'),
                    this.makeEmpty()
                  for (var e = 0, n = t.length; e < n; e++) this.vertices.push(new l(t[e]))
                  return this.compute(), this
                },
                setFromObject: function (t) {
                  var e = []
                  return (
                    t.updateMatrixWorld(!0),
                    t.traverse(function (t) {
                      var n,
                        i,
                        r,
                        s = t.geometry
                      if (void 0 !== s) {
                        if (s.isGeometry)
                          return void console.error(
                            'THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.'
                          )
                        if (s.isBufferGeometry) {
                          var o = s.attributes.position
                          if (void 0 !== o)
                            for (n = 0, i = o.count; n < i; n++)
                              (r = new ei()).fromBufferAttribute(o, n).applyMatrix4(t.matrixWorld), e.push(r)
                        }
                      }
                    }),
                    this.setFromPoints(e)
                  )
                },
                containsPoint: function (t) {
                  for (var e = this.faces, n = 0, i = e.length; n < i; n++)
                    if (e[n].distanceToPoint(t) > this.tolerance) return !1
                  return !0
                },
                intersectRay: function (t, e) {
                  for (var n = this.faces, i = -1 / 0, r = 1 / 0, s = 0, o = n.length; s < o; s++) {
                    var a = n[s],
                      l = a.distanceToPoint(t.origin),
                      c = a.normal.dot(t.direction)
                    if (l > 0 && c >= 0) return null
                    var h = 0 !== c ? -l / c : 0
                    if (!(h <= 0) && (c > 0 ? (r = Math.min(h, r)) : (i = Math.max(h, i)), i > r)) return null
                  }
                  return i !== -1 / 0 ? t.at(i, e) : t.at(r, e), e
                },
                intersectsRay: function (t) {
                  return null !== this.intersectRay(t, r)
                },
                makeEmpty: function () {
                  return (this.faces = []), (this.vertices = []), this
                },
                addVertexToFace: function (t, e) {
                  return (
                    (t.face = e),
                    null === e.outside ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t),
                    (e.outside = t),
                    this
                  )
                },
                removeVertexFromFace: function (t, e) {
                  return (
                    t === e.outside &&
                      (null !== t.next && t.next.face === e ? (e.outside = t.next) : (e.outside = null)),
                    this.assigned.remove(t),
                    this
                  )
                },
                removeAllVerticesFromFace: function (t) {
                  if (null !== t.outside) {
                    for (var e = t.outside, n = t.outside; null !== n.next && n.next.face === t; ) n = n.next
                    return this.assigned.removeSubList(e, n), (e.prev = n.next = null), (t.outside = null), e
                  }
                },
                deleteFaceVertices: function (t, e) {
                  var n = this.removeAllVerticesFromFace(t)
                  if (void 0 !== n)
                    if (void 0 === e) this.unassigned.appendChain(n)
                    else {
                      var i = n
                      do {
                        var r = i.next
                        e.distanceToPoint(i.point) > this.tolerance
                          ? this.addVertexToFace(i, e)
                          : this.unassigned.append(i),
                          (i = r)
                      } while (null !== i)
                    }
                  return this
                },
                resolveUnassignedPoints: function (t) {
                  if (!1 === this.unassigned.isEmpty()) {
                    var e = this.unassigned.first()
                    do {
                      for (var n = e.next, i = this.tolerance, r = null, s = 0; s < t.length; s++) {
                        var o = t[s]
                        if (0 === o.mark) {
                          var a = o.distanceToPoint(e.point)
                          if ((a > i && ((i = a), (r = o)), i > 1e3 * this.tolerance)) break
                        }
                      }
                      null !== r && this.addVertexToFace(e, r), (e = n)
                    } while (null !== e)
                  }
                  return this
                },
                computeExtremes: function () {
                  var t,
                    e,
                    n,
                    i = new ei(),
                    r = new ei(),
                    s = [],
                    o = []
                  for (t = 0; t < 3; t++) s[t] = o[t] = this.vertices[0]
                  for (
                    i.copy(this.vertices[0].point), r.copy(this.vertices[0].point), t = 0, e = this.vertices.length;
                    t < e;
                    t++
                  ) {
                    var a = this.vertices[t],
                      l = a.point
                    for (n = 0; n < 3; n++)
                      l.getComponent(n) < i.getComponent(n) && (i.setComponent(n, l.getComponent(n)), (s[n] = a))
                    for (n = 0; n < 3; n++)
                      l.getComponent(n) > r.getComponent(n) && (r.setComponent(n, l.getComponent(n)), (o[n] = a))
                  }
                  return (
                    (this.tolerance =
                      3 *
                      Number.EPSILON *
                      (Math.max(Math.abs(i.x), Math.abs(r.x)) +
                        Math.max(Math.abs(i.y), Math.abs(r.y)) +
                        Math.max(Math.abs(i.z), Math.abs(r.z)))),
                    { min: s, max: o }
                  )
                },
                computeInitialHull: function () {
                  void 0 === t && ((t = new zd()), (e = new ar()), (n = new ei()))
                  var i,
                    r,
                    s,
                    a,
                    l,
                    c,
                    h,
                    u,
                    d,
                    p = this.vertices,
                    m = this.computeExtremes(),
                    f = m.min,
                    g = m.max,
                    v = 0,
                    y = 0
                  for (c = 0; c < 3; c++)
                    (d = g[c].point.getComponent(c) - f[c].point.getComponent(c)) > v && ((v = d), (y = c))
                  for (r = f[y], s = g[y], v = 0, t.set(r.point, s.point), c = 0, h = this.vertices.length; c < h; c++)
                    (i = p[c]) !== r &&
                      i !== s &&
                      (t.closestPointToPoint(i.point, !0, n),
                      (d = n.distanceToSquared(i.point)) > v && ((v = d), (a = i)))
                  for (
                    v = -1, e.setFromCoplanarPoints(r.point, s.point, a.point), c = 0, h = this.vertices.length;
                    c < h;
                    c++
                  )
                    (i = p[c]) !== r &&
                      i !== s &&
                      i !== a &&
                      (d = Math.abs(e.distanceToPoint(i.point))) > v &&
                      ((v = d), (l = i))
                  var x = []
                  if (e.distanceToPoint(l.point) < 0)
                    for (
                      x.push(o.create(r, s, a), o.create(l, s, r), o.create(l, a, s), o.create(l, r, a)), c = 0;
                      c < 3;
                      c++
                    )
                      (u = (c + 1) % 3),
                        x[c + 1].getEdge(2).setTwin(x[0].getEdge(u)),
                        x[c + 1].getEdge(1).setTwin(x[u + 1].getEdge(0))
                  else
                    for (
                      x.push(o.create(r, a, s), o.create(l, r, s), o.create(l, s, a), o.create(l, a, r)), c = 0;
                      c < 3;
                      c++
                    )
                      (u = (c + 1) % 3),
                        x[c + 1].getEdge(2).setTwin(x[0].getEdge((3 - c) % 3)),
                        x[c + 1].getEdge(0).setTwin(x[u + 1].getEdge(1))
                  for (c = 0; c < 4; c++) this.faces.push(x[c])
                  for (c = 0, h = p.length; c < h; c++)
                    if ((i = p[c]) !== r && i !== s && i !== a && i !== l) {
                      v = this.tolerance
                      var b = null
                      for (u = 0; u < 4; u++)
                        (d = this.faces[u].distanceToPoint(i.point)) > v && ((v = d), (b = this.faces[u]))
                      null !== b && this.addVertexToFace(i, b)
                    }
                  return this
                },
                reindexFaces: function () {
                  for (var t = [], e = 0; e < this.faces.length; e++) {
                    var n = this.faces[e]
                    0 === n.mark && t.push(n)
                  }
                  return (this.faces = t), this
                },
                nextVertexToAdd: function () {
                  if (!1 === this.assigned.isEmpty()) {
                    var t,
                      e = 0,
                      n = this.assigned.first().face,
                      i = n.outside
                    do {
                      var r = n.distanceToPoint(i.point)
                      r > e && ((e = r), (t = i)), (i = i.next)
                    } while (null !== i && i.face === n)
                    return t
                  }
                },
                computeHorizon: function (t, e, n, i) {
                  var r
                  this.deleteFaceVertices(n), (n.mark = 1), (r = null === e ? (e = n.getEdge(0)) : e.next)
                  do {
                    var s = r.twin,
                      o = s.face
                    0 === o.mark &&
                      (o.distanceToPoint(t) > this.tolerance ? this.computeHorizon(t, s, o, i) : i.push(r)),
                      (r = r.next)
                  } while (r !== e)
                  return this
                },
                addAdjoiningFace: function (t, e) {
                  var n = o.create(t, e.tail(), e.head())
                  return this.faces.push(n), n.getEdge(-1).setTwin(e.twin), n.getEdge(0)
                },
                addNewFaces: function (t, e) {
                  this.newFaces = []
                  for (var n = null, i = null, r = 0; r < e.length; r++) {
                    var s = e[r],
                      o = this.addAdjoiningFace(t, s)
                    null === n ? (n = o) : o.next.setTwin(i), this.newFaces.push(o.face), (i = o)
                  }
                  return n.next.setTwin(i), this
                },
                addVertexToHull: function (t) {
                  var e = []
                  return (
                    this.unassigned.clear(),
                    this.removeVertexFromFace(t, t.face),
                    this.computeHorizon(t.point, null, t.face, e),
                    this.addNewFaces(t, e),
                    this.resolveUnassignedPoints(this.newFaces),
                    this
                  )
                },
                cleanup: function () {
                  return this.assigned.clear(), this.unassigned.clear(), (this.newFaces = []), this
                },
                compute: function () {
                  var t
                  for (this.computeInitialHull(); void 0 !== (t = this.nextVertexToAdd()); ) this.addVertexToHull(t)
                  return this.reindexFaces(), this.cleanup(), this
                }
              }),
              Object.assign(o, {
                create: function (t, e, n) {
                  var i = new o(),
                    r = new a(t, i),
                    s = new a(e, i),
                    l = new a(n, i)
                  return (r.next = l.prev = s), (s.next = r.prev = l), (l.next = s.prev = r), (i.edge = r), i.compute()
                }
              }),
              Object.assign(o.prototype, {
                getEdge: function (t) {
                  for (var e = this.edge; t > 0; ) (e = e.next), t--
                  for (; t < 0; ) (e = e.prev), t++
                  return e
                },
                compute: function () {
                  void 0 === i && (i = new yr())
                  var t = this.edge.tail(),
                    e = this.edge.head(),
                    n = this.edge.next.head()
                  return (
                    i.set(t.point, e.point, n.point),
                    i.getNormal(this.normal),
                    i.getMidpoint(this.midpoint),
                    (this.area = i.getArea()),
                    (this.constant = this.normal.dot(this.midpoint)),
                    this
                  )
                },
                distanceToPoint: function (t) {
                  return this.normal.dot(t) - this.constant
                }
              }),
              Object.assign(a.prototype, {
                head: function () {
                  return this.vertex
                },
                tail: function () {
                  return this.prev ? this.prev.vertex : null
                },
                length: function () {
                  var t = this.head(),
                    e = this.tail()
                  return null !== e ? e.point.distanceTo(t.point) : -1
                },
                lengthSquared: function () {
                  var t = this.head(),
                    e = this.tail()
                  return null !== e ? e.point.distanceToSquared(t.point) : -1
                },
                setTwin: function (t) {
                  return (this.twin = t), (t.twin = this), this
                }
              }),
              Object.assign(c.prototype, {
                first: function () {
                  return this.head
                },
                last: function () {
                  return this.tail
                },
                clear: function () {
                  return (this.head = this.tail = null), this
                },
                insertBefore: function (t, e) {
                  return (
                    (e.prev = t.prev),
                    (e.next = t),
                    null === e.prev ? (this.head = e) : (e.prev.next = e),
                    (t.prev = e),
                    this
                  )
                },
                insertAfter: function (t, e) {
                  return (
                    (e.prev = t),
                    (e.next = t.next),
                    null === e.next ? (this.tail = e) : (e.next.prev = e),
                    (t.next = e),
                    this
                  )
                },
                append: function (t) {
                  return (
                    null === this.head ? (this.head = t) : (this.tail.next = t),
                    (t.prev = this.tail),
                    (t.next = null),
                    (this.tail = t),
                    this
                  )
                },
                appendChain: function (t) {
                  for (
                    null === this.head ? (this.head = t) : (this.tail.next = t), t.prev = this.tail;
                    null !== t.next;

                  )
                    t = t.next
                  return (this.tail = t), this
                },
                remove: function (t) {
                  return (
                    null === t.prev ? (this.head = t.next) : (t.prev.next = t.next),
                    null === t.next ? (this.tail = t.prev) : (t.next.prev = t.prev),
                    this
                  )
                },
                removeSubList: function (t, e) {
                  return (
                    null === t.prev ? (this.head = e.next) : (t.prev.next = e.next),
                    null === e.next ? (this.tail = t.prev) : (e.next.prev = t.prev),
                    this
                  )
                },
                isEmpty: function () {
                  return null === this.head
                }
              }),
              s
            )
          })(),
          Xm = function (t) {
            Qr.call(this)
            var e = [],
              n = []
            void 0 === qm && console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull')
            for (var i = new qm().setFromPoints(t).faces, r = 0; r < i.length; r++) {
              var s = i[r],
                o = s.edge
              do {
                var a = o.head().point
                e.push(a.x, a.y, a.z), n.push(s.normal.x, s.normal.y, s.normal.z), (o = o.next)
              } while (o !== s.edge)
            }
            this.setAttribute('position', new Ur(e, 3)), this.setAttribute('normal', new Ur(n, 3))
          }
        ;(Xm.prototype = Object.create(Qr.prototype)).constructor = Xm
        const Ym = t => new (window.THREE && window.THREE.ConvexGeometry ? window.THREE.ConvexGeometry : Xm)(t),
          Zm = function (t, e) {
            ;(this.minSizeForBreak = t || 1.4),
              (this.smallDelta = e || 1e-4),
              (this.tempLine1 = new zd()),
              (this.tempPlane1 = new ar()),
              (this.tempPlane2 = new ar()),
              (this.tempPlane_Cut = new ar()),
              (this.tempCM1 = new ei()),
              (this.tempCM2 = new ei()),
              (this.tempVector3 = new ei()),
              (this.tempVector3_2 = new ei()),
              (this.tempVector3_3 = new ei()),
              (this.tempVector3_P0 = new ei()),
              (this.tempVector3_P1 = new ei()),
              (this.tempVector3_P2 = new ei()),
              (this.tempVector3_N0 = new ei()),
              (this.tempVector3_N1 = new ei()),
              (this.tempVector3_AB = new ei()),
              (this.tempVector3_CB = new ei()),
              (this.tempResultObjects = { object1: null, object2: null }),
              (this.segments = [])
            for (var n = 0; n < 900; n++) this.segments[n] = !1
          }
        var Jm
        ;(Zm.prototype = {
          constructor: Zm,
          prepareBreakableObject: function (t, e, n, i, r) {
            t.geometry.isBufferGeometry ||
              console.error(
                'THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.'
              ),
              (t.userData.ammoPhysicsData = {})
            var s = t.userData.ammoPhysicsData
            ;(s.mass = e), (s.velocity = n.clone()), (s.angularVelocity = i.clone()), (s.breakable = r)
          },
          subdivideByImpact: function (t, e, n, i, r) {
            var s = [],
              o = this.tempPlane1,
              a = this.tempPlane2
            this.tempVector3.addVectors(e, n), o.setFromCoplanarPoints(e, t.position, this.tempVector3)
            var l = r + i,
              c = this
            return (
              (function r(h, u, d, p) {
                if (Math.random() < 0.05 * p || p > l) s.push(h)
                else {
                  var m = Math.PI
                  0 === p
                    ? (a.normal.copy(o.normal), (a.constant = o.constant))
                    : p <= i
                    ? ((m = (d - u) * (0.2 + 0.6 * Math.random()) + u),
                      c.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(n, m).add(e),
                      a.setFromCoplanarPoints(e, c.tempVector3, c.tempVector3_2))
                    : ((m = (0.5 * (1 & p) + 0.2 * (2 - Math.random())) * Math.PI),
                      c.tempVector3_2.copy(e).sub(h.position).applyAxisAngle(n, m).add(h.position),
                      c.tempVector3_3.copy(n).add(h.position),
                      a.setFromCoplanarPoints(h.position, c.tempVector3_3, c.tempVector3_2)),
                    c.cutByPlane(h, a, c.tempResultObjects)
                  var f = c.tempResultObjects.object1,
                    g = c.tempResultObjects.object2
                  f && r(f, u, m, p + 1), g && r(g, m, d, p + 1)
                }
              })(t, 0, 2 * Math.PI, 0),
              s
            )
          },
          cutByPlane: function (t, e, n) {
            var i = t.geometry,
              r = i.attributes.position.array,
              s = i.attributes.normal.array,
              o = r.length / 3,
              a = o / 3,
              l = i.getIndex()
            function c(t, e) {
              var n = 3 * t + e
              return l ? l[n] : n
            }
            l && (a = (l = l.array).length / 3)
            for (var h = [], u = [], d = this.smallDelta, p = o * o, m = 0; m < p; m++) this.segments[m] = !1
            var f = this.tempVector3_P0,
              g = this.tempVector3_P1,
              v = this.tempVector3_N0,
              y = this.tempVector3_N1
            for (m = 0; m < a - 1; m++) {
              var x = c(m, 0),
                b = c(m, 1),
                w = c(m, 2)
              v.set(s[x], s[x] + 1, s[x] + 2)
              for (var _ = m + 1; _ < a; _++) {
                var M = c(_, 0),
                  T = c(_, 1),
                  S = c(_, 2)
                y.set(s[M], s[M] + 1, s[M] + 2),
                  1 - v.dot(y) < d &&
                    (x === M || x === T || x === S
                      ? b === M || b === T || b === S
                        ? ((this.segments[x * o + b] = !0), (this.segments[b * o + x] = !0))
                        : ((this.segments[w * o + x] = !0), (this.segments[x * o + w] = !0))
                      : (b !== M && b !== T && b !== S) ||
                        ((this.segments[w * o + b] = !0), (this.segments[b * o + w] = !0)))
              }
            }
            var E = this.tempPlane_Cut
            for (t.updateMatrix(), Zm.transformPlaneToLocalSpace(e, t.matrix, E), m = 0; m < a; m++)
              for (var A = c(m, 0), L = c(m, 1), R = c(m, 2), P = 0; P < 3; P++) {
                var C = 0 === P ? A : 1 === P ? L : R,
                  I = 0 === P ? L : 1 === P ? R : A
                if (!this.segments[C * o + I]) {
                  ;(this.segments[C * o + I] = !0),
                    (this.segments[I * o + C] = !0),
                    f.set(r[3 * C], r[3 * C + 1], r[3 * C + 2]),
                    g.set(r[3 * I], r[3 * I + 1], r[3 * I + 2])
                  var D = 0
                  ;(O = E.distanceToPoint(f)) > d
                    ? ((D = 2), u.push(f.clone()))
                    : O < -d
                    ? ((D = 1), h.push(f.clone()))
                    : ((D = 3), h.push(f.clone()), u.push(f.clone()))
                  var O,
                    N = 0
                  if (
                    ((O = E.distanceToPoint(g)) > d
                      ? ((N = 2), u.push(g.clone()))
                      : O < -d
                      ? ((N = 1), h.push(g.clone()))
                      : ((N = 3), h.push(g.clone()), u.push(g.clone())),
                    (1 === D && 2 === N) || (2 === D && 1 === N))
                  ) {
                    this.tempLine1.start.copy(f), this.tempLine1.end.copy(g)
                    var B = new ei()
                    if (void 0 === (B = E.intersectLine(this.tempLine1, B)))
                      return (
                        console.error('Internal error: segment does not intersect plane.'),
                        (n.segmentedObject1 = null),
                        (n.segmentedObject2 = null),
                        0
                      )
                    h.push(B), u.push(B.clone())
                  }
                }
              }
            var F = 0.5 * t.userData.ammoPhysicsData.mass
            this.tempCM1.set(0, 0, 0)
            var z = 0,
              k = h.length
            if (k > 0) {
              for (m = 0; m < k; m++) this.tempCM1.add(h[m])
              for (this.tempCM1.divideScalar(k), m = 0; m < k; m++)
                (G = h[m]).sub(this.tempCM1), (z = Math.max(z, G.x, G.y, G.z))
              this.tempCM1.add(t.position)
            }
            this.tempCM2.set(0, 0, 0)
            var U = 0,
              H = u.length
            if (H > 0) {
              for (m = 0; m < H; m++) this.tempCM2.add(u[m])
              for (this.tempCM2.divideScalar(H), m = 0; m < H; m++) {
                var G
                ;(G = u[m]).sub(this.tempCM2), (U = Math.max(U, G.x, G.y, G.z))
              }
              this.tempCM2.add(t.position)
            }
            var V = null,
              W = null,
              j = 0
            if (k > 4)
              try {
                ;(V = new gs(Ym(h), t.material)).position.copy(this.tempCM1),
                  V.quaternion.copy(t.quaternion),
                  (V.userData = t.userData),
                  this.prepareBreakableObject(
                    V,
                    F,
                    t.userData.ammoPhysicsData.velocity,
                    t.userData.ammoPhysicsData.angularVelocity,
                    2 * z > this.minSizeForBreak
                  ),
                  j++
              } catch (t) {
                Sm('Error in ConvexObjectBreaker.ts'), Sm(t)
              }
            if (H > 4)
              try {
                ;(W = new gs(Ym(u), t.material)).position.copy(this.tempCM2),
                  W.quaternion.copy(t.quaternion),
                  (W.userData = t.userData),
                  this.prepareBreakableObject(
                    W,
                    F,
                    t.userData.ammoPhysicsData.velocity,
                    t.userData.ammoPhysicsData.angularVelocity,
                    2 * U > this.minSizeForBreak
                  ),
                  j++
              } catch (t) {
                Sm('Error in ConvexObjectBreaker.ts'), Sm(t)
              }
            return (n.object1 = V), (n.object2 = W), j
          }
        }),
          (Zm.transformFreeVector = function (t, e) {
            var n = t.x,
              i = t.y,
              r = t.z,
              s = e.elements
            return (
              (t.x = s[0] * n + s[4] * i + s[8] * r),
              (t.y = s[1] * n + s[5] * i + s[9] * r),
              (t.z = s[2] * n + s[6] * i + s[10] * r),
              t
            )
          }),
          (Zm.transformFreeVectorInverse = function (t, e) {
            var n = t.x,
              i = t.y,
              r = t.z,
              s = e.elements
            return (
              (t.x = s[0] * n + s[1] * i + s[2] * r),
              (t.y = s[4] * n + s[5] * i + s[6] * r),
              (t.z = s[8] * n + s[9] * i + s[10] * r),
              t
            )
          }),
          (Zm.transformTiedVectorInverse = function (t, e) {
            var n = t.x,
              i = t.y,
              r = t.z,
              s = e.elements
            return (
              (t.x = s[0] * n + s[1] * i + s[2] * r - s[12]),
              (t.y = s[4] * n + s[5] * i + s[6] * r - s[13]),
              (t.z = s[8] * n + s[9] * i + s[10] * r - s[14]),
              t
            )
          }),
          (Zm.transformPlaneToLocalSpace =
            ((Jm = new ei()),
            function (t, e, n) {
              n.normal.copy(t.normal), (n.constant = t.constant)
              var i = Zm.transformTiedVectorInverse(t.coplanarPoint(Jm), e)
              Zm.transformFreeVectorInverse(n.normal, e), (n.constant = -i.dot(n.normal))
            }))
        const Km = (() => {
            try {
              if ('object' == typeof WebAssembly && 'function' == typeof WebAssembly.instantiate) {
                const t = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0))
                if (t instanceof WebAssembly.Module) return new WebAssembly.Instance(t) instanceof WebAssembly.Instance
              }
            } catch (t) {
              console.error(t.message)
            }
            return !1
          })(),
          Qm = (t, e) => {
            ;((t, e) => {
              var n = document.createElement('script')
              ;(n.onload = () => {
                e()
              }),
                (n.onerror = () => {
                  throw new Error(`failed to load ${t}`)
                }),
                (n.async = !0),
                (n.src = t),
                document.head.appendChild(n)
            })(Km ? `${t}/ammo.wasm.js` : `${t}/ammo.js`, () => e())
          },
          $m = (t, e) => {
            'undefined' != typeof window && (window.__loadPhysics = !0),
              Qm(t, () => {
                Ammo().then(() => {
                  e()
                })
              })
          },
          tf = (t, e) => {
            e.forEach(e => {
              Object.getOwnPropertyNames(e.prototype).forEach(n => {
                Object.defineProperty(t.prototype, n, Object.getOwnPropertyDescriptor(e.prototype, n))
              })
            })
          }
        class ef {
          constructor(t) {
            this.physics = t
          }
          setRayFromWorld(t = 0, e = 0, n = 0) {
            this._btRayFrom.setValue(t, e, n)
          }
          setRayToWorld(t = 0, e = 0, n = 0) {
            this._btRayTo.setValue(t, e, n)
          }
          hasHit() {
            return this._btRayCallback.hasHit()
          }
          rayTest() {
            void 0 !== this._btRayCallback && Ammo.destroy(this._btRayCallback),
              (this._btRayCallback =
                'closest' === this.type
                  ? new Ammo.ClosestRayResultCallback(this._btRayFrom, this._btRayTo)
                  : new Ammo.AllHitsRayResultCallback(this._btRayFrom, this._btRayTo)),
              this.physics.physicsWorld.rayTest(this._btRayFrom, this._btRayTo, this._btRayCallback)
          }
          destroy() {
            void 0 !== this._btRayFrom && Ammo.destroy(this._btRayFrom),
              void 0 !== this._btRayTo && Ammo.destroy(this._btRayTo),
              void 0 !== this._btRayCallback && Ammo.destroy(this._btRayCallback)
          }
        }
        class nf {
          constructor(t) {
            ;(this.physics = t),
              (this.type = 'closest'),
              (this._btRayFrom = new Ammo.btVector3(0, 0, 0)),
              (this._btRayTo = new Ammo.btVector3(0, 0, 0))
          }
        }
        class rf {
          constructor(t) {
            ;(this.physics = t),
              (this.type = 'allHits'),
              (this._btRayFrom = new Ammo.btVector3(0, 0, 0)),
              (this._btRayTo = new Ammo.btVector3(0, 0, 0))
          }
        }
        tf(nf, [
          ef,
          class {
            constructor(t) {
              this.physics = t
            }
            getHitPointWorld() {
              const t = this._btRayCallback.get_m_hitPointWorld()
              return { x: t.x(), y: t.y(), z: t.z() }
            }
            getHitNormalWorld() {
              const t = this._btRayCallback.get_m_hitNormalWorld()
              return { x: t.x(), y: t.y(), z: t.z() }
            }
            getCollisionObject() {
              return Ammo.castObject(this._btRayCallback.get_m_collisionObject(), Ammo.btRigidBody).threeObject
            }
          }
        ]),
          tf(rf, [
            ef,
            class {
              constructor(t) {
                this.physics = t
              }
              getHitPointsWorld() {
                const t = this._btRayCallback.get_m_hitPointWorld(),
                  e = []
                for (let n = t.size() - 1; n >= 0; n--) {
                  const i = t.at(n)
                  e.push({ x: i.x(), y: i.y(), z: i.z() })
                }
                return e
              }
              getHitPointWorld() {
                return (
                  console.warn(
                    '[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!'
                  ),
                  this.getHitPointsWorld()
                )
              }
              getHitNormalsWorld() {
                const t = this._btRayCallback.get_m_hitNormalWorld(),
                  e = []
                for (let n = t.size() - 1; n >= 0; n--) {
                  const i = t.at(n)
                  e.push({ x: i.x(), y: i.y(), z: i.z() })
                }
                return e
              }
              getCollisionObjects() {
                const t = [],
                  e = this._btRayCallback.get_m_collisionObjects()
                for (let n = e.size() - 1; n >= 0; n--) {
                  const i = Ammo.castObject(e.at(n), Ammo.btRigidBody)
                  t.push(i.threeObject)
                }
                return t
              }
            }
          ])
        class sf extends Lm.Events {
          constructor(t, e = {}) {
            super(),
              (this.scene = t),
              (this.config = e),
              (this.rigidBodies = []),
              (this.earlierDetectedCollisions = []),
              (this.complexShapes = ['plane', 'hull', 'hacd', 'vhacd', 'convexMesh', 'concaveMesh']),
              (this.gravity = e.gravity || { x: 0, y: -9.81, z: 0 }),
              (this.isHeadless = 'headless' === t),
              (this.tmpEuler = new Gi()),
              (this.tmpQuaternion = new ti()),
              (this.tmpVector3 = new ei()),
              (this.tmpVector3a = new ei()),
              (this.tmpMatrix4 = new Ii()),
              (this.tmpMatrix4a = new Ii()),
              (this.tmpBtVector3 = new Ammo.btVector3()),
              (this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1)),
              (this.emptyV3 = new ei()),
              (this.impactPoint = new ei()),
              (this.impactNormal = new ei()),
              'headless' !== t && (this.defaultMaterial = new Gm()),
              this.start()
          }
          get tmpTrans() {
            return console.warn('Use worldTransform instead of tmpTrans.'), this.worldTransform
          }
          set tmpTrans(t) {
            console.warn('Use worldTransform instead of tmpTrans.'), (this.worldTransform = t)
          }
          destroy(t) {
            var e
            const n = Object.keys(t).includes('body') ? t.body : t
            if (void 0 === (null == n ? void 0 : n.ammo)) return
            const i = n.ammo.name
            let r = n.ammo.threeObject
            if (i && r && (null === (e = null == r ? void 0 : r.body) || void 0 === e ? void 0 : e.ammo)) {
              r.body.isSoftBody
                ? this.physicsWorld.removeSoftBody(r.body.ammo)
                : this.physicsWorld.removeRigidBody(r.body.ammo),
                r.body.destructor(),
                (r.body = void 0),
                (r.hasBody = !1),
                delete n.ammo.threeObject
              for (let t = 0; t < this.rigidBodies.length; t++)
                this.rigidBodies[t].name === i && (this.rigidBodies.splice(t, 1), t--)
            }
            'headless' === this.scene && r && (r = null)
          }
          setup() {
            if (
              ((this.worldTransform = new Ammo.btTransform()),
              'function' == typeof this.config.setupPhysicsWorld
                ? (this.physicsWorld = this.config.setupPhysicsWorld())
                : (this.physicsWorld = this.setupPhysicsWorld()),
              'headless' !== this.scene)
            ) {
              ;(this.convexBreaker = new Zm()), (this.objectsToRemove = []), (this.numObjectsToRemove = 0)
              for (let t = 0; t < 500; t++) this.objectsToRemove[t] = null
            }
            ;(this.collisionEvents = new jm()),
              (this.factory = new Wm(this.scene)),
              (this.shapes = new (class {
                constructor(t, e) {
                  ;(this.factory = t), (this.addExisting = e)
                }
                addPlane(t = {}, e = {}) {
                  const n = this.factory.add.plane(t, e)
                  return this.addExisting(n, t), n
                }
                addSphere(t = {}, e = {}) {
                  const n = this.factory.add.sphere(t, e)
                  return this.addExisting(n, t), n
                }
                addBox(t = {}, e = {}) {
                  const n = this.factory.add.box(t, e)
                  return this.addExisting(n, t), n
                }
                addGround(t, e = {}) {
                  const n = this.factory.add.ground(t, e),
                    i = Object.assign(Object.assign({}, t), { mass: 0, collisionFlags: 1 })
                  return this.addExisting(n, i), n
                }
                addCylinder(t = {}, e = {}) {
                  const n = this.factory.add.cylinder(t, e)
                  return this.addExisting(n, t), n
                }
                addCone(t = {}, e = {}) {
                  const n = this.factory.add.cone(t, e)
                  return this.addExisting(n, t), n
                }
                addTorus(t = {}, e = {}) {
                  const n = this.factory.add.torus(t, e)
                  return this.addExisting(n, t), n
                }
                addExtrude(t, e = {}) {
                  const n = this.factory.add.extrude(t, e)
                  return n.translateX(1), this.addExisting(n), n
                }
              })(this.factory, (t, e) => this.addExisting(t, e))),
              (this.constraints = new Am(this.worldTransform, this.physicsWorld)),
              'headless' !== this.scene &&
                (this.debugDrawer = new (class {
                  constructor(t, e, n = {}) {
                    ;(this.scene = t), (this.world = e), (this.options = n), (this.debugDrawMode = n.debugDrawMode || 1)
                    const i = 32768 & this.debugDrawMode || !1,
                      r = n.maxBufferSize || 1e6
                    this.geometry = new Qr()
                    const s = new Float32Array(3 * r),
                      o = new Float32Array(3 * r)
                    this.geometry.setAttribute('position', new Cr(s, 3).setUsage(Rn)),
                      this.geometry.setAttribute('color', new Cr(o, 3).setUsage(Rn)),
                      (this.index = 0)
                    const a = new Nl({ vertexColors: !0, depthTest: !i })
                    ;(this.mesh = new Wl(this.geometry, a)),
                      i && (this.mesh.renderOrder = 999),
                      (this.mesh.frustumCulled = !1),
                      (this.enabled = !1),
                      (this.debugDrawer = new Ammo.DebugDrawer()),
                      (this.debugDrawer.drawLine = this.drawLine.bind(this)),
                      (this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this)),
                      (this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this)),
                      (this.debugDrawer.draw3dText = this.draw3dText.bind(this)),
                      (this.debugDrawer.setDebugMode = this.setDebugMode.bind(this)),
                      (this.debugDrawer.getDebugMode = this.getDebugMode.bind(this)),
                      this.world.setDebugDrawer(this.debugDrawer)
                  }
                  enable() {
                    ;(this.enabled = !0), this.scene.add(this.mesh)
                  }
                  disable() {
                    ;(this.enabled = !1), this.scene.remove(this.mesh)
                  }
                  update() {
                    this.enabled &&
                      (0 != this.index &&
                        ((this.geometry.attributes.position.needsUpdate = !0),
                        (this.geometry.attributes.color.needsUpdate = !0)),
                      (this.index = 0),
                      this.world.debugDrawWorld(),
                      this.geometry.setDrawRange(0, this.index))
                  }
                  drawLine(t, e, n) {
                    const i = Ammo.HEAPF32,
                      r = i[(n + 0) / 4],
                      s = i[(n + 4) / 4],
                      o = i[(n + 8) / 4],
                      a = i[(t + 0) / 4],
                      l = i[(t + 4) / 4],
                      c = i[(t + 8) / 4]
                    this.geometry.attributes.position.setXYZ(this.index, a, l, c),
                      this.geometry.attributes.color.setXYZ(this.index++, r, s, o)
                    const h = i[(e + 0) / 4],
                      u = i[(e + 4) / 4],
                      d = i[(e + 8) / 4]
                    this.geometry.attributes.position.setXYZ(this.index, h, u, d),
                      this.geometry.attributes.color.setXYZ(this.index++, r, s, o)
                  }
                  drawContactPoint(t, e, n, i, r) {
                    const s = Ammo.HEAPF32,
                      o = s[(r + 0) / 4],
                      a = s[(r + 4) / 4],
                      l = s[(r + 8) / 4],
                      c = s[(t + 0) / 4],
                      h = s[(t + 4) / 4],
                      u = s[(t + 8) / 4]
                    this.geometry.attributes.position.setXYZ(this.index, c, h, u),
                      this.geometry.attributes.color.setXYZ(this.index++, o, a, l)
                    const d = s[(e + 0) / 4] * n,
                      p = s[(e + 4) / 4] * n,
                      m = s[(e + 8) / 4] * n
                    this.geometry.attributes.position.setXYZ(this.index, c + d, h + p, u + m),
                      this.geometry.attributes.color.setXYZ(this.index++, o, a, l)
                  }
                  reportErrorWarning(t) {
                    Ammo.hasOwnProperty('Pointer_stringify')
                      ? console.warn(Ammo.Pointer_stringify(t))
                      : this.warnedOnce ||
                        ((this.warnedOnce = !0),
                        console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))
                  }
                  draw3dText(t, e) {
                    console.warn('TODO: draw3dText')
                  }
                  setDebugMode(t) {
                    this.debugDrawMode = t
                  }
                  getDebugMode() {
                    return this.debugDrawMode
                  }
                })(this.scene, this.physicsWorld, {}))
          }
          updateDebugger() {
            'headless' !== this.scene && this.debugDrawer && this.debugDrawer.enabled && this.debugDrawer.update()
          }
          setupPhysicsWorld() {
            const t = this.gravity,
              { softBodies: e = !1 } = this.config
            let n
            if (!e) {
              const t = new Ammo.btDefaultCollisionConfiguration(),
                e = new Ammo.btCollisionDispatcher(t),
                i = new Ammo.btDbvtBroadphase(),
                r = new Ammo.btSequentialImpulseConstraintSolver()
              n = new Ammo.btDiscreteDynamicsWorld(e, i, r, t)
            }
            if (e) {
              const t = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(),
                e = new Ammo.btCollisionDispatcher(t),
                i = new Ammo.btDbvtBroadphase(),
                r = new Ammo.btSequentialImpulseConstraintSolver(),
                s = new Ammo.btDefaultSoftBodySolver()
              n = new Ammo.btSoftRigidDynamicsWorld(e, i, r, t, s)
            }
            return n.setGravity(new Ammo.btVector3(t.x, t.y, t.z)), n
          }
          createDebrisFromBreakableObject(t, e) {
            'headless' !== this.scene &&
              ((t.material = e.material),
              (t.shape = 'hull'),
              (t.fragmentDepth = e.fragmentDepth + 1),
              this.scene.add(t),
              this.addExisting(t),
              (t.body.fractureImpulse = e.body.fractureImpulse),
              (t.body.breakable = !1),
              setTimeout(() => {
                t.body.breakable = !0
              }, 2500))
          }
          removeDebris(t) {
            'headless' !== this.scene && (this.scene.remove(t), this.destroy(t))
          }
          update(t) {
            this.updatePhysics(t), this.detectCollisions()
          }
          updatePhysics(t) {
            const e = t / 1e3
            this.physicsWorld.stepSimulation(e, this.config.maxSubSteps || 4, this.config.fixedTimeStep || 1 / 60)
            for (let t = 0; t < this.rigidBodies.length; t++) {
              const e = this.rigidBodies[t],
                n = e.body.ammo.getMotionState()
              if (n)
                if (
                  (n.getWorldTransform(this.worldTransform),
                  e.body.didUpdate &&
                    (e.body._emitUpdateEvents && e.body.eventEmitter.emit('update'), (e.body.didUpdate = !1)),
                  e.body.ammo.isKinematicObject() && e.body.needUpdate)
                )
                  e.getWorldQuaternion(this.tmpQuaternion),
                    e.getWorldPosition(this.tmpVector3),
                    this.tmpBtVector3.setValue(this.tmpVector3.x, this.tmpVector3.y, this.tmpVector3.z),
                    this.tmpBtQuaternion.setValue(
                      this.tmpQuaternion.x,
                      this.tmpQuaternion.y,
                      this.tmpQuaternion.z,
                      this.tmpQuaternion.w
                    ),
                    this.worldTransform.setOrigin(this.tmpBtVector3),
                    this.worldTransform.setRotation(this.tmpBtQuaternion),
                    n.setWorldTransform(this.worldTransform),
                    (e.body.needUpdate = !1)
                else if (e.body.skipUpdate);
                else if (!e.body.ammo.isStaticObject()) {
                  const t = this.worldTransform.getOrigin(),
                    n = this.worldTransform.getRotation(),
                    i = e.body.offset
                  if (e.body.ignoreScale) this.tmpVector3a.set(e.scale.x, e.scale.y, e.scale.z)
                  else {
                    const t = e.body.ammo.getCollisionShape().getLocalScaling()
                    this.tmpVector3a.set(t.x(), t.y(), t.z())
                  }
                  this.tmpVector3.set(t.x() + i.x, t.y() + i.y, t.z() + i.z),
                    this.tmpQuaternion.set(n.x(), n.y(), n.z(), n.w()),
                    this.tmpMatrix4.compose(this.tmpVector3, this.tmpQuaternion, this.tmpVector3a),
                    e.parent
                      ? parseInt(a) >= 123
                        ? this.tmpMatrix4a.copy(e.parent.matrixWorld).invert()
                        : this.tmpMatrix4a.getInverse(e.parent.matrixWorld)
                      : this.tmpMatrix4a.identity(),
                    this.tmpMatrix4a.multiply(this.tmpMatrix4),
                    this.tmpMatrix4a.decompose(e.position, e.quaternion, e.scale)
                }
            }
          }
          detectCollisions() {
            var t, e
            const n = []
            this.impactPoint.set(0, 0, 0), this.impactNormal.set(0, 0, 0)
            const i = this.physicsWorld.getDispatcher(),
              r = i.getNumManifolds()
            for (let s = 0; s < r; s++) {
              const r = i.getManifoldByIndexInternal(s),
                o = r.getNumContacts(),
                a = Ammo.castObject(r.getBody0(), Ammo.btRigidBody),
                l = Ammo.castObject(r.getBody1(), Ammo.btRigidBody),
                c = a.threeObject,
                h = l.threeObject
              if (!c || !h) continue
              if ('' === a.name && '' === l.name) continue
              const u = null === (t = c.body) || void 0 === t ? void 0 : t.checkCollisions,
                d = null === (e = h.body) || void 0 === e ? void 0 : e.checkCollisions,
                p = c.body.breakable,
                m = h.body.breakable,
                f = c.body.fractureImpulse,
                g = h.body.fractureImpulse,
                v = p || m
              if (!u && !d && !v) continue
              let y = !1,
                x = 0,
                b = 'start'
              for (let t = 0; t < o; t++) {
                const e = r.getContactPoint(t)
                if (e.getDistance() <= 0) {
                  y = !0
                  const t = e.getAppliedImpulse(),
                    i = e.get_m_positionWorldOnB(),
                    r = e.get_m_normalWorldOnB()
                  if (u || d) {
                    const t = [c.name, h.name].sort(),
                      e = `${t[0]}__${t[1]}`
                    this.earlierDetectedCollisions.find(t => t.combinedName === e) && (b = 'collision'),
                      n.find(t => t.combinedName === e) ||
                        (n.push({ combinedName: e, collision: !0 }),
                        this.collisionEvents.emit('collision', { bodies: [c, h], event: b }))
                  }
                  t >= x &&
                    ((x = t),
                    (p || m) && (this.impactPoint.set(i.x(), i.y(), i.z()), this.impactNormal.set(r.x(), r.y(), r.z())))
                  break
                }
              }
              if (!y) continue
              if (!v) continue
              const w = 2
              if (
                (this.emptyV3.set(0, 0, 0),
                (c.userData.ammoPhysicsData = {
                  mass: 1,
                  velocity: this.emptyV3,
                  angularVelocity: this.emptyV3,
                  breakable: p,
                  physicsBody: a
                }),
                (h.userData.ammoPhysicsData = {
                  mass: 1,
                  velocity: this.emptyV3,
                  angularVelocity: this.emptyV3,
                  breakable: m,
                  physicsBody: l
                }),
                p && x > f && c.fragmentDepth < w)
              ) {
                const t = this.convexBreaker.subdivideByImpact(c, this.impactPoint, this.impactNormal, 1, 2),
                  e = t.length
                for (let n = 0; n < e; n++) {
                  const e = a.getLinearVelocity(),
                    i = a.getAngularVelocity(),
                    r = t[n]
                  r.userData.ammoPhysicsData.velocity.set(e.x(), e.y(), e.z()),
                    r.userData.ammoPhysicsData.angularVelocity.set(i.x(), i.y(), i.z()),
                    this.createDebrisFromBreakableObject(r, c)
                }
                this.objectsToRemove[this.numObjectsToRemove++] = c
              }
              if (m && x > g && h.fragmentDepth < w) {
                const t = this.convexBreaker.subdivideByImpact(h, this.impactPoint, this.impactNormal, 1, 2),
                  e = t.length
                for (let n = 0; n < e; n++) {
                  const e = l.getLinearVelocity(),
                    i = l.getAngularVelocity(),
                    r = t[n]
                  r.userData.ammoPhysicsData.velocity.set(e.x(), e.y(), e.z()),
                    r.userData.ammoPhysicsData.angularVelocity.set(i.x(), i.y(), i.z()),
                    this.createDebrisFromBreakableObject(r, h)
                }
                this.objectsToRemove[this.numObjectsToRemove++] = h
              }
            }
            for (let t = 0; t < this.numObjectsToRemove; t++) this.removeDebris(this.objectsToRemove[t])
            ;(this.numObjectsToRemove = 0),
              this.earlierDetectedCollisions.forEach(t => {
                const { combinedName: e } = t
                if (!n.find(t => t.combinedName === e)) {
                  const t = e.split('__'),
                    n = this.rigidBodies.find(e => e.name === t[0]),
                    i = this.rigidBodies.find(e => e.name === t[1]),
                    r = 'end'
                  n && i && this.collisionEvents.emit('collision', { bodies: [n, i], event: r })
                }
              }),
              (this.earlierDetectedCollisions = [...n])
          }
          setGravity(t = 0, e = -9.8, n = 0) {
            this.tmpBtVector3.setValue(t, e, n), this.physicsWorld.setGravity(this.tmpBtVector3)
          }
          get debug() {
            return this.isHeadless
              ? null
              : {
                  enable: () => {
                    this.debugDrawer.enable()
                  },
                  mode: (t = 1) => {
                    this.debugDrawer.setDebugMode(t)
                  },
                  disable: () => {
                    this.debugDrawer.disable()
                  }
                }
          }
          start() {
            'undefined' != typeof Ammo
              ? 'function' == typeof Ammo
                ? Ammo().then(() => {
                    this.setup()
                  })
                : this.setup()
              : Sm('Are you sure you included ammo.js?')
          }
          get add() {
            return {
              collider: (t, e, n) => this.collisionEvents.addCollider(t, e, n),
              constraints: this.constraints.addConstraints,
              existing: (t, e) => this.addExisting(t, e),
              plane: (t = {}, e = {}) => this.shapes.addPlane(t, e),
              sphere: (t = {}, e = {}) => this.shapes.addSphere(t, e),
              ground: (t = {}, e = {}) => this.shapes.addGround(t, e),
              box: (t = {}, e = {}) => this.shapes.addBox(t, e),
              cylinder: (t = {}, e = {}) => this.shapes.addCylinder(t, e),
              cone: (t = {}, e = {}) => this.shapes.addCone(t, e),
              torus: (t = {}, e = {}) => this.shapes.addTorus(t, e),
              extrude: (t, e = {}) => this.shapes.addExtrude(t, e),
              raycaster: (t = 'closest') => ('closest' === t ? new nf(this) : new rf(this))
            }
          }
          prepareThreeObjectForCollisionShape(t, e = {}) {
            var n, i
            const { autoCenter: r = !1 } = e,
              s = {
                width: 1,
                height: 1,
                depth: 1,
                radius: 1,
                radiusTop: 1,
                radiusBottom: 1,
                tube: 0.4,
                tubularSegments: 6
              }
            let o = 'unknown'
            const a = (null === (n = t.geometry) || void 0 === n ? void 0 : n.type) || 'unknown'
            ;/box/i.test(a)
              ? (o = 'box')
              : /cone/i.test(a)
              ? (o = 'cone')
              : /cylinder/i.test(a)
              ? (o = 'cylinder')
              : /extrude/i.test(a)
              ? (o = 'extrude')
              : /plane/i.test(a)
              ? (o = 'plane')
              : /sphere/i.test(a)
              ? (o = 'sphere')
              : /torus/i.test(a) && (o = 'torus')
            let l = Object.assign(
              Object.assign({}, s),
              null === (i = null == t ? void 0 : t.geometry) || void 0 === i ? void 0 : i.parameters
            )
            return (
              e.shape ? ((l = Object.assign(Object.assign({}, s), e)), (o = e.shape)) : t.shape && (o = t.shape),
              Object.keys(l).forEach(t => {
                void 0 === l[t] && s[t] && (l[t] = s[t])
              }),
              r && t.geometry.center(),
              'cylinder' === o && (l.radius = e.radius || l.radiusTop),
              'extrude' === o && (o = 'hacd'),
              ('mesh' !== o && 'convex' !== o) || (o = 'convexMesh'),
              'concave' === o && (o = 'concaveMesh'),
              'unknown' === o &&
                (Sm(`Shape for ${null == t ? void 0 : t.name} not recognized! Will fallback to box.`), (o = 'box')),
              { shape: o, params: l, object: t }
            )
          }
          createCollisionShape(t, e, n) {
            const i = (null == n ? void 0 : n.quaternion) ? (null == n ? void 0 : n.quaternion) : new ti(0, 0, 0, 1),
              { axis: r = 'y' } = e,
              s = new Ammo.btVector3(),
              o = null == n ? void 0 : n.geometry
            n && (null == o ? void 0 : o.isGeometry) && (n.geometry = new Qr().fromGeometry(o))
            let a,
              l = {}
            switch (
              (-1 !== this.complexShapes.indexOf(t) &&
                (l = (t => {
                  const e = new Ii().elements,
                    n = [],
                    i = [],
                    r = []
                  return (
                    Fm(t, {}, (t, e, s) => {
                      n.push(t), i.push(e), r.push(s)
                    }),
                    { vertices: n, matrices: i, indexes: r, matrixWorld: e }
                  )
                })(n)),
              t)
            ) {
              case 'box':
                s.setValue(e.width / 2, e.height / 2, e.depth / 2), (a = new Ammo.btBoxShape(s))
                break
              case 'sphere':
                a = new Ammo.btSphereShape(e.radius)
                break
              case 'cylinder':
                switch (r) {
                  case 'y':
                    s.setValue(e.radius, e.height / 2, e.radius), (a = new Ammo.btCylinderShape(s))
                    break
                  case 'x':
                    s.setValue(e.height / 2, e.radius, e.radius), (a = new Ammo.btCylinderShapeX(s))
                    break
                  case 'z':
                    s.setValue(e.radius, e.radius, e.height / 2), (a = new Ammo.btCylinderShapeZ(s))
                }
                break
              case 'cone':
                switch (r) {
                  case 'y':
                    a = new Ammo.btConeShape(e.radius, e.height)
                    break
                  case 'x':
                    a = new Ammo.btConeShapeX(e.radius, e.height)
                    break
                  case 'z':
                    a = new Ammo.btConeShapeZ(e.radius, e.height)
                }
                break
              case 'capsule':
                switch (r) {
                  case 'y':
                    a = new Ammo.btCapsuleShape(e.radius, e.height)
                    break
                  case 'x':
                    a = new Ammo.btCapsuleShapeX(e.radius, e.height)
                    break
                  case 'z':
                    a = new Ammo.btCapsuleShapeZ(e.radius, e.height)
                }
                break
              case 'torus':
                a = ((t, e) => {
                  const { radius: n = 1, tube: i = 0.4, tubularSegments: r = 8 } = t,
                    s = Math.PI,
                    o = r,
                    a = Math.sqrt(2 * i * i - 2 * i * i * Math.cos((2 * s) / o)),
                    l = new Ammo.btVector3(i, s / o + 0.5 * a, i),
                    c = new Ammo.btCylinderShape(l)
                  c.setMargin(0.05)
                  const h = new Ammo.btCompoundShape(),
                    u = new Ammo.btVector3(0, 0, 1),
                    d = new Ammo.btVector3(0, n, 0),
                    p = new Ammo.btQuaternion(e.x, e.y, e.z, e.w)
                  for (let t = 0; t < o; t++) {
                    const e = (2 * t * s) / o,
                      n = d.rotate(u, e),
                      i = new Ammo.btTransform()
                    p.setRotation(u, e + Math.PI / 2),
                      i.setIdentity(),
                      i.setOrigin(n),
                      i.setRotation(p),
                      h.addChildShape(i, c)
                  }
                  return h
                })(e, i)
                break
              case 'plane':
                a = Om(
                  l.vertices,
                  l.matrices,
                  l.indexes,
                  l.matrixWorld,
                  Object.assign(Object.assign({}, e), { concave: !1 })
                )
                break
              case 'hull':
                a = Cm(l.vertices, l.matrices, l.matrixWorld, e)
                break
              case 'hacd':
                a = Im(l.vertices, l.matrices, l.indexes, l.matrixWorld, e)
                break
              case 'vhacd':
                a = Dm(l.vertices, l.matrices, l.indexes, l.matrixWorld, e)
                break
              case 'convexMesh':
                a = Om(
                  l.vertices,
                  l.matrices,
                  l.indexes,
                  l.matrixWorld,
                  Object.assign(Object.assign({}, e), { concave: !1 })
                )
                break
              case 'concaveMesh':
                a = Om(
                  l.vertices,
                  l.matrices,
                  l.indexes,
                  l.matrixWorld,
                  Object.assign(Object.assign({}, e), { concave: !0 })
                )
            }
            Ammo.destroy(s)
            const { x: c, y: h, z: u } = e
            return (
              (c || h || u) && (a.offset = { x: c || 0, y: h || 0, z: u || 0 }),
              Array.isArray(a) && (a = this.mergeCollisionShapesToCompoundShape(a)),
              a
            )
          }
          mergeCollisionShapesToCompoundShape(t) {
            const e = new Ammo.btCompoundShape()
            return (
              t.forEach(t => {
                const n = t._tmp
                if (n) {
                  const { pos: i, quat: r, scale: s, margin: o } = n,
                    a = this.applyPosQuatScaleMargin(t, i, r, s, o)
                  e.addChildShape(a, t)
                } else {
                  const n = new Ammo.btTransform()
                  n.setIdentity(), e.addChildShape(n, t)
                }
              }),
              e
            )
          }
          addExisting(t, e = {}) {
            const { hasBody: n } = t
            if (n) return void console.warn(`[Enable3d]: Object "${t.name}" already has a physical body!`)
            const i = new ei(),
              r = new ti(),
              s = new ei()
            t.getWorldPosition(i), t.getWorldQuaternion(r), t.getWorldScale(s)
            const o = '1' === (e.collisionFlags || 0).toString(2).slice(-1),
              a = '1' === (e.collisionFlags || 0).toString(2).slice(-2, -1),
              {
                shape: l = 'unknown',
                compound: c = [],
                mass: h = o || a ? 0 : 1,
                collisionFlags: u = 0,
                collisionGroup: d = 1,
                collisionMask: p = -1,
                offset: m,
                breakable: f = !1,
                addChildren: g = !0,
                margin: v = 0.01,
                ignoreScale: y = !1,
                fractureImpulse: x = 1
              } = e
            if ((y && s.set(1, 1, 1), c.length >= 1)) {
              const e = c.map(t => this.createCollisionShape(t.shape, t)),
                n = this.mergeCollisionShapesToCompoundShape(e),
                o = this.applyPosQuatScaleMargin(n, i, r, s, v),
                l = this.collisionShapeToRigidBody(n, o, h, a)
              return (
                this.addRigidBodyToWorld(t, l, u, d, p, m),
                (t.body.breakable = f),
                (t.body.fractureImpulse = x),
                void (t.body.ignoreScale = y)
              )
            }
            const b = []
            if ('unknown' !== l || t.isMesh) {
              const n = this.prepareThreeObjectForCollisionShape(t, e),
                i = this.createCollisionShape(n.shape, n.params, n.object)
              b.push(i)
            }
            if (
              ('unknown' === l &&
                g &&
                t.children.length >= 1 &&
                t.children.forEach(t => {
                  if (t.isMesh) {
                    const e = this.prepareThreeObjectForCollisionShape(t),
                      n = this.createCollisionShape(e.shape, e.params, e.object)
                    ;(n._tmp = {
                      pos: t.position.clone(),
                      quat: t.quaternion.clone(),
                      scale: t.scale.clone(),
                      margin: v
                    }),
                      b.push(n)
                  }
                }),
              0 === b.length)
            ) {
              const n = this.prepareThreeObjectForCollisionShape(t, e),
                i = this.createCollisionShape(n.shape, n.params, n.object)
              b.push(i)
            }
            const w = 1 === b.length ? b[0] : this.mergeCollisionShapesToCompoundShape(b),
              _ = this.applyPosQuatScaleMargin(w, i, r, s, v),
              M = this.collisionShapeToRigidBody(w, _, h, a)
            this.addRigidBodyToWorld(t, M, u, d, p, m),
              (t.body.breakable = f),
              (t.body.fractureImpulse = x),
              (t.body.ignoreScale = y)
          }
          addRigidBodyToWorld(t, e, n, i, r, s) {
            this.rigidBodies.push(t), this.physicsWorld.addRigidBody(e, i, r)
            const o = Object.values(e)[0]
            ;(e.name = t.name),
              (t.body = new (class {
                constructor(t, e) {
                  ;(this.physics = t),
                    (this.ammo = e),
                    (this.ignoreScale = !1),
                    (this.isSoftBody = !1),
                    (this.offset = { x: 0, y: 0, z: 0 }),
                    (this.errors = []),
                    (this.checkCollisions = !1),
                    (this.breakable = !1),
                    (this.fractureImpulse = 1),
                    (this.didUpdate = !1),
                    (this.skipUpdate = !1),
                    (this._emitUpdateEvents = !1),
                    (this._needUpdate = !1),
                    (this.tmpEuler = new Gi()),
                    (this.tmpQuaternion = new ti()),
                    (this.tmpBtVector3 = new Ammo.btVector3()),
                    (this.tmpBtVector3_1 = new Ammo.btVector3()),
                    (this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1)),
                    (this.eventEmitter = new Em.Events()),
                    (this.name = e.name)
                }
                destructor() {
                  this.eventEmitter && this.eventEmitter.removeAllListeners(),
                    Ammo.destroy(this.tmpBtVector3),
                    Ammo.destroy(this.tmpBtVector3_1),
                    Ammo.destroy(this.tmpBtQuaternion),
                    Ammo.destroy(this.ammo.getCollisionShape()),
                    Ammo.destroy(this.ammo)
                }
                setupEventEmitter() {
                  void 0 === this.eventEmitter && (this.eventEmitter = new Em.Events())
                }
                get needUpdate() {
                  return this._needUpdate
                }
                set needUpdate(t) {
                  !t && this._needUpdate && (this.didUpdate = !0), (this._needUpdate = t)
                }
                onUpdateEvent(t, e = !1) {
                  this.setupEventEmitter(),
                    (this._emitUpdateEvents = !0),
                    e
                      ? this.eventEmitter.once('update', () => {
                          t()
                        })
                      : this.eventEmitter.on('update', () => {
                          t()
                        })
                }
                get on() {
                  return { update: t => this.onUpdateEvent(t), collision: t => this.onCollision(t) }
                }
                get once() {
                  return { update: t => this.onUpdateEvent(t, !0) }
                }
                onCollision(t) {
                  ;(this.checkCollisions = !0),
                    this.physics.collisionEvents.on('collision', e => {
                      const { bodies: n, event: i } = e
                      n[0].name === this.name ? t(n[1], i) : n[1].name === this.name && t(n[0], i)
                    })
                }
                transform() {
                  const t = this.physics.worldTransform
                  this.ammo.getMotionState().getWorldTransform(t)
                }
                refresh() {
                  const t = this.physics.worldTransform
                  this.ammo.getMotionState().setWorldTransform(t)
                }
                setRotation(t, e, n) {
                  const i = this.tmpEuler.set(t, e, n),
                    r = this.tmpQuaternion.set(0, 0, 0, 1)
                  r.setFromEuler(i), this.tmpBtQuaternion.setValue(0, 0, 0, 1)
                  const s = this.tmpBtQuaternion
                  s.setValue(r.x, r.y, r.z, r.w), this.physics.worldTransform.setRotation(s)
                }
                get rotation() {
                  let t, e, n
                  const i = this.physics.worldTransform.getRotation()
                  let r = this.tmpQuaternion.set(i.x(), i.y(), i.z(), i.w())
                  r.w > 1 && (r = r.normalize())
                  const s = 2 * Math.acos(r.w),
                    o = Math.sqrt(1 - r.w * r.w)
                  return (
                    o < 0.001 ? ((t = r.x), (e = r.y), (n = r.z)) : ((t = r.x / o), (e = r.y / o), (n = r.z / o)),
                    { x: t * s, y: e * s, z: n * s }
                  )
                }
                get quaternion() {
                  const t = this.physics.worldTransform.getRotation()
                  return { x: t.x(), y: t.y(), z: t.z(), w: t.w() }
                }
                setPosition(t, e, n) {
                  this.physics.worldTransform.getOrigin().setValue(t, e, n)
                }
                get position() {
                  const t = this.physics.worldTransform
                  return { x: t.getOrigin().x(), y: t.getOrigin().y(), z: t.getOrigin().z() }
                }
                get velocity() {
                  return {
                    x: this.ammo.getLinearVelocity().x(),
                    y: this.ammo.getLinearVelocity().y(),
                    z: this.ammo.getLinearVelocity().z()
                  }
                }
                get angularVelocity() {
                  return {
                    x: this.ammo.getAngularVelocity().x(),
                    y: this.ammo.getAngularVelocity().y(),
                    z: this.ammo.getAngularVelocity().z()
                  }
                }
                setVelocity(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.setLinearVelocity(this.tmpBtVector3)
                }
                setVelocityX(t) {
                  this.tmpBtVector3.setValue(t, this.velocity.y, this.velocity.z),
                    this.ammo.setLinearVelocity(this.tmpBtVector3)
                }
                setVelocityY(t) {
                  this.tmpBtVector3.setValue(this.velocity.x, t, this.velocity.z),
                    this.ammo.setLinearVelocity(this.tmpBtVector3)
                }
                setVelocityZ(t) {
                  this.tmpBtVector3.setValue(this.velocity.x, this.velocity.y, t),
                    this.ammo.setLinearVelocity(this.tmpBtVector3)
                }
                setAngularVelocity(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.setAngularVelocity(this.tmpBtVector3)
                }
                setAngularVelocityX(t) {
                  this.tmpBtVector3.setValue(t, this.angularVelocity.y, this.angularVelocity.z),
                    this.ammo.setAngularVelocity(this.tmpBtVector3)
                }
                setAngularVelocityY(t) {
                  this.tmpBtVector3.setValue(this.angularVelocity.x, t, this.angularVelocity.z),
                    this.ammo.setAngularVelocity(this.tmpBtVector3)
                }
                setAngularVelocityZ(t) {
                  this.tmpBtVector3.setValue(this.angularVelocity.x, this.angularVelocity.y, t),
                    this.ammo.setAngularVelocity(this.tmpBtVector3)
                }
                applyForce(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralImpulse(this.tmpBtVector3)
                }
                applyForceX(t) {
                  this.tmpBtVector3.setValue(t, 0, 0), this.ammo.applyCentralImpulse(this.tmpBtVector3)
                }
                applyForceY(t) {
                  this.tmpBtVector3.setValue(0, t, 0), this.ammo.applyCentralImpulse(this.tmpBtVector3)
                }
                applyForceZ(t) {
                  this.tmpBtVector3.setValue(0, 0, t), this.ammo.applyCentralImpulse(this.tmpBtVector3)
                }
                applyCentralForce(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralForce(this.tmpBtVector3)
                }
                applyCentralImpulse(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralImpulse(this.tmpBtVector3)
                }
                applyCentralLocalForce(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralLocalForce(this.tmpBtVector3)
                }
                applyImpulse(t, e) {
                  this.tmpBtVector3.setValue(t.x || 0, t.y || 0, t.z || 0),
                    this.tmpBtVector3_1.setValue(e.x || 0, e.y || 0, e.z || 0),
                    this.ammo.applyImpulse(this.tmpBtVector3, this.tmpBtVector3_1)
                }
                applyLocalTorque(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyLocalTorque(this.tmpBtVector3)
                }
                applyTorque(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyTorque(this.tmpBtVector3)
                }
                applyTorqueImpulse(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.applyTorqueImpulse(this.tmpBtVector3)
                }
                setCollisionFlags(t) {
                  this.ammo.setCollisionFlags(t)
                }
                getCollisionFlags() {
                  return this.ammo.getCollisionFlags()
                }
                setRestitution(t) {
                  this.ammo.setRestitution(t)
                }
                setBounciness(t) {
                  this.setRestitution(t)
                }
                setFriction(t) {
                  this.ammo.setFriction(t)
                }
                setDamping(t, e) {
                  this.ammo.setDamping(t, e)
                }
                setGravity(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.setGravity(this.tmpBtVector3)
                }
                setLinearFactor(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.setLinearFactor(this.tmpBtVector3)
                }
                setAngularFactor(t, e, n) {
                  this.tmpBtVector3.setValue(t, e, n), this.ammo.setAngularFactor(this.tmpBtVector3)
                }
                setCcdMotionThreshold(t) {
                  this.ammo.setCcdMotionThreshold(t)
                }
                setCcdSweptSphereRadius(t) {
                  this.ammo.setCcdSweptSphereRadius(t)
                }
              })(this, e)),
              (t.hasBody = !0),
              (t.ptr = o),
              (e.threeObject = t),
              s && (t.body.offset = Object.assign({ x: 0, y: 0, z: 0 }, s)),
              t.body.setCollisionFlags(n)
          }
          applyPosQuatScaleMargin(t, e = new ei(), n = new ti(), i = new ei(), r = 0.01) {
            t.setMargin(r)
            const s = new Ammo.btQuaternion(0, 0, 0, 1)
            s.setValue(n.x, n.y, n.z, n.w)
            const o = new Ammo.btTransform()
            o.setIdentity(), o.getOrigin().setValue(e.x, e.y, e.z), o.setRotation(s), Ammo.destroy(s)
            const a = new Ammo.btVector3(i.x, i.y, i.z)
            return t.setLocalScaling(a), Ammo.destroy(a), o
          }
          collisionShapeToRigidBody(t, e, n, i) {
            const r = new Ammo.btDefaultMotionState(e),
              s = new Ammo.btVector3(0, 0, 0)
            n > 0 && t.calculateLocalInertia(n, s)
            const o = new Ammo.btRigidBodyConstructionInfo(n, r, t, s),
              a = new Ammo.btRigidBody(o)
            return (n > 0 || i) && a.setActivationState(4), a
          }
        }
        console.log(
          '%c %c %c %c %c Powered by enable3d v0.22.0-dev.2 %c https://enable3d.io/',
          'background: #ff0000',
          'background: #ffff00',
          'background: #00ff00',
          'background: #00ffff',
          'color: #fff; background: #000000;',
          'background: none'
        )
        var of = {},
          af = Uint8Array,
          lf = Uint16Array,
          cf = Uint32Array,
          hf = new af([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
          uf = new af([
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13,
            0,
            0
          ]),
          df = new af([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
          pf = function (t, e) {
            for (var n = new lf(31), i = 0; i < 31; ++i) n[i] = e += 1 << t[i - 1]
            var r = new cf(n[30])
            for (i = 1; i < 30; ++i) for (var s = n[i]; s < n[i + 1]; ++s) r[s] = ((s - n[i]) << 5) | i
            return [n, r]
          },
          mf = pf(hf, 2),
          ff = mf[0],
          gf = mf[1]
        ;(ff[28] = 258), (gf[258] = 28)
        for (var vf = pf(uf, 0), yf = vf[0], xf = vf[1], bf = new lf(32768), wf = 0; wf < 32768; ++wf) {
          var _f = ((43690 & wf) >>> 1) | ((21845 & wf) << 1)
          ;(_f = ((61680 & (_f = ((52428 & _f) >>> 2) | ((13107 & _f) << 2))) >>> 4) | ((3855 & _f) << 4)),
            (bf[wf] = (((65280 & _f) >>> 8) | ((255 & _f) << 8)) >>> 1)
        }
        var Mf = function (t, e, n) {
            for (var i = t.length, r = 0, s = new lf(e); r < i; ++r) ++s[t[r] - 1]
            var o,
              a = new lf(e)
            for (r = 0; r < e; ++r) a[r] = (a[r - 1] + s[r - 1]) << 1
            if (n) {
              o = new lf(1 << e)
              var l = 15 - e
              for (r = 0; r < i; ++r)
                if (t[r])
                  for (
                    var c = (r << 4) | t[r], h = e - t[r], u = a[t[r] - 1]++ << h, d = u | ((1 << h) - 1);
                    u <= d;
                    ++u
                  )
                    o[bf[u] >>> l] = c
            } else for (o = new lf(i), r = 0; r < i; ++r) t[r] && (o[r] = bf[a[t[r] - 1]++] >>> (15 - t[r]))
            return o
          },
          Tf = new af(288)
        for (wf = 0; wf < 144; ++wf) Tf[wf] = 8
        for (wf = 144; wf < 256; ++wf) Tf[wf] = 9
        for (wf = 256; wf < 280; ++wf) Tf[wf] = 7
        for (wf = 280; wf < 288; ++wf) Tf[wf] = 8
        var Sf = new af(32)
        for (wf = 0; wf < 32; ++wf) Sf[wf] = 5
        var Ef = Mf(Tf, 9, 0),
          Af = Mf(Tf, 9, 1),
          Lf = Mf(Sf, 5, 0),
          Rf = Mf(Sf, 5, 1),
          Pf = function (t) {
            for (var e = t[0], n = 1; n < t.length; ++n) t[n] > e && (e = t[n])
            return e
          },
          Cf = function (t, e, n) {
            var i = (e / 8) | 0
            return ((t[i] | (t[i + 1] << 8)) >> (7 & e)) & n
          },
          If = function (t, e) {
            var n = (e / 8) | 0
            return (t[n] | (t[n + 1] << 8) | (t[n + 2] << 16)) >> (7 & e)
          },
          Df = function (t) {
            return ((t / 8) | 0) + (7 & t && 1)
          },
          Of = function (t, e, n) {
            ;(null == e || e < 0) && (e = 0), (null == n || n > t.length) && (n = t.length)
            var i = new (t instanceof lf ? lf : t instanceof cf ? cf : af)(n - e)
            return i.set(t.subarray(e, n)), i
          },
          Nf = function (t, e, n) {
            var i = t.length
            if (!i || (n && !n.l && i < 5)) return e || new af(0)
            var r = !e || n,
              s = !n || n.i
            n || (n = {}), e || (e = new af(3 * i))
            var o = function (t) {
                var n = e.length
                if (t > n) {
                  var i = new af(Math.max(2 * n, t))
                  i.set(e), (e = i)
                }
              },
              a = n.f || 0,
              l = n.p || 0,
              c = n.b || 0,
              h = n.l,
              u = n.d,
              d = n.m,
              p = n.n,
              m = 8 * i
            do {
              if (!h) {
                n.f = a = Cf(t, l, 1)
                var f = Cf(t, l + 1, 3)
                if (((l += 3), !f)) {
                  var g = t[(A = Df(l) + 4) - 4] | (t[A - 3] << 8),
                    v = A + g
                  if (v > i) {
                    if (s) throw 'unexpected EOF'
                    break
                  }
                  r && o(c + g), e.set(t.subarray(A, v), c), (n.b = c += g), (n.p = l = 8 * v)
                  continue
                }
                if (1 == f) (h = Af), (u = Rf), (d = 9), (p = 5)
                else {
                  if (2 != f) throw 'invalid block type'
                  var y = Cf(t, l, 31) + 257,
                    x = Cf(t, l + 10, 15) + 4,
                    b = y + Cf(t, l + 5, 31) + 1
                  l += 14
                  for (var w = new af(b), _ = new af(19), M = 0; M < x; ++M) _[df[M]] = Cf(t, l + 3 * M, 7)
                  l += 3 * x
                  var T = Pf(_),
                    S = (1 << T) - 1
                  if (!s && l + b * (T + 7) > m) break
                  var E = Mf(_, T, 1)
                  for (M = 0; M < b; ) {
                    var A,
                      L = E[Cf(t, l, S)]
                    if (((l += 15 & L), (A = L >>> 4) < 16)) w[M++] = A
                    else {
                      var R = 0,
                        P = 0
                      for (
                        16 == A
                          ? ((P = 3 + Cf(t, l, 3)), (l += 2), (R = w[M - 1]))
                          : 17 == A
                          ? ((P = 3 + Cf(t, l, 7)), (l += 3))
                          : 18 == A && ((P = 11 + Cf(t, l, 127)), (l += 7));
                        P--;

                      )
                        w[M++] = R
                    }
                  }
                  var C = w.subarray(0, y),
                    I = w.subarray(y)
                  ;(d = Pf(C)), (p = Pf(I)), (h = Mf(C, d, 1)), (u = Mf(I, p, 1))
                }
                if (l > m) throw 'unexpected EOF'
              }
              r && o(c + 131072)
              for (var D = (1 << d) - 1, O = (1 << p) - 1, N = d + p + 18; s || l + N < m; ) {
                var B = (R = h[If(t, l) & D]) >>> 4
                if ((l += 15 & R) > m) throw 'unexpected EOF'
                if (!R) throw 'invalid length/literal'
                if (B < 256) e[c++] = B
                else {
                  if (256 == B) {
                    h = null
                    break
                  }
                  var F = B - 254
                  if (B > 264) {
                    var z = hf[(M = B - 257)]
                    ;(F = Cf(t, l, (1 << z) - 1) + ff[M]), (l += z)
                  }
                  var k = u[If(t, l) & O],
                    U = k >>> 4
                  if (!k) throw 'invalid distance'
                  if (
                    ((l += 15 & k),
                    (I = yf[U]),
                    U > 3 && ((z = uf[U]), (I += If(t, l) & ((1 << z) - 1)), (l += z)),
                    l > m)
                  )
                    throw 'unexpected EOF'
                  r && o(c + 131072)
                  for (var H = c + F; c < H; c += 4)
                    (e[c] = e[c - I]), (e[c + 1] = e[c + 1 - I]), (e[c + 2] = e[c + 2 - I]), (e[c + 3] = e[c + 3 - I])
                  c = H
                }
              }
              ;(n.l = h), (n.p = l), (n.b = c), h && ((a = 1), (n.m = d), (n.d = u), (n.n = p))
            } while (!a)
            return c == e.length ? e : Of(e, 0, c)
          },
          Bf = function (t, e, n) {
            n <<= 7 & e
            var i = (e / 8) | 0
            ;(t[i] |= n), (t[i + 1] |= n >>> 8)
          },
          Ff = function (t, e, n) {
            n <<= 7 & e
            var i = (e / 8) | 0
            ;(t[i] |= n), (t[i + 1] |= n >>> 8), (t[i + 2] |= n >>> 16)
          },
          zf = function (t, e) {
            for (var n = [], i = 0; i < t.length; ++i) t[i] && n.push({ s: i, f: t[i] })
            var r = n.length,
              s = n.slice()
            if (!r) return [jf, 0]
            if (1 == r) {
              var o = new af(n[0].s + 1)
              return (o[n[0].s] = 1), [o, 1]
            }
            n.sort(function (t, e) {
              return t.f - e.f
            }),
              n.push({ s: -1, f: 25001 })
            var a = n[0],
              l = n[1],
              c = 0,
              h = 1,
              u = 2
            for (n[0] = { s: -1, f: a.f + l.f, l: a, r: l }; h != r - 1; )
              (a = n[n[c].f < n[u].f ? c++ : u++]),
                (l = n[c != h && n[c].f < n[u].f ? c++ : u++]),
                (n[h++] = { s: -1, f: a.f + l.f, l: a, r: l })
            var d = s[0].s
            for (i = 1; i < r; ++i) s[i].s > d && (d = s[i].s)
            var p = new lf(d + 1),
              m = kf(n[h - 1], p, 0)
            if (m > e) {
              i = 0
              var f = 0,
                g = m - e,
                v = 1 << g
              for (
                s.sort(function (t, e) {
                  return p[e.s] - p[t.s] || t.f - e.f
                });
                i < r;
                ++i
              ) {
                var y = s[i].s
                if (!(p[y] > e)) break
                ;(f += v - (1 << (m - p[y]))), (p[y] = e)
              }
              for (f >>>= g; f > 0; ) {
                var x = s[i].s
                p[x] < e ? (f -= 1 << (e - p[x]++ - 1)) : ++i
              }
              for (; i >= 0 && f; --i) {
                var b = s[i].s
                p[b] == e && (--p[b], ++f)
              }
              m = e
            }
            return [new af(p), m]
          },
          kf = function (t, e, n) {
            return -1 == t.s ? Math.max(kf(t.l, e, n + 1), kf(t.r, e, n + 1)) : (e[t.s] = n)
          },
          Uf = function (t) {
            for (var e = t.length; e && !t[--e]; );
            for (
              var n = new lf(++e),
                i = 0,
                r = t[0],
                s = 1,
                o = function (t) {
                  n[i++] = t
                },
                a = 1;
              a <= e;
              ++a
            )
              if (t[a] == r && a != e) ++s
              else {
                if (!r && s > 2) {
                  for (; s > 138; s -= 138) o(32754)
                  s > 2 && (o(s > 10 ? ((s - 11) << 5) | 28690 : ((s - 3) << 5) | 12305), (s = 0))
                } else if (s > 3) {
                  for (o(r), --s; s > 6; s -= 6) o(8304)
                  s > 2 && (o(((s - 3) << 5) | 8208), (s = 0))
                }
                for (; s--; ) o(r)
                ;(s = 1), (r = t[a])
              }
            return [n.subarray(0, i), e]
          },
          Hf = function (t, e) {
            for (var n = 0, i = 0; i < e.length; ++i) n += t[i] * e[i]
            return n
          },
          Gf = function (t, e, n) {
            var i = n.length,
              r = Df(e + 2)
            ;(t[r] = 255 & i), (t[r + 1] = i >>> 8), (t[r + 2] = 255 ^ t[r]), (t[r + 3] = 255 ^ t[r + 1])
            for (var s = 0; s < i; ++s) t[r + s + 4] = n[s]
            return 8 * (r + 4 + i)
          },
          Vf = function (t, e, n, i, r, s, o, a, l, c, h) {
            Bf(e, h++, n), ++r[256]
            for (
              var u = zf(r, 15),
                d = u[0],
                p = u[1],
                m = zf(s, 15),
                f = m[0],
                g = m[1],
                v = Uf(d),
                y = v[0],
                x = v[1],
                b = Uf(f),
                w = b[0],
                _ = b[1],
                M = new lf(19),
                T = 0;
              T < y.length;
              ++T
            )
              M[31 & y[T]]++
            for (T = 0; T < w.length; ++T) M[31 & w[T]]++
            for (var S = zf(M, 7), E = S[0], A = S[1], L = 19; L > 4 && !E[df[L - 1]]; --L);
            var R,
              P,
              C,
              I,
              D = (c + 5) << 3,
              O = Hf(r, Tf) + Hf(s, Sf) + o,
              N = Hf(r, d) + Hf(s, f) + o + 14 + 3 * L + Hf(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18])
            if (D <= O && D <= N) return Gf(e, h, t.subarray(l, l + c))
            if ((Bf(e, h, 1 + (N < O)), (h += 2), N < O)) {
              ;(R = Mf(d, p, 0)), (P = d), (C = Mf(f, g, 0)), (I = f)
              var B = Mf(E, A, 0)
              for (Bf(e, h, x - 257), Bf(e, h + 5, _ - 1), Bf(e, h + 10, L - 4), h += 14, T = 0; T < L; ++T)
                Bf(e, h + 3 * T, E[df[T]])
              h += 3 * L
              for (var F = [y, w], z = 0; z < 2; ++z) {
                var k = F[z]
                for (T = 0; T < k.length; ++T) {
                  var U = 31 & k[T]
                  Bf(e, h, B[U]), (h += E[U]), U > 15 && (Bf(e, h, (k[T] >>> 5) & 127), (h += k[T] >>> 12))
                }
              }
            } else (R = Ef), (P = Tf), (C = Lf), (I = Sf)
            for (T = 0; T < a; ++T)
              if (i[T] > 255) {
                ;(U = (i[T] >>> 18) & 31),
                  Ff(e, h, R[U + 257]),
                  (h += P[U + 257]),
                  U > 7 && (Bf(e, h, (i[T] >>> 23) & 31), (h += hf[U]))
                var H = 31 & i[T]
                Ff(e, h, C[H]), (h += I[H]), H > 3 && (Ff(e, h, (i[T] >>> 5) & 8191), (h += uf[H]))
              } else Ff(e, h, R[i[T]]), (h += P[i[T]])
            return Ff(e, h, R[256]), h + P[256]
          },
          Wf = new cf([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
          jf = new af(0),
          qf = function (t, e, n, i, r, s) {
            var o = t.length,
              a = new af(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r),
              l = a.subarray(i, a.length - r),
              c = 0
            if (!e || o < 8)
              for (var h = 0; h <= o; h += 65535) {
                var u = h + 65535
                u < o ? (c = Gf(l, c, t.subarray(h, u))) : ((l[h] = s), (c = Gf(l, c, t.subarray(h, o))))
              }
            else {
              for (
                var d = Wf[e - 1],
                  p = d >>> 13,
                  m = 8191 & d,
                  f = (1 << n) - 1,
                  g = new lf(32768),
                  v = new lf(f + 1),
                  y = Math.ceil(n / 3),
                  x = 2 * y,
                  b = function (e) {
                    return (t[e] ^ (t[e + 1] << y) ^ (t[e + 2] << x)) & f
                  },
                  w = new cf(25e3),
                  _ = new lf(288),
                  M = new lf(32),
                  T = 0,
                  S = 0,
                  E = ((h = 0), 0),
                  A = 0,
                  L = 0;
                h < o;
                ++h
              ) {
                var R = b(h),
                  P = 32767 & h,
                  C = v[R]
                if (((g[P] = C), (v[R] = P), A <= h)) {
                  var I = o - h
                  if ((T > 7e3 || E > 24576) && I > 423) {
                    ;(c = Vf(t, l, 0, w, _, M, S, E, L, h - L, c)), (E = T = S = 0), (L = h)
                    for (var D = 0; D < 286; ++D) _[D] = 0
                    for (D = 0; D < 30; ++D) M[D] = 0
                  }
                  var O = 2,
                    N = 0,
                    B = m,
                    F = (P - C) & 32767
                  if (I > 2 && R == b(h - F))
                    for (
                      var z = Math.min(p, I) - 1, k = Math.min(32767, h), U = Math.min(258, I);
                      F <= k && --B && P != C;

                    ) {
                      if (t[h + O] == t[h + O - F]) {
                        for (var H = 0; H < U && t[h + H] == t[h + H - F]; ++H);
                        if (H > O) {
                          if (((O = H), (N = F), H > z)) break
                          var G = Math.min(F, H - 2),
                            V = 0
                          for (D = 0; D < G; ++D) {
                            var W = (h - F + D + 32768) & 32767,
                              j = (W - g[W] + 32768) & 32767
                            j > V && ((V = j), (C = W))
                          }
                        }
                      }
                      F += ((P = C) - (C = g[P]) + 32768) & 32767
                    }
                  if (N) {
                    w[E++] = 268435456 | (gf[O] << 18) | xf[N]
                    var q = 31 & gf[O],
                      X = 31 & xf[N]
                    ;(S += hf[q] + uf[X]), ++_[257 + q], ++M[X], (A = h + O), ++T
                  } else (w[E++] = t[h]), ++_[t[h]]
                }
              }
              ;(c = Vf(t, l, s, w, _, M, S, E, L, h - L, c)), !s && 7 & c && (c = Gf(l, c + 1, jf))
            }
            return Of(a, 0, i + Df(c) + r)
          },
          Xf = (function () {
            for (var t = new cf(256), e = 0; e < 256; ++e) {
              for (var n = e, i = 9; --i; ) n = (1 & n && 3988292384) ^ (n >>> 1)
              t[e] = n
            }
            return t
          })(),
          Yf = function () {
            var t = -1
            return {
              p: function (e) {
                for (var n = t, i = 0; i < e.length; ++i) n = Xf[(255 & n) ^ e[i]] ^ (n >>> 8)
                t = n
              },
              d: function () {
                return ~t
              }
            }
          },
          Zf = function () {
            var t = 1,
              e = 0
            return {
              p: function (n) {
                for (var i = t, r = e, s = n.length, o = 0; o != s; ) {
                  for (var a = Math.min(o + 2655, s); o < a; ++o) r += i += n[o]
                  ;(i = (65535 & i) + 15 * (i >> 16)), (r = (65535 & r) + 15 * (r >> 16))
                }
                ;(t = i), (e = r)
              },
              d: function () {
                return ((((t %= 65521) >>> 8) << 16) | ((255 & (e %= 65521)) << 8) | (e >>> 8)) + 2 * ((255 & t) << 23)
              }
            }
          },
          Jf = function (t, e, n, i, r) {
            return qf(
              t,
              null == e.level ? 6 : e.level,
              null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem,
              n,
              i,
              !r
            )
          },
          Kf = function (t, e) {
            var n = {}
            for (var i in t) n[i] = t[i]
            for (var i in e) n[i] = e[i]
            return n
          },
          Qf = function (t, e, n) {
            for (
              var i = t(),
                r = t.toString(),
                s = r
                  .slice(r.indexOf('[') + 1, r.lastIndexOf(']'))
                  .replace(/ /g, '')
                  .split(','),
                o = 0;
              o < i.length;
              ++o
            ) {
              var a = i[o],
                l = s[o]
              if ('function' == typeof a) {
                e += ';' + l + '='
                var c = a.toString()
                if (a.prototype)
                  if (-1 != c.indexOf('[native code]')) {
                    var h = c.indexOf(' ', 8) + 1
                    e += c.slice(h, c.indexOf('(', h))
                  } else
                    for (var u in ((e += c), a.prototype))
                      e += ';' + l + '.prototype.' + u + '=' + a.prototype[u].toString()
                else e += c
              } else n[l] = a
            }
            return [e, n]
          },
          $f = [],
          tg = function (t, e, n, i) {
            var r
            if (!$f[n]) {
              for (var s = '', o = {}, a = t.length - 1, l = 0; l < a; ++l) (s = (r = Qf(t[l], s, o))[0]), (o = r[1])
              $f[n] = Qf(t[a], s, o)
            }
            var c = Kf({}, $f[n][1])
            return (function (t, e, n, i, r) {
              var s = of[e] || (of[e] = URL.createObjectURL(new Blob([t], { type: 'text/javascript' }))),
                o = new Worker(s)
              return (
                (o.onerror = function (t) {
                  return r(t.error, null)
                }),
                (o.onmessage = function (t) {
                  return r(null, t.data)
                }),
                o.postMessage(n, i),
                o
              )
            })(
              $f[n][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + e.toString() + '}',
              n,
              c,
              (function (t) {
                var e = []
                for (var n in t)
                  (t[n] instanceof af || t[n] instanceof lf || t[n] instanceof cf) &&
                    e.push((t[n] = new t[n].constructor(t[n])).buffer)
                return e
              })(c),
              i
            )
          },
          eg = function () {
            return [af, lf, cf, hf, uf, df, ff, yf, Af, Rf, bf, Mf, Pf, Cf, If, Df, Of, Nf, Pg, ag, lg]
          },
          ng = function () {
            return [
              af,
              lf,
              cf,
              hf,
              uf,
              df,
              gf,
              xf,
              Ef,
              Tf,
              Lf,
              Sf,
              bf,
              Wf,
              jf,
              Mf,
              Bf,
              Ff,
              zf,
              kf,
              Uf,
              Hf,
              Gf,
              Vf,
              Df,
              Of,
              qf,
              Jf,
              Eg,
              ag
            ]
          },
          ig = function () {
            return [gg, xg, fg, Yf, Xf]
          },
          rg = function () {
            return [vg, yg]
          },
          sg = function () {
            return [bg, fg, Zf]
          },
          og = function () {
            return [wg]
          },
          ag = function (t) {
            return postMessage(t, [t.buffer])
          },
          lg = function (t) {
            return t && t.size && new af(t.size)
          },
          cg = function (t, e, n, i, r, s) {
            var o = tg(n, i, r, function (t, e) {
              o.terminate(), s(t, e)
            })
            return (
              o.postMessage([t, e], e.consume ? [t.buffer] : []),
              function () {
                o.terminate()
              }
            )
          },
          hg = function (t) {
            return (
              (t.ondata = function (t, e) {
                return postMessage([t, e], [t.buffer])
              }),
              function (e) {
                return t.push(e.data[0], e.data[1])
              }
            )
          },
          ug = function (t, e, n, i, r) {
            var s,
              o = tg(t, i, r, function (t, n) {
                t ? (o.terminate(), e.ondata.call(e, t)) : (n[1] && o.terminate(), e.ondata.call(e, t, n[0], n[1]))
              })
            o.postMessage(n),
              (e.push = function (t, n) {
                if (s) throw 'stream finished'
                if (!e.ondata) throw 'no stream handler'
                o.postMessage([t, (s = n)], [t.buffer])
              }),
              (e.terminate = function () {
                o.terminate()
              })
          },
          dg = function (t, e) {
            return t[e] | (t[e + 1] << 8)
          },
          pg = function (t, e) {
            return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + 2 * (t[e + 3] << 23)
          },
          mg = function (t, e) {
            return pg(t, e) | (4294967296 * pg(t, e))
          },
          fg = function (t, e, n) {
            for (; n; ++e) (t[e] = n), (n >>>= 8)
          },
          gg = function (t, e) {
            var n = e.filename
            if (
              ((t[0] = 31),
              (t[1] = 139),
              (t[2] = 8),
              (t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0),
              (t[9] = 3),
              0 != e.mtime && fg(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
              n)
            ) {
              t[3] = 8
              for (var i = 0; i <= n.length; ++i) t[i + 10] = n.charCodeAt(i)
            }
          },
          vg = function (t) {
            if (31 != t[0] || 139 != t[1] || 8 != t[2]) throw 'invalid gzip data'
            var e = t[3],
              n = 10
            4 & e && (n += t[10] | (2 + (t[11] << 8)))
            for (var i = ((e >> 3) & 1) + ((e >> 4) & 1); i > 0; i -= !t[n++]);
            return n + (2 & e)
          },
          yg = function (t) {
            var e = t.length
            return (t[e - 4] | (t[e - 3] << 8) | (t[e - 2] << 16)) + 2 * (t[e - 1] << 23)
          },
          xg = function (t) {
            return 10 + ((t.filename && t.filename.length + 1) || 0)
          },
          bg = function (t, e) {
            var n = e.level,
              i = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2
            ;(t[0] = 120), (t[1] = (i << 6) | (i ? 32 - 2 * i : 1))
          },
          wg = function (t) {
            if (8 != (15 & t[0]) || t[0] >>> 4 > 7 || ((t[0] << 8) | t[1]) % 31) throw 'invalid zlib data'
            if (32 & t[1]) throw 'invalid zlib data: preset dictionaries not supported'
          }
        function _g(t, e) {
          return !e && 'function' == typeof t && ((e = t), (t = {})), (this.ondata = e), t
        }
        var Mg = (function () {
            function t(t, e) {
              !e && 'function' == typeof t && ((e = t), (t = {})), (this.ondata = e), (this.o = t || {})
            }
            return (
              (t.prototype.p = function (t, e) {
                this.ondata(Jf(t, this.o, 0, 0, !e), e)
              }),
              (t.prototype.push = function (t, e) {
                if (this.d) throw 'stream finished'
                if (!this.ondata) throw 'no stream handler'
                ;(this.d = e), this.p(t, e || !1)
              }),
              t
            )
          })(),
          Tg = function (t, e) {
            ug(
              [
                ng,
                function () {
                  return [hg, Mg]
                }
              ],
              this,
              _g.call(this, t, e),
              function (t) {
                var e = new Mg(t.data)
                onmessage = hg(e)
              },
              6
            )
          }
        function Sg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [ng],
            function (t) {
              return ag(Eg(t.data[0], t.data[1]))
            },
            0,
            n
          )
        }
        function Eg(t, e) {
          return Jf(t, e || {}, 0, 0)
        }
        var Ag = (function () {
            function t(t) {
              ;(this.s = {}), (this.p = new af(0)), (this.ondata = t)
            }
            return (
              (t.prototype.e = function (t) {
                if (this.d) throw 'stream finished'
                if (!this.ondata) throw 'no stream handler'
                var e = this.p.length,
                  n = new af(e + t.length)
                n.set(this.p), n.set(t, e), (this.p = n)
              }),
              (t.prototype.c = function (t) {
                this.d = this.s.i = t || !1
                var e = this.s.b,
                  n = Nf(this.p, this.o, this.s)
                this.ondata(Of(n, e, this.s.b), this.d),
                  (this.o = Of(n, this.s.b - 32768)),
                  (this.s.b = this.o.length),
                  (this.p = Of(this.p, (this.s.p / 8) | 0)),
                  (this.s.p &= 7)
              }),
              (t.prototype.push = function (t, e) {
                this.e(t), this.c(e)
              }),
              t
            )
          })(),
          Lg = function (t) {
            ;(this.ondata = t),
              ug(
                [
                  eg,
                  function () {
                    return [hg, Ag]
                  }
                ],
                this,
                0,
                function () {
                  var t = new Ag()
                  onmessage = hg(t)
                },
                7
              )
          }
        function Rg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [eg],
            function (t) {
              return ag(Pg(t.data[0], lg(t.data[1])))
            },
            1,
            n
          )
        }
        function Pg(t, e) {
          return Nf(t, e)
        }
        var Cg = (function () {
            function t(t, e) {
              ;(this.c = Yf()), (this.l = 0), (this.v = 1), Mg.call(this, t, e)
            }
            return (
              (t.prototype.push = function (t, e) {
                Mg.prototype.push.call(this, t, e)
              }),
              (t.prototype.p = function (t, e) {
                this.c.p(t), (this.l += t.length)
                var n = Jf(t, this.o, this.v && xg(this.o), e && 8, !e)
                this.v && (gg(n, this.o), (this.v = 0)),
                  e && (fg(n, n.length - 8, this.c.d()), fg(n, n.length - 4, this.l)),
                  this.ondata(n, e)
              }),
              t
            )
          })(),
          Ig = function (t, e) {
            ug(
              [
                ng,
                ig,
                function () {
                  return [hg, Mg, Cg]
                }
              ],
              this,
              _g.call(this, t, e),
              function (t) {
                var e = new Cg(t.data)
                onmessage = hg(e)
              },
              8
            )
          }
        function Dg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [
              ng,
              ig,
              function () {
                return [Og]
              }
            ],
            function (t) {
              return ag(Og(t.data[0], t.data[1]))
            },
            2,
            n
          )
        }
        function Og(t, e) {
          e || (e = {})
          var n = Yf(),
            i = t.length
          n.p(t)
          var r = Jf(t, e, xg(e), 8),
            s = r.length
          return gg(r, e), fg(r, s - 8, n.d()), fg(r, s - 4, i), r
        }
        var Ng = (function () {
            function t(t) {
              ;(this.v = 1), Ag.call(this, t)
            }
            return (
              (t.prototype.push = function (t, e) {
                if ((Ag.prototype.e.call(this, t), this.v)) {
                  var n = this.p.length > 3 ? vg(this.p) : 4
                  if (n >= this.p.length && !e) return
                  ;(this.p = this.p.subarray(n)), (this.v = 0)
                }
                if (e) {
                  if (this.p.length < 8) throw 'invalid gzip stream'
                  this.p = this.p.subarray(0, -8)
                }
                Ag.prototype.c.call(this, e)
              }),
              t
            )
          })(),
          Bg = function (t) {
            ;(this.ondata = t),
              ug(
                [
                  eg,
                  rg,
                  function () {
                    return [hg, Ag, Ng]
                  }
                ],
                this,
                0,
                function () {
                  var t = new Ng()
                  onmessage = hg(t)
                },
                9
              )
          }
        function Fg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [
              eg,
              rg,
              function () {
                return [zg]
              }
            ],
            function (t) {
              return ag(zg(t.data[0]))
            },
            3,
            n
          )
        }
        function zg(t, e) {
          return Nf(t.subarray(vg(t), -8), e || new af(yg(t)))
        }
        var kg = (function () {
            function t(t, e) {
              ;(this.c = Zf()), (this.v = 1), Mg.call(this, t, e)
            }
            return (
              (t.prototype.push = function (t, e) {
                Mg.prototype.push.call(this, t, e)
              }),
              (t.prototype.p = function (t, e) {
                this.c.p(t)
                var n = Jf(t, this.o, this.v && 2, e && 4, !e)
                this.v && (bg(n, this.o), (this.v = 0)), e && fg(n, n.length - 4, this.c.d()), this.ondata(n, e)
              }),
              t
            )
          })(),
          Ug = function (t, e) {
            ug(
              [
                ng,
                sg,
                function () {
                  return [hg, Mg, kg]
                }
              ],
              this,
              _g.call(this, t, e),
              function (t) {
                var e = new kg(t.data)
                onmessage = hg(e)
              },
              10
            )
          }
        function Hg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [
              ng,
              sg,
              function () {
                return [Gg]
              }
            ],
            function (t) {
              return ag(Gg(t.data[0], t.data[1]))
            },
            4,
            n
          )
        }
        function Gg(t, e) {
          e || (e = {})
          var n = Zf()
          n.p(t)
          var i = Jf(t, e, 2, 4)
          return bg(i, e), fg(i, i.length - 4, n.d()), i
        }
        var Vg = (function () {
            function t(t) {
              ;(this.v = 1), Ag.call(this, t)
            }
            return (
              (t.prototype.push = function (t, e) {
                if ((Ag.prototype.e.call(this, t), this.v)) {
                  if (this.p.length < 2 && !e) return
                  ;(this.p = this.p.subarray(2)), (this.v = 0)
                }
                if (e) {
                  if (this.p.length < 4) throw 'invalid zlib stream'
                  this.p = this.p.subarray(0, -4)
                }
                Ag.prototype.c.call(this, e)
              }),
              t
            )
          })(),
          Wg = function (t) {
            ;(this.ondata = t),
              ug(
                [
                  eg,
                  og,
                  function () {
                    return [hg, Ag, Vg]
                  }
                ],
                this,
                0,
                function () {
                  var t = new Vg()
                  onmessage = hg(t)
                },
                11
              )
          }
        function jg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return cg(
            t,
            e,
            [
              eg,
              og,
              function () {
                return [qg]
              }
            ],
            function (t) {
              return ag(qg(t.data[0], lg(t.data[1])))
            },
            5,
            n
          )
        }
        function qg(t, e) {
          return Nf((wg(t), t.subarray(2, -4)), e)
        }
        var Xg = (function () {
            function t(t) {
              ;(this.G = Ng), (this.I = Ag), (this.Z = Vg), (this.ondata = t)
            }
            return (
              (t.prototype.push = function (t, e) {
                if (!this.ondata) throw 'no stream handler'
                if (this.s) this.s.push(t, e)
                else {
                  if (this.p && this.p.length) {
                    var n = new af(this.p.length + t.length)
                    n.set(this.p), n.set(t, this.p.length)
                  } else this.p = t
                  if (this.p.length > 2) {
                    var i = this,
                      r = function () {
                        i.ondata.apply(i, arguments)
                      }
                    ;(this.s =
                      31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2]
                        ? new this.G(r)
                        : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || ((this.p[0] << 8) | this.p[1]) % 31
                        ? new this.I(r)
                        : new this.Z(r)),
                      this.s.push(this.p, e),
                      (this.p = null)
                  }
                }
              }),
              t
            )
          })(),
          Yg = (function () {
            function t(t) {
              ;(this.G = Bg), (this.I = Lg), (this.Z = Wg), (this.ondata = t)
            }
            return (
              (t.prototype.push = function (t, e) {
                Xg.prototype.push.call(this, t, e)
              }),
              t
            )
          })()
        function Zg(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          return 31 == t[0] && 139 == t[1] && 8 == t[2]
            ? Fg(t, e, n)
            : 8 != (15 & t[0]) || t[0] >> 4 > 7 || ((t[0] << 8) | t[1]) % 31
            ? Rg(t, e, n)
            : jg(t, e, n)
        }
        function Jg(t, e) {
          return 31 == t[0] && 139 == t[1] && 8 == t[2]
            ? zg(t, e)
            : 8 != (15 & t[0]) || t[0] >> 4 > 7 || ((t[0] << 8) | t[1]) % 31
            ? Pg(t, e)
            : qg(t, e)
        }
        var Kg = function (t, e, n, i) {
            for (var r in t) {
              var s = t[r],
                o = e + r
              s instanceof af ? (n[o] = [s, i]) : Array.isArray(s) ? (n[o] = [s[0], Kf(i, s[1])]) : Kg(s, o + '/', n, i)
            }
          },
          Qg = 'undefined' != typeof TextEncoder && new TextEncoder(),
          $g = 'undefined' != typeof TextDecoder && new TextDecoder(),
          tv = 0
        try {
          $g.decode(jf, { stream: !0 }), (tv = 1)
        } catch (t) {}
        var ev = function (t) {
            for (var e = '', n = 0; ; ) {
              var i = t[n++],
                r = (i > 127) + (i > 223) + (i > 239)
              if (n + r > t.length) return [e, Of(t, n - 1)]
              r
                ? 3 == r
                  ? ((i = (((15 & i) << 18) | ((63 & t[n++]) << 12) | ((63 & t[n++]) << 6) | (63 & t[n++])) - 65536),
                    (e += String.fromCharCode(55296 | (i >> 10), 56320 | (1023 & i))))
                  : (e +=
                      1 & r
                        ? String.fromCharCode(((31 & i) << 6) | (63 & t[n++]))
                        : String.fromCharCode(((15 & i) << 12) | ((63 & t[n++]) << 6) | (63 & t[n++])))
                : (e += String.fromCharCode(i))
            }
          },
          nv = (function () {
            function t(t) {
              ;(this.ondata = t), tv ? (this.t = new TextDecoder()) : (this.p = jf)
            }
            return (
              (t.prototype.push = function (t, e) {
                if (!this.ondata) throw 'no callback'
                if ((e || (e = !1), this.t)) return this.ondata(this.t.decode(t, { stream: !e }), e)
                var n = new af(this.p.length + t.length)
                n.set(this.p), n.set(t, this.p.length)
                var i = ev(n),
                  r = i[0],
                  s = i[1]
                if (e && s.length) throw 'invalid utf-8 data'
                ;(this.p = s), this.ondata(r, e)
              }),
              t
            )
          })(),
          iv = (function () {
            function t(t) {
              this.ondata = t
            }
            return (
              (t.prototype.push = function (t, e) {
                if (!this.ondata) throw 'no callback'
                this.ondata(rv(t), e || !1)
              }),
              t
            )
          })()
        function rv(t, e) {
          if (e) {
            for (var n = new af(t.length), i = 0; i < t.length; ++i) n[i] = t.charCodeAt(i)
            return n
          }
          if (Qg) return Qg.encode(t)
          var r = t.length,
            s = new af(t.length + (t.length >> 1)),
            o = 0,
            a = function (t) {
              s[o++] = t
            }
          for (i = 0; i < r; ++i) {
            if (o + 5 > s.length) {
              var l = new af(o + 8 + ((r - i) << 1))
              l.set(s), (s = l)
            }
            var c = t.charCodeAt(i)
            c < 128 || e
              ? a(c)
              : c < 2048
              ? (a(192 | (c >>> 6)), a(128 | (63 & c)))
              : c > 55295 && c < 57344
              ? (a(240 | ((c = (65536 + (1047552 & c)) | (1023 & t.charCodeAt(++i))) >>> 18)),
                a(128 | ((c >>> 12) & 63)),
                a(128 | ((c >>> 6) & 63)),
                a(128 | (63 & c)))
              : (a(224 | (c >>> 12)), a(128 | ((c >>> 6) & 63)), a(128 | (63 & c)))
          }
          return Of(s, 0, o)
        }
        function sv(t, e) {
          if (e) {
            for (var n = '', i = 0; i < t.length; i += 16384)
              n += String.fromCharCode.apply(null, t.subarray(i, i + 16384))
            return n
          }
          if ($g) return $g.decode(t)
          var r = ev(t),
            s = r[0]
          if (r[1].length) throw 'invalid utf-8 data'
          return s
        }
        var ov = function (t) {
            return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0
          },
          av = function (t, e) {
            return e + 30 + dg(t, e + 26) + dg(t, e + 28)
          },
          lv = function (t, e, n) {
            var i = dg(t, e + 28),
              r = sv(t.subarray(e + 46, e + 46 + i), !(2048 & dg(t, e + 8))),
              s = e + 46 + i,
              o = pg(t, e + 20),
              a = n && 4294967295 == o ? cv(t, s) : [o, pg(t, e + 24), pg(t, e + 42)],
              l = a[0],
              c = a[1],
              h = a[2]
            return [dg(t, e + 10), l, c, r, s + dg(t, e + 30) + dg(t, e + 32), h]
          },
          cv = function (t, e) {
            for (; 1 != dg(t, e); e += 4 + dg(t, e + 2));
            return [mg(t, e + 12), mg(t, e + 4), mg(t, e + 20)]
          },
          hv = function (t) {
            var e = 0
            if (t)
              for (var n in t) {
                var i = t[n].length
                if (i > 65535) throw 'extra field too long'
                e += i + 4
              }
            return e
          },
          uv = function (t, e, n, i, r, s, o, a) {
            var l = i.length,
              c = n.extra,
              h = a && a.length,
              u = hv(c)
            fg(t, e, null != o ? 33639248 : 67324752),
              (e += 4),
              null != o && ((t[e++] = 20), (t[e++] = n.os)),
              (t[e] = 20),
              (e += 2),
              (t[e++] = (n.flag << 1) | (null == s && 8)),
              (t[e++] = r && 8),
              (t[e++] = 255 & n.compression),
              (t[e++] = n.compression >> 8)
            var d = new Date(null == n.mtime ? Date.now() : n.mtime),
              p = d.getFullYear() - 1980
            if (p < 0 || p > 119) throw 'date not in range 1980-2099'
            if (
              (fg(
                t,
                e,
                (2 * (p << 24)) |
                  ((d.getMonth() + 1) << 21) |
                  (d.getDate() << 16) |
                  (d.getHours() << 11) |
                  (d.getMinutes() << 5) |
                  (d.getSeconds() >>> 1)
              ),
              (e += 4),
              null != s && (fg(t, e, n.crc), fg(t, e + 4, s), fg(t, e + 8, n.size)),
              fg(t, e + 12, l),
              fg(t, e + 14, u),
              (e += 16),
              null != o && (fg(t, e, h), fg(t, e + 6, n.attrs), fg(t, e + 10, o), (e += 14)),
              t.set(i, e),
              (e += l),
              u)
            )
              for (var m in c) {
                var f = c[m],
                  g = f.length
                fg(t, e, +m), fg(t, e + 2, g), t.set(f, e + 4), (e += 4 + g)
              }
            return h && (t.set(a, e), (e += h)), e
          },
          dv = function (t, e, n, i, r) {
            fg(t, e, 101010256), fg(t, e + 8, n), fg(t, e + 10, n), fg(t, e + 12, i), fg(t, e + 16, r)
          },
          pv = (function () {
            function t(t) {
              ;(this.filename = t), (this.c = Yf()), (this.size = 0), (this.compression = 0)
            }
            return (
              (t.prototype.process = function (t, e) {
                this.ondata(null, t, e)
              }),
              (t.prototype.push = function (t, e) {
                if (!this.ondata) throw 'no callback - add to ZIP archive before pushing'
                this.c.p(t), (this.size += t.length), e && (this.crc = this.c.d()), this.process(t, e || !1)
              }),
              t
            )
          })(),
          mv = (function () {
            function t(t, e) {
              var n = this
              e || (e = {}),
                pv.call(this, t),
                (this.d = new Mg(e, function (t, e) {
                  n.ondata(null, t, e)
                })),
                (this.compression = 8),
                (this.flag = ov(e.level))
            }
            return (
              (t.prototype.process = function (t, e) {
                try {
                  this.d.push(t, e)
                } catch (t) {
                  this.ondata(t, null, e)
                }
              }),
              (t.prototype.push = function (t, e) {
                pv.prototype.push.call(this, t, e)
              }),
              t
            )
          })(),
          fv = (function () {
            function t(t, e) {
              var n = this
              e || (e = {}),
                pv.call(this, t),
                (this.d = new Tg(e, function (t, e, i) {
                  n.ondata(t, e, i)
                })),
                (this.compression = 8),
                (this.flag = ov(e.level)),
                (this.terminate = this.d.terminate)
            }
            return (
              (t.prototype.process = function (t, e) {
                this.d.push(t, e)
              }),
              (t.prototype.push = function (t, e) {
                pv.prototype.push.call(this, t, e)
              }),
              t
            )
          })(),
          gv = (function () {
            function t(t) {
              ;(this.ondata = t), (this.u = []), (this.d = 1)
            }
            return (
              (t.prototype.add = function (t) {
                var e = this
                if (2 & this.d) throw 'stream finished'
                var n = rv(t.filename),
                  i = n.length,
                  r = t.comment,
                  s = r && rv(r),
                  o = i != t.filename.length || (s && r.length != s.length),
                  a = i + hv(t.extra) + 30
                if (i > 65535) throw 'filename too long'
                var l = new af(a)
                uv(l, 0, t, n, o)
                var c = [l],
                  h = function () {
                    for (var t = 0, n = c; t < n.length; t++) {
                      var i = n[t]
                      e.ondata(null, i, !1)
                    }
                    c = []
                  },
                  u = this.d
                this.d = 0
                var d = this.u.length,
                  p = Kf(t, {
                    f: n,
                    u: o,
                    o: s,
                    t: function () {
                      t.terminate && t.terminate()
                    },
                    r: function () {
                      if ((h(), u)) {
                        var t = e.u[d + 1]
                        t ? t.r() : (e.d = 1)
                      }
                      u = 1
                    }
                  }),
                  m = 0
                ;(t.ondata = function (n, i, r) {
                  if (n) e.ondata(n, i, r), e.terminate()
                  else if (((m += i.length), c.push(i), r)) {
                    var s = new af(16)
                    fg(s, 0, 134695760),
                      fg(s, 4, t.crc),
                      fg(s, 8, m),
                      fg(s, 12, t.size),
                      c.push(s),
                      (p.c = m),
                      (p.b = a + m + 16),
                      (p.crc = t.crc),
                      (p.size = t.size),
                      u && p.r(),
                      (u = 1)
                  } else u && h()
                }),
                  this.u.push(p)
              }),
              (t.prototype.end = function () {
                var t = this
                if (2 & this.d) throw 1 & this.d ? 'stream finishing' : 'stream finished'
                this.d
                  ? this.e()
                  : this.u.push({
                      r: function () {
                        1 & t.d && (t.u.splice(-1, 1), t.e())
                      },
                      t: function () {}
                    }),
                  (this.d = 3)
              }),
              (t.prototype.e = function () {
                for (var t = 0, e = 0, n = 0, i = 0, r = this.u; i < r.length; i++)
                  n += 46 + (l = r[i]).f.length + hv(l.extra) + (l.o ? l.o.length : 0)
                for (var s = new af(n + 22), o = 0, a = this.u; o < a.length; o++) {
                  var l = a[o]
                  uv(s, t, l, l.f, l.u, l.c, e, l.o),
                    (t += 46 + l.f.length + hv(l.extra) + (l.o ? l.o.length : 0)),
                    (e += l.b)
                }
                dv(s, t, this.u.length, n, e), this.ondata(null, s, !0), (this.d = 2)
              }),
              (t.prototype.terminate = function () {
                for (var t = 0, e = this.u; t < e.length; t++) e[t].t()
                this.d = 2
              }),
              t
            )
          })()
        function vv(t, e, n) {
          if ((n || ((n = e), (e = {})), 'function' != typeof n)) throw 'no callback'
          var i = {}
          Kg(t, '', i, e)
          var r = Object.keys(i),
            s = r.length,
            o = 0,
            a = 0,
            l = s,
            c = new Array(s),
            h = [],
            u = function () {
              for (var t = 0; t < h.length; ++t) h[t]()
            },
            d = function () {
              var t = new af(a + 22),
                e = o,
                i = a - o
              a = 0
              for (var r = 0; r < l; ++r) {
                var s = c[r]
                try {
                  var h = s.c.length
                  uv(t, a, s, s.f, s.u, h)
                  var u = 30 + s.f.length + hv(s.extra),
                    d = a + u
                  t.set(s.c, d), uv(t, o, s, s.f, s.u, h, a, s.m), (o += 16 + u + (s.m ? s.m.length : 0)), (a = d + h)
                } catch (t) {
                  return n(t, null)
                }
              }
              dv(t, o, c.length, i, e), n(null, t)
            }
          s || d()
          for (
            var p = function (t) {
                var e = r[t],
                  l = i[e],
                  p = l[0],
                  m = l[1],
                  f = Yf(),
                  g = p.length
                f.p(p)
                var v = rv(e),
                  y = v.length,
                  x = m.comment,
                  b = x && rv(x),
                  w = b && b.length,
                  _ = hv(m.extra),
                  M = 0 == m.level ? 0 : 8,
                  T = function (i, r) {
                    if (i) u(), n(i, null)
                    else {
                      var l = r.length
                      ;(c[t] = Kf(m, {
                        size: g,
                        crc: f.d(),
                        c: r,
                        f: v,
                        m: b,
                        u: y != e.length || (b && x.length != w),
                        compression: M
                      })),
                        (o += 30 + y + _ + l),
                        (a += 76 + 2 * (y + _) + (w || 0) + l),
                        --s || d()
                    }
                  }
                if ((y > 65535 && T('filename too long', null), M))
                  if (g < 16e4)
                    try {
                      T(null, Eg(p, m))
                    } catch (t) {
                      T(t, null)
                    }
                  else h.push(Sg(p, m, T))
                else T(null, p)
              },
              m = 0;
            m < l;
            ++m
          )
            p(m)
          return u
        }
        function yv(t, e) {
          e || (e = {})
          var n = {},
            i = []
          Kg(t, '', n, e)
          var r = 0,
            s = 0
          for (var o in n) {
            var a = n[o],
              l = a[0],
              c = a[1],
              h = 0 == c.level ? 0 : 8,
              u = (M = rv(o)).length,
              d = c.comment,
              p = d && rv(d),
              m = p && p.length,
              f = hv(c.extra)
            if (u > 65535) throw 'filename too long'
            var g = h ? Eg(l, c) : l,
              v = g.length,
              y = Yf()
            y.p(l),
              i.push(
                Kf(c, {
                  size: l.length,
                  crc: y.d(),
                  c: g,
                  f: M,
                  m: p,
                  u: u != o.length || (p && d.length != m),
                  o: r,
                  compression: h
                })
              ),
              (r += 30 + u + f + v),
              (s += 76 + 2 * (u + f) + (m || 0) + v)
          }
          for (var x = new af(s + 22), b = r, w = s - r, _ = 0; _ < i.length; ++_) {
            var M = i[_]
            uv(x, M.o, M, M.f, M.u, M.c.length)
            var T = 30 + M.f.length + hv(M.extra)
            x.set(M.c, M.o + T), uv(x, r, M, M.f, M.u, M.c.length, M.o, M.m), (r += 16 + T + (M.m ? M.m.length : 0))
          }
          return dv(x, r, i.length, w, b), x
        }
        var xv = (function () {
            function t() {}
            return (
              (t.prototype.push = function (t, e) {
                this.ondata(null, t, e)
              }),
              (t.compression = 0),
              t
            )
          })(),
          bv = (function () {
            function t() {
              var t = this
              this.i = new Ag(function (e, n) {
                t.ondata(null, e, n)
              })
            }
            return (
              (t.prototype.push = function (t, e) {
                try {
                  this.i.push(t, e)
                } catch (n) {
                  this.ondata(n, t, e)
                }
              }),
              (t.compression = 8),
              t
            )
          })(),
          wv = (function () {
            function t(t, e) {
              var n = this
              e < 32e4
                ? (this.i = new Ag(function (t, e) {
                    n.ondata(null, t, e)
                  }))
                : ((this.i = new Lg(function (t, e, i) {
                    n.ondata(t, e, i)
                  })),
                  (this.terminate = this.i.terminate))
            }
            return (
              (t.prototype.push = function (t, e) {
                this.i.terminate && (t = Of(t, 0)), this.i.push(t, e)
              }),
              (t.compression = 8),
              t
            )
          })(),
          _v = (function () {
            function t(t) {
              ;(this.onfile = t), (this.k = []), (this.o = { 0: xv }), (this.p = jf)
            }
            return (
              (t.prototype.push = function (t, e) {
                var n = this
                if (!this.onfile) throw 'no callback'
                if (this.c > 0) {
                  var i = Math.min(this.c, t.length),
                    r = t.subarray(0, i)
                  if (((this.c -= i), this.d ? this.d.push(r, !this.c) : this.k[0].push(r), (t = t.subarray(i)).length))
                    return this.push(t, e)
                } else {
                  var s = 0,
                    o = 0,
                    a = void 0,
                    l = void 0
                  this.p.length
                    ? t.length
                      ? ((l = new af(this.p.length + t.length)).set(this.p), l.set(t, this.p.length))
                      : (l = this.p)
                    : (l = t)
                  for (
                    var c = l.length,
                      h = this.c,
                      u = h && this.d,
                      d = function () {
                        var t,
                          e = pg(l, o)
                        if (67324752 == e) {
                          ;(s = 1), (a = o), (p.d = null), (p.c = 0)
                          var i = dg(l, o + 6),
                            r = dg(l, o + 8),
                            u = 2048 & i,
                            d = 8 & i,
                            m = dg(l, o + 26),
                            f = dg(l, o + 28)
                          if (c > o + 30 + m + f) {
                            var g = []
                            p.k.unshift(g), (s = 2)
                            var v = pg(l, o + 18),
                              y = pg(l, o + 22),
                              x = sv(l.subarray(o + 30, (o += 30 + m)), !u)
                            4294967295 == v ? ((t = d ? [-2] : cv(l, o)), (v = t[0]), (y = t[1])) : d && (v = -1),
                              (o += f),
                              (p.c = v)
                            var b = {
                              name: x,
                              compression: r,
                              start: function () {
                                if (!b.ondata) throw 'no callback'
                                if (v) {
                                  var t = n.o[r]
                                  if (!t) throw 'unknown compression type ' + r
                                  var e = v < 0 ? new t(x) : new t(x, v, y)
                                  e.ondata = function (t, e, n) {
                                    b.ondata(t, e, n)
                                  }
                                  for (var i = 0, s = g; i < s.length; i++) {
                                    var o = s[i]
                                    e.push(o, !1)
                                  }
                                  n.k[0] == g ? (n.d = e) : e.push(jf, !0)
                                } else b.ondata(null, jf, !0)
                              },
                              terminate: function () {
                                n.k[0] == g && n.d.terminate && n.d.terminate()
                              }
                            }
                            v >= 0 && ((b.size = v), (b.originalSize = y)), p.onfile(b)
                          }
                          return 'break'
                        }
                        if (h) {
                          if (134695760 == e) return (a = o += 12 + (-2 == h && 8)), (s = 2), (p.c = 0), 'break'
                          if (33639248 == e) return (a = o -= 4), (s = 2), (p.c = 0), 'break'
                        }
                      },
                      p = this;
                    o < c - 4 && 'break' !== d();
                    ++o
                  );
                  if (((this.p = jf), h < 0)) {
                    var m = s
                      ? l.subarray(0, a - 12 - (-2 == h && 8) - (134695760 == pg(l, a - 16) && 4))
                      : l.subarray(0, o)
                    u ? u.push(m, !!s) : this.k[+(2 == s)].push(m)
                  }
                  if (2 & s) return this.push(l.subarray(o), e)
                  this.p = l.subarray(o)
                }
                if (e && this.c) throw 'invalid zip file'
              }),
              (t.prototype.register = function (t) {
                this.o[t.compression] = t
              }),
              t
            )
          })()
        function Mv(t, e) {
          if ('function' != typeof e) throw 'no callback'
          for (
            var n = [],
              i = function () {
                for (var t = 0; t < n.length; ++t) n[t]()
              },
              r = {},
              s = t.length - 22;
            101010256 != pg(t, s);
            --s
          )
            if (!s || t.length - s > 65558) return void e('invalid zip file', null)
          var o = dg(t, s + 8)
          o || e(null, {})
          var a = o,
            l = pg(t, s + 16),
            c = 4294967295 == l
          if (c) {
            if (((s = pg(t, s - 12)), 101075792 != pg(t, s))) return void e('invalid zip file', null)
            ;(a = o = pg(t, s + 32)), (l = pg(t, s + 48))
          }
          for (
            var h = function (s) {
                var a = lv(t, l, c),
                  h = a[0],
                  u = a[1],
                  d = a[2],
                  p = a[3],
                  m = a[4],
                  f = a[5],
                  g = av(t, f)
                l = m
                var v = function (t, n) {
                  t ? (i(), e(t, null)) : ((r[p] = n), --o || e(null, r))
                }
                if (h)
                  if (8 == h) {
                    var y = t.subarray(g, g + u)
                    if (u < 32e4)
                      try {
                        v(null, Pg(y, new af(d)))
                      } catch (t) {
                        v(t, null)
                      }
                    else n.push(Rg(y, { size: d }, v))
                  } else v('unknown compression type ' + h, null)
                else v(null, Of(t, g, g + u))
              },
              u = 0;
            u < a;
            ++u
          )
            h()
          return i
        }
        function Tv(t) {
          for (var e = {}, n = t.length - 22; 101010256 != pg(t, n); --n)
            if (!n || t.length - n > 65558) throw 'invalid zip file'
          var i = dg(t, n + 8)
          if (!i) return {}
          var r = pg(t, n + 16),
            s = 4294967295 == r
          if (s) {
            if (((n = pg(t, n - 12)), 101075792 != pg(t, n))) throw 'invalid zip file'
            ;(i = pg(t, n + 32)), (r = pg(t, n + 48))
          }
          for (var o = 0; o < i; ++o) {
            var a = lv(t, r, s),
              l = a[0],
              c = a[1],
              h = a[2],
              u = a[3],
              d = a[4],
              p = a[5],
              m = av(t, p)
            if (((r = d), l)) {
              if (8 != l) throw 'unknown compression type ' + l
              e[u] = Pg(t.subarray(m, m + c), new af(h))
            } else e[u] = Of(t, m, m + c)
          }
          return e
        }
        const Sv = null
        var Ev = {
            findSpan: function (t, e, n) {
              var i = n.length - t - 1
              if (e >= n[i]) return i - 1
              if (e <= n[t]) return t
              for (var r = t, s = i, o = Math.floor((r + s) / 2); e < n[o] || e >= n[o + 1]; )
                e < n[o] ? (s = o) : (r = o), (o = Math.floor((r + s) / 2))
              return o
            },
            calcBasisFunctions: function (t, e, n, i) {
              var r = [],
                s = [],
                o = []
              r[0] = 1
              for (var a = 1; a <= n; ++a) {
                ;(s[a] = e - i[t + 1 - a]), (o[a] = i[t + a] - e)
                for (var l = 0, c = 0; c < a; ++c) {
                  var h = o[c + 1],
                    u = s[a - c],
                    d = r[c] / (h + u)
                  ;(r[c] = l + h * d), (l = u * d)
                }
                r[a] = l
              }
              return r
            },
            calcBSplinePoint: function (t, e, n, i) {
              for (
                var r = this.findSpan(t, i, e), s = this.calcBasisFunctions(r, i, t, e), o = new Kn(0, 0, 0, 0), a = 0;
                a <= t;
                ++a
              ) {
                var l = n[r - t + a],
                  c = s[a],
                  h = l.w * c
                ;(o.x += l.x * h), (o.y += l.y * h), (o.z += l.z * h), (o.w += l.w * c)
              }
              return o
            },
            calcBasisFunctionDerivatives: function (t, e, n, i, r) {
              for (var s = [], o = 0; o <= n; ++o) s[o] = 0
              var a = []
              for (o = 0; o <= i; ++o) a[o] = s.slice(0)
              var l = []
              for (o = 0; o <= n; ++o) l[o] = s.slice(0)
              l[0][0] = 1
              for (var c = s.slice(0), h = s.slice(0), u = 1; u <= n; ++u) {
                ;(c[u] = e - r[t + 1 - u]), (h[u] = r[t + u] - e)
                for (var d = 0, p = 0; p < u; ++p) {
                  var m = h[p + 1],
                    f = c[u - p]
                  l[u][p] = m + f
                  var g = l[p][u - 1] / l[u][p]
                  ;(l[p][u] = d + m * g), (d = f * g)
                }
                l[u][u] = d
              }
              for (u = 0; u <= n; ++u) a[0][u] = l[u][n]
              for (p = 0; p <= n; ++p) {
                var v = 0,
                  y = 1,
                  x = []
                for (o = 0; o <= n; ++o) x[o] = s.slice(0)
                x[0][0] = 1
                for (var b = 1; b <= i; ++b) {
                  var w = 0,
                    _ = p - b,
                    M = n - b
                  p >= b && ((x[y][0] = x[v][0] / l[M + 1][_]), (w = x[y][0] * l[_][M]))
                  var T = p - 1 <= M ? b - 1 : n - p
                  for (u = _ >= -1 ? 1 : -_; u <= T; ++u)
                    (x[y][u] = (x[v][u] - x[v][u - 1]) / l[M + 1][_ + u]), (w += x[y][u] * l[_ + u][M])
                  p <= M && ((x[y][b] = -x[v][b - 1] / l[M + 1][p]), (w += x[y][b] * l[p][M])),
                    (a[b][p] = w),
                    (u = v),
                    (v = y),
                    (y = u)
                }
              }
              for (p = n, b = 1; b <= i; ++b) {
                for (u = 0; u <= n; ++u) a[b][u] *= p
                p *= n - b
              }
              return a
            },
            calcBSplineDerivatives: function (t, e, n, i, r) {
              for (
                var s = r < t ? r : t,
                  o = [],
                  a = this.findSpan(t, i, e),
                  l = this.calcBasisFunctionDerivatives(a, i, t, s, e),
                  c = [],
                  h = 0;
                h < n.length;
                ++h
              ) {
                var u = (p = n[h].clone()).w
                ;(p.x *= u), (p.y *= u), (p.z *= u), (c[h] = p)
              }
              for (var d = 0; d <= s; ++d) {
                for (var p = c[a - t].clone().multiplyScalar(l[d][0]), m = 1; m <= t; ++m)
                  p.add(c[a - t + m].clone().multiplyScalar(l[d][m]))
                o[d] = p
              }
              for (d = s + 1; d <= r + 1; ++d) o[d] = new Kn(0, 0, 0)
              return o
            },
            calcKoverI: function (t, e) {
              for (var n = 1, i = 2; i <= t; ++i) n *= i
              var r = 1
              for (i = 2; i <= e; ++i) r *= i
              for (i = 2; i <= t - e; ++i) r *= i
              return n / r
            },
            calcRationalCurveDerivatives: function (t) {
              for (var e = t.length, n = [], i = [], r = 0; r < e; ++r) {
                var s = t[r]
                ;(n[r] = new ei(s.x, s.y, s.z)), (i[r] = s.w)
              }
              for (var o = [], a = 0; a < e; ++a) {
                var l = n[a].clone()
                for (r = 1; r <= a; ++r) l.sub(o[a - r].clone().multiplyScalar(this.calcKoverI(a, r) * i[r]))
                o[a] = l.divideScalar(i[0])
              }
              return o
            },
            calcNURBSDerivatives: function (t, e, n, i, r) {
              var s = this.calcBSplineDerivatives(t, e, n, i, r)
              return this.calcRationalCurveDerivatives(s)
            },
            calcSurfacePoint: function (t, e, n, i, r, s, o, a) {
              for (
                var l = this.findSpan(t, s, n),
                  c = this.findSpan(e, o, i),
                  h = this.calcBasisFunctions(l, s, t, n),
                  u = this.calcBasisFunctions(c, o, e, i),
                  d = [],
                  p = 0;
                p <= e;
                ++p
              ) {
                d[p] = new Kn(0, 0, 0, 0)
                for (var m = 0; m <= t; ++m) {
                  var f = r[l - t + m][c - e + p].clone(),
                    g = f.w
                  ;(f.x *= g), (f.y *= g), (f.z *= g), d[p].add(f.multiplyScalar(h[m]))
                }
              }
              var v = new Kn(0, 0, 0, 0)
              for (p = 0; p <= e; ++p) v.add(d[p].multiplyScalar(u[p]))
              v.divideScalar(v.w), a.set(v.x, v.y, v.z)
            }
          },
          Av = function (t, e, n, i, r) {
            Uh.call(this),
              (this.degree = t),
              (this.knots = e),
              (this.controlPoints = []),
              (this.startKnot = i || 0),
              (this.endKnot = r || this.knots.length - 1)
            for (var s = 0; s < n.length; ++s) {
              var o = n[s]
              this.controlPoints[s] = new Kn(o.x, o.y, o.z, o.w)
            }
          }
        ;((Av.prototype = Object.create(Uh.prototype)).constructor = Av),
          (Av.prototype.getPoint = function (t, e) {
            var n = e || new ei(),
              i = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]),
              r = Ev.calcBSplinePoint(this.degree, this.knots, this.controlPoints, i)
            return 1 != r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z)
          }),
          (Av.prototype.getTangent = function (t, e) {
            var n = e || new ei(),
              i = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]),
              r = Ev.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, i, 1)
            return n.copy(r[1]).normalize(), n
          })
        var Lv,
          Rv,
          Pv,
          Cv,
          Iv,
          Dv,
          Ov,
          Nv,
          Bv,
          Fv,
          zv,
          kv,
          Uv,
          Hv,
          Gv,
          Vv,
          Wv,
          jv = (function () {
            var t, n, i
            function r(t) {
              Ch.call(this, t)
            }
            function s(t, e) {
              ;(this.textureLoader = t), (this.manager = e)
            }
            function o() {}
            function a() {}
            function l() {}
            function c() {}
            function h(t, e) {
              ;(this.dv = new DataView(t)), (this.offset = 0), (this.littleEndian = void 0 === e || e)
            }
            function u() {}
            function d(t) {
              var e = t.match(/FBXVersion: (\d+)/)
              if (e) return parseInt(e[1])
              throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')
            }
            function p(t) {
              return t / 46186158e3
            }
            ;(r.prototype = Object.assign(Object.create(Ch.prototype), {
              constructor: r,
              load: function (t, e, n, i) {
                var r = this,
                  s = '' === r.path ? Pu.extractUrlBase(t) : r.path,
                  o = new Dh(this.manager)
                o.setPath(r.path),
                  o.setResponseType('arraybuffer'),
                  o.setRequestHeader(r.requestHeader),
                  o.setWithCredentials(r.withCredentials),
                  o.load(
                    t,
                    function (n) {
                      try {
                        e(r.parse(n, s))
                      } catch (e) {
                        i ? i(e) : console.error(e), r.manager.itemError(t)
                      }
                    },
                    n,
                    i
                  )
              },
              parse: function (e, n) {
                if (((o = 'Kaydara FBX Binary  \0'), (r = e).byteLength >= o.length && o === w(r, 0, o.length)))
                  t = new c().parse(e)
                else {
                  var i = w(e)
                  if (
                    !(function (t) {
                      var e,
                        n,
                        i = [
                          'K',
                          'a',
                          'y',
                          'd',
                          'a',
                          'r',
                          'a',
                          '\\',
                          'F',
                          'B',
                          'X',
                          '\\',
                          'B',
                          'i',
                          'n',
                          'a',
                          'r',
                          'y',
                          '\\',
                          '\\'
                        ],
                        r = 0
                      for (var s = 0; s < i.length; ++s)
                        if (((n = void 0), (n = t[(e = 1) - 1]), (t = t.slice(r + e)), r++, n === i[s])) return !1
                      return !0
                    })(i)
                  )
                    throw new Error('THREE.FBXLoader: Unknown format.')
                  if (d(i) < 7e3) throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + d(i))
                  t = new l().parse(i)
                }
                var r, o
                return new s(
                  new kh(this.manager).setPath(this.resourcePath || n).setCrossOrigin(this.crossOrigin),
                  this.manager
                ).parse(t)
              }
            })),
              (s.prototype = {
                constructor: s,
                parse: function () {
                  n = this.parseConnections()
                  var t = this.parseImages(),
                    e = this.parseTextures(t),
                    r = this.parseMaterials(e),
                    s = this.parseDeformers(),
                    a = new o().parse(s)
                  return this.parseScene(s, a, r), i
                },
                parseConnections: function () {
                  var e = new Map()
                  return (
                    'Connections' in t &&
                      t.Connections.connections.forEach(function (t) {
                        var n = t[0],
                          i = t[1],
                          r = t[2]
                        e.has(n) || e.set(n, { parents: [], children: [] })
                        var s = { ID: i, relationship: r }
                        e.get(n).parents.push(s), e.has(i) || e.set(i, { parents: [], children: [] })
                        var o = { ID: n, relationship: r }
                        e.get(i).children.push(o)
                      }),
                    e
                  )
                },
                parseImages: function () {
                  var e = {},
                    n = {}
                  if ('Video' in t.Objects) {
                    var i = t.Objects.Video
                    for (var r in i) {
                      var s = i[r]
                      if (((e[(c = parseInt(r))] = s.RelativeFilename || s.Filename), 'Content' in s)) {
                        var o = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0,
                          a = 'string' == typeof s.Content && '' !== s.Content
                        if (o || a) {
                          var l = this.parseImage(i[r])
                          n[s.RelativeFilename || s.Filename] = l
                        }
                      }
                    }
                  }
                  for (var c in e) {
                    var h = e[c]
                    void 0 !== n[h] ? (e[c] = n[h]) : (e[c] = e[c].split('\\').pop())
                  }
                  return e
                },
                parseImage: function (t) {
                  var e,
                    n = t.Content,
                    i = t.RelativeFilename || t.Filename,
                    r = i.slice(i.lastIndexOf('.') + 1).toLowerCase()
                  switch (r) {
                    case 'bmp':
                      e = 'image/bmp'
                      break
                    case 'jpg':
                    case 'jpeg':
                      e = 'image/jpeg'
                      break
                    case 'png':
                      e = 'image/png'
                      break
                    case 'tif':
                      e = 'image/tiff'
                      break
                    case 'tga':
                      null === this.manager.getHandler('.tga') &&
                        console.warn('FBXLoader: TGA loader not found, skipping ', i),
                        (e = 'image/tga')
                      break
                    default:
                      return void console.warn('FBXLoader: Image type "' + r + '" is not supported.')
                  }
                  if ('string' == typeof n) return 'data:' + e + ';base64,' + n
                  var s = new Uint8Array(n)
                  return window.URL.createObjectURL(new Blob([s], { type: e }))
                },
                parseTextures: function (e) {
                  var n = new Map()
                  if ('Texture' in t.Objects) {
                    var i = t.Objects.Texture
                    for (var r in i) {
                      var s = this.parseTexture(i[r], e)
                      n.set(parseInt(r), s)
                    }
                  }
                  return n
                },
                parseTexture: function (t, e) {
                  var n = this.loadTexture(t, e)
                  ;(n.ID = t.id), (n.name = t.attrName)
                  var i = t.WrapModeU,
                    r = t.WrapModeV,
                    s = void 0 !== i ? i.value : 0,
                    o = void 0 !== r ? r.value : 0
                  if (((n.wrapS = 0 === s ? ft : gt), (n.wrapT = 0 === o ? ft : gt), 'Scaling' in t)) {
                    var a = t.Scaling.value
                    ;(n.repeat.x = a[0]), (n.repeat.y = a[1])
                  }
                  return n
                },
                loadTexture: function (t, e) {
                  var i,
                    r,
                    s = this.textureLoader.path,
                    o = n.get(t.id).children
                  void 0 !== o &&
                    o.length > 0 &&
                    void 0 !== e[o[0].ID] &&
                    ((0 !== (i = e[o[0].ID]).indexOf('blob:') && 0 !== i.indexOf('data:')) ||
                      this.textureLoader.setPath(void 0))
                  var a = t.FileName.slice(-3).toLowerCase()
                  if ('tga' === a) {
                    var l = this.manager.getHandler('.tga')
                    null === l
                      ? (console.warn(
                          'FBXLoader: TGA loader not found, creating placeholder texture for',
                          t.RelativeFilename
                        ),
                        (r = new Zn()))
                      : (r = l.load(i))
                  } else
                    'psd' === a
                      ? (console.warn(
                          'FBXLoader: PSD textures are not supported, creating placeholder texture for',
                          t.RelativeFilename
                        ),
                        (r = new Zn()))
                      : (r = this.textureLoader.load(i))
                  return this.textureLoader.setPath(s), r
                },
                parseMaterials: function (e) {
                  var n = new Map()
                  if ('Material' in t.Objects) {
                    var i = t.Objects.Material
                    for (var r in i) {
                      var s = this.parseMaterial(i[r], e)
                      null !== s && n.set(parseInt(r), s)
                    }
                  }
                  return n
                },
                parseMaterial: function (t, e) {
                  var i = t.id,
                    r = t.attrName,
                    s = t.ShadingModel
                  if (('object' == typeof s && (s = s.value), !n.has(i))) return null
                  var o,
                    a = this.parseParameters(t, e, i)
                  switch (s.toLowerCase()) {
                    case 'phong':
                      o = new oh()
                      break
                    case 'lambert':
                      o = new ch()
                      break
                    default:
                      console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s),
                        (o = new oh())
                  }
                  return o.setValues(a), (o.name = r), o
                },
                parseParameters: function (t, e, i) {
                  var r = {}
                  t.BumpFactor && (r.bumpScale = t.BumpFactor.value),
                    t.Diffuse
                      ? (r.color = new Ar().fromArray(t.Diffuse.value))
                      : !t.DiffuseColor ||
                        ('Color' !== t.DiffuseColor.type && 'ColorRGB' !== t.DiffuseColor.type) ||
                        (r.color = new Ar().fromArray(t.DiffuseColor.value)),
                    t.DisplacementFactor && (r.displacementScale = t.DisplacementFactor.value),
                    t.Emissive
                      ? (r.emissive = new Ar().fromArray(t.Emissive.value))
                      : !t.EmissiveColor ||
                        ('Color' !== t.EmissiveColor.type && 'ColorRGB' !== t.EmissiveColor.type) ||
                        (r.emissive = new Ar().fromArray(t.EmissiveColor.value)),
                    t.EmissiveFactor && (r.emissiveIntensity = parseFloat(t.EmissiveFactor.value)),
                    t.Opacity && (r.opacity = parseFloat(t.Opacity.value)),
                    r.opacity < 1 && (r.transparent = !0),
                    t.ReflectionFactor && (r.reflectivity = t.ReflectionFactor.value),
                    t.Shininess && (r.shininess = t.Shininess.value),
                    t.Specular
                      ? (r.specular = new Ar().fromArray(t.Specular.value))
                      : t.SpecularColor &&
                        'Color' === t.SpecularColor.type &&
                        (r.specular = new Ar().fromArray(t.SpecularColor.value))
                  var s = this
                  return (
                    n.get(i).children.forEach(function (t) {
                      var n = t.relationship
                      switch (n) {
                        case 'Bump':
                          r.bumpMap = s.getTexture(e, t.ID)
                          break
                        case 'Maya|TEX_ao_map':
                          r.aoMap = s.getTexture(e, t.ID)
                          break
                        case 'DiffuseColor':
                        case 'Maya|TEX_color_map':
                          ;(r.map = s.getTexture(e, t.ID)), (r.map.encoding = en)
                          break
                        case 'DisplacementColor':
                          r.displacementMap = s.getTexture(e, t.ID)
                          break
                        case 'EmissiveColor':
                          ;(r.emissiveMap = s.getTexture(e, t.ID)), (r.emissiveMap.encoding = en)
                          break
                        case 'NormalMap':
                        case 'Maya|TEX_normal_map':
                          r.normalMap = s.getTexture(e, t.ID)
                          break
                        case 'ReflectionColor':
                          ;(r.envMap = s.getTexture(e, t.ID)), (r.envMap.mapping = ut), (r.envMap.encoding = en)
                          break
                        case 'SpecularColor':
                          ;(r.specularMap = s.getTexture(e, t.ID)), (r.specularMap.encoding = en)
                          break
                        case 'TransparentColor':
                        case 'TransparencyFactor':
                          ;(r.alphaMap = s.getTexture(e, t.ID)), (r.transparent = !0)
                          break
                        case 'AmbientColor':
                        case 'ShininessExponent':
                        case 'SpecularFactor':
                        case 'VectorDisplacementColor':
                        default:
                          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', n)
                      }
                    }),
                    r
                  )
                },
                getTexture: function (e, i) {
                  return (
                    'LayeredTexture' in t.Objects &&
                      i in t.Objects.LayeredTexture &&
                      (console.warn(
                        'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.'
                      ),
                      (i = n.get(i).children[0].ID)),
                    e.get(i)
                  )
                },
                parseDeformers: function () {
                  var e = {},
                    i = {}
                  if ('Deformer' in t.Objects) {
                    var r = t.Objects.Deformer
                    for (var s in r) {
                      var o = r[s],
                        a = n.get(parseInt(s))
                      if ('Skin' === o.attrType) {
                        var l = this.parseSkeleton(a, r)
                        ;(l.ID = s),
                          a.parents.length > 1 &&
                            console.warn(
                              'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.'
                            ),
                          (l.geometryID = a.parents[0].ID),
                          (e[s] = l)
                      } else if ('BlendShape' === o.attrType) {
                        var c = { id: s }
                        ;(c.rawTargets = this.parseMorphTargets(a, r)),
                          (c.id = s),
                          a.parents.length > 1 &&
                            console.warn(
                              'THREE.FBXLoader: morph target attached to more than one geometry is not supported.'
                            ),
                          (i[s] = c)
                      }
                    }
                  }
                  return { skeletons: e, morphTargets: i }
                },
                parseSkeleton: function (t, e) {
                  var n = []
                  return (
                    t.children.forEach(function (t) {
                      var i = e[t.ID]
                      if ('Cluster' === i.attrType) {
                        var r = {
                          ID: t.ID,
                          indices: [],
                          weights: [],
                          transformLink: new Ii().fromArray(i.TransformLink.a)
                        }
                        'Indexes' in i && ((r.indices = i.Indexes.a), (r.weights = i.Weights.a)), n.push(r)
                      }
                    }),
                    { rawBones: n, bones: [] }
                  )
                },
                parseMorphTargets: function (t, e) {
                  for (var i = [], r = 0; r < t.children.length; r++) {
                    var s = t.children[r],
                      o = e[s.ID],
                      a = { name: o.attrName, initialWeight: o.DeformPercent, id: o.id, fullWeights: o.FullWeights.a }
                    if ('BlendShapeChannel' !== o.attrType) return
                    ;(a.geoID = n.get(parseInt(s.ID)).children.filter(function (t) {
                      return void 0 === t.relationship
                    })[0].ID),
                      i.push(a)
                  }
                  return i
                },
                parseScene: function (e, r, s) {
                  i = new Va()
                  var o = this.parseModels(e.skeletons, r, s),
                    l = t.Objects.Model,
                    c = this
                  o.forEach(function (t) {
                    var e = l[t.ID]
                    c.setLookAtProperties(t, e),
                      n.get(t.ID).parents.forEach(function (e) {
                        var n = o.get(e.ID)
                        void 0 !== n && n.add(t)
                      }),
                      null === t.parent && i.add(t)
                  }),
                    this.bindSkeleton(e.skeletons, r, o),
                    this.createAmbientLight(),
                    this.setupMorphMaterials(),
                    i.traverse(function (t) {
                      if (t.userData.transformData) {
                        t.parent &&
                          ((t.userData.transformData.parentMatrix = t.parent.matrix),
                          (t.userData.transformData.parentMatrixWorld = t.parent.matrixWorld))
                        var e = y(t.userData.transformData)
                        t.applyMatrix4(e), t.updateWorldMatrix()
                      }
                    })
                  var h = new a().parse()
                  1 === i.children.length &&
                    i.children[0].isGroup &&
                    ((i.children[0].animations = h), (i = i.children[0])),
                    (i.animations = h)
                },
                parseModels: function (e, i, r) {
                  var s = new Map(),
                    o = t.Objects.Model
                  for (var a in o) {
                    var l = parseInt(a),
                      c = o[a],
                      h = n.get(l),
                      u = this.buildSkeleton(h, e, l, c.attrName)
                    if (!u) {
                      switch (c.attrType) {
                        case 'Camera':
                          u = this.createCamera(h)
                          break
                        case 'Light':
                          u = this.createLight(h)
                          break
                        case 'Mesh':
                          u = this.createMesh(h, i, r)
                          break
                        case 'NurbsCurve':
                          u = this.createCurve(h, i)
                          break
                        case 'LimbNode':
                        case 'Root':
                          u = new El()
                          break
                        case 'Null':
                        default:
                          u = new Va()
                      }
                      ;(u.name = c.attrName ? _d.sanitizeNodeName(c.attrName) : ''), (u.ID = l)
                    }
                    this.getTransformData(u, c), s.set(l, u)
                  }
                  return s
                },
                buildSkeleton: function (t, e, n, i) {
                  var r = null
                  return (
                    t.parents.forEach(function (t) {
                      for (var s in e) {
                        var o = e[s]
                        o.rawBones.forEach(function (e, s) {
                          if (e.ID === t.ID) {
                            var a = r
                            ;(r = new El()).matrixWorld.copy(e.transformLink),
                              (r.name = i ? _d.sanitizeNodeName(i) : ''),
                              (r.ID = n),
                              (o.bones[s] = r),
                              null !== a && r.add(a)
                          }
                        })
                      }
                    }),
                    r
                  )
                },
                createCamera: function (e) {
                  var n, i
                  if (
                    (e.children.forEach(function (e) {
                      var n = t.Objects.NodeAttribute[e.ID]
                      void 0 !== n && (i = n)
                    }),
                    void 0 === i)
                  )
                    n = new ir()
                  else {
                    var r = 0
                    void 0 !== i.CameraProjectionType && 1 === i.CameraProjectionType.value && (r = 1)
                    var s = 1
                    void 0 !== i.NearPlane && (s = i.NearPlane.value / 1e3)
                    var o = 1e3
                    void 0 !== i.FarPlane && (o = i.FarPlane.value / 1e3)
                    var a = window.innerWidth,
                      l = window.innerHeight
                    void 0 !== i.AspectWidth &&
                      void 0 !== i.AspectHeight &&
                      ((a = i.AspectWidth.value), (l = i.AspectHeight.value))
                    var c = a / l,
                      h = 45
                    void 0 !== i.FieldOfView && (h = i.FieldOfView.value)
                    var u = i.FocalLength ? i.FocalLength.value : null
                    switch (r) {
                      case 0:
                        ;(n = new Ts(h, c, s, o)), null !== u && n.setFocalLength(u)
                        break
                      case 1:
                        n = new _u(-a / 2, a / 2, l / 2, -l / 2, s, o)
                        break
                      default:
                        console.warn('THREE.FBXLoader: Unknown camera type ' + r + '.'), (n = new ir())
                    }
                  }
                  return n
                },
                createLight: function (e) {
                  var n, i
                  if (
                    (e.children.forEach(function (e) {
                      var n = t.Objects.NodeAttribute[e.ID]
                      void 0 !== n && (i = n)
                    }),
                    void 0 === i)
                  )
                    n = new ir()
                  else {
                    var r
                    r = void 0 === i.LightType ? 0 : i.LightType.value
                    var s = 16777215
                    void 0 !== i.Color && (s = new Ar().fromArray(i.Color.value))
                    var o = void 0 === i.Intensity ? 1 : i.Intensity.value / 100
                    void 0 !== i.CastLightOnObject && 0 === i.CastLightOnObject.value && (o = 0)
                    var a = 0
                    switch (
                      (void 0 !== i.FarAttenuationEnd &&
                        (a =
                          void 0 !== i.EnableFarAttenuation && 0 === i.EnableFarAttenuation.value
                            ? 0
                            : i.FarAttenuationEnd.value),
                      r)
                    ) {
                      case 0:
                        n = new wu(s, o, a, 1)
                        break
                      case 1:
                        n = new Tu(s, o)
                        break
                      case 2:
                        var l = Math.PI / 3
                        void 0 !== i.InnerAngle && (l = Vn.degToRad(i.InnerAngle.value))
                        var c = 0
                        void 0 !== i.OuterAngle && ((c = Vn.degToRad(i.OuterAngle.value)), (c = Math.max(c, 1))),
                          (n = new gu(s, o, a, l, c, 1))
                        break
                      default:
                        console.warn(
                          'THREE.FBXLoader: Unknown light type ' + i.LightType.value + ', defaulting to a PointLight.'
                        ),
                          (n = new wu(s, o))
                    }
                    void 0 !== i.CastShadows && 1 === i.CastShadows.value && (n.castShadow = !0)
                  }
                  return n
                },
                createMesh: function (t, e, n) {
                  var i,
                    r = null,
                    s = null,
                    o = []
                  return (
                    t.children.forEach(function (t) {
                      e.has(t.ID) && (r = e.get(t.ID)), n.has(t.ID) && o.push(n.get(t.ID))
                    }),
                    o.length > 1 ? (s = o) : o.length > 0 ? (s = o[0]) : ((s = new oh({ color: 13421772 })), o.push(s)),
                    'color' in r.attributes &&
                      o.forEach(function (t) {
                        t.vertexColors = !0
                      }),
                    r.FBX_Deformer
                      ? (o.forEach(function (t) {
                          t.skinning = !0
                        }),
                        (i = new Sl(r, s)).normalizeSkinWeights())
                      : (i = new gs(r, s)),
                    i
                  )
                },
                createCurve: function (t, e) {
                  return new Hl(
                    t.children.reduce(function (t, n) {
                      return e.has(n.ID) && (t = e.get(n.ID)), t
                    }, null),
                    new Nl({ color: 3342591, linewidth: 1 })
                  )
                },
                getTransformData: function (t, e) {
                  var n = {}
                  'InheritType' in e && (n.inheritType = parseInt(e.InheritType.value)),
                    (n.eulerOrder = 'RotationOrder' in e ? x(e.RotationOrder.value) : 'ZYX'),
                    'Lcl_Translation' in e && (n.translation = e.Lcl_Translation.value),
                    'PreRotation' in e && (n.preRotation = e.PreRotation.value),
                    'Lcl_Rotation' in e && (n.rotation = e.Lcl_Rotation.value),
                    'PostRotation' in e && (n.postRotation = e.PostRotation.value),
                    'Lcl_Scaling' in e && (n.scale = e.Lcl_Scaling.value),
                    'ScalingOffset' in e && (n.scalingOffset = e.ScalingOffset.value),
                    'ScalingPivot' in e && (n.scalingPivot = e.ScalingPivot.value),
                    'RotationOffset' in e && (n.rotationOffset = e.RotationOffset.value),
                    'RotationPivot' in e && (n.rotationPivot = e.RotationPivot.value),
                    (t.userData.transformData = n)
                },
                setLookAtProperties: function (e, r) {
                  'LookAtProperty' in r &&
                    n.get(e.ID).children.forEach(function (n) {
                      if ('LookAtProperty' === n.relationship) {
                        var r = t.Objects.Model[n.ID]
                        if ('Lcl_Translation' in r) {
                          var s = r.Lcl_Translation.value
                          void 0 !== e.target
                            ? (e.target.position.fromArray(s), i.add(e.target))
                            : e.lookAt(new ei().fromArray(s))
                        }
                      }
                    })
                },
                bindSkeleton: function (t, e, i) {
                  var r = this.parsePoseNodes()
                  for (var s in t) {
                    var o = t[s]
                    n.get(parseInt(o.ID)).parents.forEach(function (t) {
                      if (e.has(t.ID)) {
                        var s = t.ID
                        n.get(s).parents.forEach(function (t) {
                          i.has(t.ID) && i.get(t.ID).bind(new Rl(o.bones), r[t.ID])
                        })
                      }
                    })
                  }
                },
                parsePoseNodes: function () {
                  var e = {}
                  if ('Pose' in t.Objects) {
                    var n = t.Objects.Pose
                    for (var i in n)
                      if ('BindPose' === n[i].attrType) {
                        var r = n[i].PoseNode
                        Array.isArray(r)
                          ? r.forEach(function (t) {
                              e[t.Node] = new Ii().fromArray(t.Matrix.a)
                            })
                          : (e[r.Node] = new Ii().fromArray(r.Matrix.a))
                      }
                  }
                  return e
                },
                createAmbientLight: function () {
                  if ('GlobalSettings' in t && 'AmbientColor' in t.GlobalSettings) {
                    var e = t.GlobalSettings.AmbientColor.value,
                      n = e[0],
                      r = e[1],
                      s = e[2]
                    if (0 !== n || 0 !== r || 0 !== s) {
                      var o = new Ar(n, r, s)
                      i.add(new Su(o, 1))
                    }
                  }
                },
                setupMorphMaterials: function () {
                  var t = this
                  i.traverse(function (e) {
                    e.isMesh &&
                      e.geometry.morphAttributes.position &&
                      e.geometry.morphAttributes.position.length &&
                      (Array.isArray(e.material)
                        ? e.material.forEach(function (n, i) {
                            t.setupMorphMaterial(e, n, i)
                          })
                        : t.setupMorphMaterial(e, e.material))
                  })
                },
                setupMorphMaterial: function (t, e, n) {
                  var r = t.uuid,
                    s = e.uuid,
                    o = !1
                  if (
                    (i.traverse(function (t) {
                      t.isMesh &&
                        (Array.isArray(t.material)
                          ? t.material.forEach(function (e) {
                              e.uuid === s && t.uuid !== r && (o = !0)
                            })
                          : t.material.uuid === s && t.uuid !== r && (o = !0))
                    }),
                    !0 === o)
                  ) {
                    var a = e.clone()
                    ;(a.morphTargets = !0), void 0 === n ? (t.material = a) : (t.material[n] = a)
                  } else e.morphTargets = !0
                }
              }),
              (o.prototype = {
                constructor: o,
                parse: function (e) {
                  var i = new Map()
                  if ('Geometry' in t.Objects) {
                    var r = t.Objects.Geometry
                    for (var s in r) {
                      var o = n.get(parseInt(s)),
                        a = this.parseGeometry(o, r[s], e)
                      i.set(parseInt(s), a)
                    }
                  }
                  return i
                },
                parseGeometry: function (t, e, n) {
                  switch (e.attrType) {
                    case 'Mesh':
                      return this.parseMeshGeometry(t, e, n)
                    case 'NurbsCurve':
                      return this.parseNurbsGeometry(e)
                  }
                },
                parseMeshGeometry: function (e, n, i) {
                  var r = i.skeletons,
                    s = [],
                    o = e.parents.map(function (e) {
                      return t.Objects.Model[e.ID]
                    })
                  if (0 !== o.length) {
                    var a = e.children.reduce(function (t, e) {
                      return void 0 !== r[e.ID] && (t = r[e.ID]), t
                    }, null)
                    e.children.forEach(function (t) {
                      void 0 !== i.morphTargets[t.ID] && s.push(i.morphTargets[t.ID])
                    })
                    var l = o[0],
                      c = {}
                    'RotationOrder' in l && (c.eulerOrder = x(l.RotationOrder.value)),
                      'InheritType' in l && (c.inheritType = parseInt(l.InheritType.value)),
                      'GeometricTranslation' in l && (c.translation = l.GeometricTranslation.value),
                      'GeometricRotation' in l && (c.rotation = l.GeometricRotation.value),
                      'GeometricScaling' in l && (c.scale = l.GeometricScaling.value)
                    var h = y(c)
                    return this.genGeometry(n, a, s, h)
                  }
                },
                genGeometry: function (t, e, n, i) {
                  var r = new Qr()
                  t.attrName && (r.name = t.attrName)
                  var s = this.parseGeoNode(t, e),
                    o = this.genBuffers(s),
                    a = new Ur(o.vertex, 3)
                  if (
                    (a.applyMatrix4(i),
                    r.setAttribute('position', a),
                    o.colors.length > 0 && r.setAttribute('color', new Ur(o.colors, 3)),
                    e &&
                      (r.setAttribute('skinIndex', new Br(o.weightsIndices, 4)),
                      r.setAttribute('skinWeight', new Ur(o.vertexWeights, 4)),
                      (r.FBX_Deformer = e)),
                    o.normal.length > 0)
                  ) {
                    var l = new jn().getNormalMatrix(i),
                      c = new Ur(o.normal, 3)
                    c.applyNormalMatrix(l), r.setAttribute('normal', c)
                  }
                  if (
                    (o.uvs.forEach(function (t, e) {
                      var n = 'uv' + (e + 1).toString()
                      0 === e && (n = 'uv'), r.setAttribute(n, new Ur(o.uvs[e], 2))
                    }),
                    s.material && 'AllSame' !== s.material.mappingType)
                  ) {
                    var h = o.materialIndex[0],
                      u = 0
                    if (
                      (o.materialIndex.forEach(function (t, e) {
                        t !== h && (r.addGroup(u, e - u, h), (h = t), (u = e))
                      }),
                      r.groups.length > 0)
                    ) {
                      var d = r.groups[r.groups.length - 1],
                        p = d.start + d.count
                      p !== o.materialIndex.length && r.addGroup(p, o.materialIndex.length - p, h)
                    }
                    0 === r.groups.length && r.addGroup(0, o.materialIndex.length, o.materialIndex[0])
                  }
                  return this.addMorphTargets(r, t, n, i), r
                },
                parseGeoNode: function (t, e) {
                  var n = {}
                  if (
                    ((n.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : []),
                    (n.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : []),
                    t.LayerElementColor && (n.color = this.parseVertexColors(t.LayerElementColor[0])),
                    t.LayerElementMaterial && (n.material = this.parseMaterialIndices(t.LayerElementMaterial[0])),
                    t.LayerElementNormal && (n.normal = this.parseNormals(t.LayerElementNormal[0])),
                    t.LayerElementUV)
                  ) {
                    n.uv = []
                    for (var i = 0; t.LayerElementUV[i]; )
                      t.LayerElementUV[i].UV && n.uv.push(this.parseUVs(t.LayerElementUV[i])), i++
                  }
                  return (
                    (n.weightTable = {}),
                    null !== e &&
                      ((n.skeleton = e),
                      e.rawBones.forEach(function (t, e) {
                        t.indices.forEach(function (i, r) {
                          void 0 === n.weightTable[i] && (n.weightTable[i] = []),
                            n.weightTable[i].push({ id: e, weight: t.weights[r] })
                        })
                      })),
                    n
                  )
                },
                genBuffers: function (t) {
                  var e = {
                      vertex: [],
                      normal: [],
                      colors: [],
                      uvs: [],
                      materialIndex: [],
                      vertexWeights: [],
                      weightsIndices: []
                    },
                    n = 0,
                    i = 0,
                    r = !1,
                    s = [],
                    o = [],
                    a = [],
                    l = [],
                    c = [],
                    h = [],
                    u = this
                  return (
                    t.vertexIndices.forEach(function (d, p) {
                      var m = !1
                      d < 0 && ((d ^= -1), (m = !0))
                      var g = [],
                        v = []
                      if ((s.push(3 * d, 3 * d + 1, 3 * d + 2), t.color)) {
                        var y = f(p, n, d, t.color)
                        a.push(y[0], y[1], y[2])
                      }
                      if (t.skeleton) {
                        if (
                          (void 0 !== t.weightTable[d] &&
                            t.weightTable[d].forEach(function (t) {
                              v.push(t.weight), g.push(t.id)
                            }),
                          v.length > 4)
                        ) {
                          r ||
                            (console.warn(
                              'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.'
                            ),
                            (r = !0))
                          var x = [0, 0, 0, 0],
                            b = [0, 0, 0, 0]
                          v.forEach(function (t, e) {
                            var n = t,
                              i = g[e]
                            b.forEach(function (t, e, r) {
                              if (n > t) {
                                ;(r[e] = n), (n = t)
                                var s = x[e]
                                ;(x[e] = i), (i = s)
                              }
                            })
                          }),
                            (g = x),
                            (v = b)
                        }
                        for (; v.length < 4; ) v.push(0), g.push(0)
                        for (var w = 0; w < 4; ++w) c.push(v[w]), h.push(g[w])
                      }
                      if (
                        (t.normal && ((y = f(p, n, d, t.normal)), o.push(y[0], y[1], y[2])),
                        t.material && 'AllSame' !== t.material.mappingType)
                      )
                        var _ = f(p, n, d, t.material)[0]
                      t.uv &&
                        t.uv.forEach(function (t, e) {
                          var i = f(p, n, d, t)
                          void 0 === l[e] && (l[e] = []), l[e].push(i[0]), l[e].push(i[1])
                        }),
                        i++,
                        m &&
                          (u.genFace(e, t, s, _, o, a, l, c, h, i),
                          n++,
                          (i = 0),
                          (s = []),
                          (o = []),
                          (a = []),
                          (l = []),
                          (c = []),
                          (h = []))
                    }),
                    e
                  )
                },
                genFace: function (t, e, n, i, r, s, o, a, l, c) {
                  for (var h = 2; h < c; h++)
                    t.vertex.push(e.vertexPositions[n[0]]),
                      t.vertex.push(e.vertexPositions[n[1]]),
                      t.vertex.push(e.vertexPositions[n[2]]),
                      t.vertex.push(e.vertexPositions[n[3 * (h - 1)]]),
                      t.vertex.push(e.vertexPositions[n[3 * (h - 1) + 1]]),
                      t.vertex.push(e.vertexPositions[n[3 * (h - 1) + 2]]),
                      t.vertex.push(e.vertexPositions[n[3 * h]]),
                      t.vertex.push(e.vertexPositions[n[3 * h + 1]]),
                      t.vertex.push(e.vertexPositions[n[3 * h + 2]]),
                      e.skeleton &&
                        (t.vertexWeights.push(a[0]),
                        t.vertexWeights.push(a[1]),
                        t.vertexWeights.push(a[2]),
                        t.vertexWeights.push(a[3]),
                        t.vertexWeights.push(a[4 * (h - 1)]),
                        t.vertexWeights.push(a[4 * (h - 1) + 1]),
                        t.vertexWeights.push(a[4 * (h - 1) + 2]),
                        t.vertexWeights.push(a[4 * (h - 1) + 3]),
                        t.vertexWeights.push(a[4 * h]),
                        t.vertexWeights.push(a[4 * h + 1]),
                        t.vertexWeights.push(a[4 * h + 2]),
                        t.vertexWeights.push(a[4 * h + 3]),
                        t.weightsIndices.push(l[0]),
                        t.weightsIndices.push(l[1]),
                        t.weightsIndices.push(l[2]),
                        t.weightsIndices.push(l[3]),
                        t.weightsIndices.push(l[4 * (h - 1)]),
                        t.weightsIndices.push(l[4 * (h - 1) + 1]),
                        t.weightsIndices.push(l[4 * (h - 1) + 2]),
                        t.weightsIndices.push(l[4 * (h - 1) + 3]),
                        t.weightsIndices.push(l[4 * h]),
                        t.weightsIndices.push(l[4 * h + 1]),
                        t.weightsIndices.push(l[4 * h + 2]),
                        t.weightsIndices.push(l[4 * h + 3])),
                      e.color &&
                        (t.colors.push(s[0]),
                        t.colors.push(s[1]),
                        t.colors.push(s[2]),
                        t.colors.push(s[3 * (h - 1)]),
                        t.colors.push(s[3 * (h - 1) + 1]),
                        t.colors.push(s[3 * (h - 1) + 2]),
                        t.colors.push(s[3 * h]),
                        t.colors.push(s[3 * h + 1]),
                        t.colors.push(s[3 * h + 2])),
                      e.material &&
                        'AllSame' !== e.material.mappingType &&
                        (t.materialIndex.push(i), t.materialIndex.push(i), t.materialIndex.push(i)),
                      e.normal &&
                        (t.normal.push(r[0]),
                        t.normal.push(r[1]),
                        t.normal.push(r[2]),
                        t.normal.push(r[3 * (h - 1)]),
                        t.normal.push(r[3 * (h - 1) + 1]),
                        t.normal.push(r[3 * (h - 1) + 2]),
                        t.normal.push(r[3 * h]),
                        t.normal.push(r[3 * h + 1]),
                        t.normal.push(r[3 * h + 2])),
                      e.uv &&
                        e.uv.forEach(function (e, n) {
                          void 0 === t.uvs[n] && (t.uvs[n] = []),
                            t.uvs[n].push(o[n][0]),
                            t.uvs[n].push(o[n][1]),
                            t.uvs[n].push(o[n][2 * (h - 1)]),
                            t.uvs[n].push(o[n][2 * (h - 1) + 1]),
                            t.uvs[n].push(o[n][2 * h]),
                            t.uvs[n].push(o[n][2 * h + 1])
                        })
                },
                addMorphTargets: function (e, n, i, r) {
                  if (0 !== i.length) {
                    ;(e.morphTargetsRelative = !0), (e.morphAttributes.position = [])
                    var s = this
                    i.forEach(function (i) {
                      i.rawTargets.forEach(function (i) {
                        var o = t.Objects.Geometry[i.geoID]
                        void 0 !== o && s.genMorphGeometry(e, n, o, r, i.name)
                      })
                    })
                  }
                },
                genMorphGeometry: function (t, e, n, i, r) {
                  for (
                    var s = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [],
                      o = void 0 !== n.Vertices ? n.Vertices.a : [],
                      a = void 0 !== n.Indexes ? n.Indexes.a : [],
                      l = 3 * t.attributes.position.count,
                      c = new Float32Array(l),
                      h = 0;
                    h < a.length;
                    h++
                  ) {
                    var u = 3 * a[h]
                    ;(c[u] = o[3 * h]), (c[u + 1] = o[3 * h + 1]), (c[u + 2] = o[3 * h + 2])
                  }
                  var d = { vertexIndices: s, vertexPositions: c },
                    p = new Ur(this.genBuffers(d).vertex, 3)
                  ;(p.name = r || n.attrName), p.applyMatrix4(i), t.morphAttributes.position.push(p)
                },
                parseNormals: function (t) {
                  var e = t.MappingInformationType,
                    n = t.ReferenceInformationType,
                    i = t.Normals.a,
                    r = []
                  return (
                    'IndexToDirect' === n &&
                      ('NormalIndex' in t ? (r = t.NormalIndex.a) : 'NormalsIndex' in t && (r = t.NormalsIndex.a)),
                    { dataSize: 3, buffer: i, indices: r, mappingType: e, referenceType: n }
                  )
                },
                parseUVs: function (t) {
                  var e = t.MappingInformationType,
                    n = t.ReferenceInformationType,
                    i = t.UV.a,
                    r = []
                  return (
                    'IndexToDirect' === n && (r = t.UVIndex.a),
                    { dataSize: 2, buffer: i, indices: r, mappingType: e, referenceType: n }
                  )
                },
                parseVertexColors: function (t) {
                  var e = t.MappingInformationType,
                    n = t.ReferenceInformationType,
                    i = t.Colors.a,
                    r = []
                  return (
                    'IndexToDirect' === n && (r = t.ColorIndex.a),
                    { dataSize: 4, buffer: i, indices: r, mappingType: e, referenceType: n }
                  )
                },
                parseMaterialIndices: function (t) {
                  var e = t.MappingInformationType,
                    n = t.ReferenceInformationType
                  if ('NoMappingInformation' === e)
                    return { dataSize: 1, buffer: [0], indices: [0], mappingType: 'AllSame', referenceType: n }
                  for (var i = t.Materials.a, r = [], s = 0; s < i.length; ++s) r.push(s)
                  return { dataSize: 1, buffer: i, indices: r, mappingType: e, referenceType: n }
                },
                parseNurbsGeometry: function (t) {
                  if (void 0 === Av)
                    return (
                      console.error(
                        'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.'
                      ),
                      new Qr()
                    )
                  var e = parseInt(t.Order)
                  if (isNaN(e))
                    return (
                      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', t.Order, t.id),
                      new Qr()
                    )
                  for (
                    var n, i, r = e - 1, s = t.KnotVector.a, o = [], a = t.Points.a, l = 0, c = a.length;
                    l < c;
                    l += 4
                  )
                    o.push(new Kn().fromArray(a, l))
                  if ('Closed' === t.Form) o.push(o[0])
                  else if ('Periodic' === t.Form) for (n = r, i = s.length - 1 - n, l = 0; l < r; ++l) o.push(o[l])
                  var h = new Av(r, s, o, n, i).getPoints(7 * o.length),
                    u = new Float32Array(3 * h.length)
                  h.forEach(function (t, e) {
                    t.toArray(u, 3 * e)
                  })
                  var d = new Qr()
                  return d.setAttribute('position', new Cr(u, 3)), d
                }
              }),
              (a.prototype = {
                constructor: a,
                parse: function () {
                  var t = [],
                    e = this.parseClips()
                  if (void 0 !== e)
                    for (var n in e) {
                      var i = e[n],
                        r = this.addClip(i)
                      t.push(r)
                    }
                  return t
                },
                parseClips: function () {
                  if (void 0 !== t.Objects.AnimationCurve) {
                    var e = this.parseAnimationCurveNodes()
                    this.parseAnimationCurves(e)
                    var n = this.parseAnimationLayers(e)
                    return this.parseAnimStacks(n)
                  }
                },
                parseAnimationCurveNodes: function () {
                  var e = t.Objects.AnimationCurveNode,
                    n = new Map()
                  for (var i in e) {
                    var r = e[i]
                    if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
                      var s = { id: r.id, attr: r.attrName, curves: {} }
                      n.set(s.id, s)
                    }
                  }
                  return n
                },
                parseAnimationCurves: function (e) {
                  var i = t.Objects.AnimationCurve
                  for (var r in i) {
                    var s = { id: i[r].id, times: i[r].KeyTime.a.map(p), values: i[r].KeyValueFloat.a },
                      o = n.get(s.id)
                    if (void 0 !== o) {
                      var a = o.parents[0].ID,
                        l = o.parents[0].relationship
                      l.match(/X/)
                        ? (e.get(a).curves.x = s)
                        : l.match(/Y/)
                        ? (e.get(a).curves.y = s)
                        : l.match(/Z/)
                        ? (e.get(a).curves.z = s)
                        : l.match(/d|DeformPercent/) && e.has(a) && (e.get(a).curves.morph = s)
                    }
                  }
                },
                parseAnimationLayers: function (e) {
                  var r = t.Objects.AnimationLayer,
                    s = new Map()
                  for (var o in r) {
                    var a = [],
                      l = n.get(parseInt(o))
                    void 0 !== l &&
                      (l.children.forEach(function (r, s) {
                        if (e.has(r.ID)) {
                          var o = e.get(r.ID)
                          if (void 0 !== o.curves.x || void 0 !== o.curves.y || void 0 !== o.curves.z) {
                            if (
                              void 0 === a[s] &&
                              void 0 !==
                                (p = n.get(r.ID).parents.filter(function (t) {
                                  return void 0 !== t.relationship
                                })[0].ID)
                            ) {
                              if (void 0 === (c = t.Objects.Model[p.toString()]))
                                return void console.warn('THREE.FBXLoader: Encountered a unused curve.', r)
                              var l = {
                                modelName: c.attrName ? _d.sanitizeNodeName(c.attrName) : '',
                                ID: c.id,
                                initialPosition: [0, 0, 0],
                                initialRotation: [0, 0, 0],
                                initialScale: [1, 1, 1]
                              }
                              i.traverse(function (t) {
                                t.ID === c.id &&
                                  ((l.transform = t.matrix),
                                  t.userData.transformData && (l.eulerOrder = t.userData.transformData.eulerOrder))
                              }),
                                l.transform || (l.transform = new Ii()),
                                'PreRotation' in c && (l.preRotation = c.PreRotation.value),
                                'PostRotation' in c && (l.postRotation = c.PostRotation.value),
                                (a[s] = l)
                            }
                            a[s] && (a[s][o.attr] = o)
                          } else if (void 0 !== o.curves.morph) {
                            if (void 0 === a[s]) {
                              var c,
                                h = n.get(r.ID).parents.filter(function (t) {
                                  return void 0 !== t.relationship
                                })[0].ID,
                                u = n.get(h).parents[0].ID,
                                d = n.get(u).parents[0].ID,
                                p = n.get(d).parents[0].ID
                              ;(l = {
                                modelName: (c = t.Objects.Model[p]).attrName ? _d.sanitizeNodeName(c.attrName) : '',
                                morphName: t.Objects.Deformer[h].attrName
                              }),
                                (a[s] = l)
                            }
                            a[s][o.attr] = o
                          }
                        }
                      }),
                      s.set(parseInt(o), a))
                  }
                  return s
                },
                parseAnimStacks: function (e) {
                  var i = t.Objects.AnimationStack,
                    r = {}
                  for (var s in i) {
                    var o = n.get(parseInt(s)).children
                    o.length > 1 &&
                      console.warn(
                        'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.'
                      )
                    var a = e.get(o[0].ID)
                    r[s] = { name: i[s].attrName, layer: a }
                  }
                  return r
                },
                addClip: function (t) {
                  var e = [],
                    n = this
                  return (
                    t.layer.forEach(function (t) {
                      e = e.concat(n.generateTracks(t))
                    }),
                    new Eh(t.name, -1, e)
                  )
                },
                generateTracks: function (t) {
                  var e = [],
                    n = new ei(),
                    i = new ti(),
                    r = new ei()
                  if (
                    (t.transform && t.transform.decompose(n, i, r),
                    (n = n.toArray()),
                    (i = new Gi().setFromQuaternion(i, t.eulerOrder).toArray()),
                    (r = r.toArray()),
                    void 0 !== t.T && Object.keys(t.T.curves).length > 0)
                  ) {
                    var s = this.generateVectorTrack(t.modelName, t.T.curves, n, 'position')
                    void 0 !== s && e.push(s)
                  }
                  if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) {
                    var o = this.generateRotationTrack(
                      t.modelName,
                      t.R.curves,
                      i,
                      t.preRotation,
                      t.postRotation,
                      t.eulerOrder
                    )
                    void 0 !== o && e.push(o)
                  }
                  if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) {
                    var a = this.generateVectorTrack(t.modelName, t.S.curves, r, 'scale')
                    void 0 !== a && e.push(a)
                  }
                  if (void 0 !== t.DeformPercent) {
                    var l = this.generateMorphTrack(t)
                    void 0 !== l && e.push(l)
                  }
                  return e
                },
                generateVectorTrack: function (t, e, n, i) {
                  var r = this.getTimesForAllAxes(e),
                    s = this.getKeyframeTrackValues(r, e, n)
                  return new Sh(t + '.' + i, r, s)
                },
                generateRotationTrack: function (t, e, n, i, r, s) {
                  void 0 !== e.x && (this.interpolateRotations(e.x), (e.x.values = e.x.values.map(Vn.degToRad))),
                    void 0 !== e.y && (this.interpolateRotations(e.y), (e.y.values = e.y.values.map(Vn.degToRad))),
                    void 0 !== e.z && (this.interpolateRotations(e.z), (e.z.values = e.z.values.map(Vn.degToRad)))
                  var o = this.getTimesForAllAxes(e),
                    a = this.getKeyframeTrackValues(o, e, n)
                  void 0 !== i &&
                    ((i = i.map(Vn.degToRad)).push(s), (i = new Gi().fromArray(i)), (i = new ti().setFromEuler(i))),
                    void 0 !== r &&
                      ((r = r.map(Vn.degToRad)).push(s),
                      (r = new Gi().fromArray(r)),
                      (r = new ti().setFromEuler(r).invert()))
                  for (var l = new ti(), c = new Gi(), h = [], u = 0; u < a.length; u += 3)
                    c.set(a[u], a[u + 1], a[u + 2], s),
                      l.setFromEuler(c),
                      void 0 !== i && l.premultiply(i),
                      void 0 !== r && l.multiply(r),
                      l.toArray(h, (u / 3) * 4)
                  return new Mh(t + '.quaternion', o, h)
                },
                generateMorphTrack: function (t) {
                  var e = t.DeformPercent.curves.morph,
                    n = e.values.map(function (t) {
                      return t / 100
                    }),
                    r = i.getObjectByName(t.modelName).morphTargetDictionary[t.morphName]
                  return new wh(t.modelName + '.morphTargetInfluences[' + r + ']', e.times, n)
                },
                getTimesForAllAxes: function (t) {
                  var e = []
                  if (
                    (void 0 !== t.x && (e = e.concat(t.x.times)),
                    void 0 !== t.y && (e = e.concat(t.y.times)),
                    void 0 !== t.z && (e = e.concat(t.z.times)),
                    (e = e.sort(function (t, e) {
                      return t - e
                    })).length > 1)
                  ) {
                    for (var n = 1, i = e[0], r = 1; r < e.length; r++) {
                      var s = e[r]
                      s !== i && ((e[n] = s), (i = s), n++)
                    }
                    e = e.slice(0, n)
                  }
                  return e
                },
                getKeyframeTrackValues: function (t, e, n) {
                  var i = n,
                    r = [],
                    s = -1,
                    o = -1,
                    a = -1
                  return (
                    t.forEach(function (t) {
                      if (
                        (e.x && (s = e.x.times.indexOf(t)),
                        e.y && (o = e.y.times.indexOf(t)),
                        e.z && (a = e.z.times.indexOf(t)),
                        -1 !== s)
                      ) {
                        var n = e.x.values[s]
                        r.push(n), (i[0] = n)
                      } else r.push(i[0])
                      if (-1 !== o) {
                        var l = e.y.values[o]
                        r.push(l), (i[1] = l)
                      } else r.push(i[1])
                      if (-1 !== a) {
                        var c = e.z.values[a]
                        r.push(c), (i[2] = c)
                      } else r.push(i[2])
                    }),
                    r
                  )
                },
                interpolateRotations: function (t) {
                  for (var e = 1; e < t.values.length; e++) {
                    var n = t.values[e - 1],
                      i = t.values[e] - n,
                      r = Math.abs(i)
                    if (r >= 180) {
                      for (
                        var s = r / 180,
                          o = i / s,
                          a = n + o,
                          l = t.times[e - 1],
                          c = (t.times[e] - l) / s,
                          h = l + c,
                          u = [],
                          d = [];
                        h < t.times[e];

                      )
                        u.push(h), (h += c), d.push(a), (a += o)
                      ;(t.times = _(t.times, e, u)), (t.values = _(t.values, e, d))
                    }
                  }
                }
              }),
              (l.prototype = {
                constructor: l,
                getPrevNode: function () {
                  return this.nodeStack[this.currentIndent - 2]
                },
                getCurrentNode: function () {
                  return this.nodeStack[this.currentIndent - 1]
                },
                getCurrentProp: function () {
                  return this.currentProp
                },
                pushStack: function (t) {
                  this.nodeStack.push(t), (this.currentIndent += 1)
                },
                popStack: function () {
                  this.nodeStack.pop(), (this.currentIndent -= 1)
                },
                setCurrentProp: function (t, e) {
                  ;(this.currentProp = t), (this.currentPropName = e)
                },
                parse: function (t) {
                  ;(this.currentIndent = 0),
                    (this.allNodes = new u()),
                    (this.nodeStack = []),
                    (this.currentProp = []),
                    (this.currentPropName = '')
                  var e = this,
                    n = t.split(/[\r\n]+/)
                  return (
                    n.forEach(function (t, i) {
                      var r = t.match(/^[\s\t]*;/),
                        s = t.match(/^[\s\t]*$/)
                      if (!r && !s) {
                        var o = t.match('^\\t{' + e.currentIndent + '}(\\w+):(.*){', ''),
                          a = t.match('^\\t{' + e.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)'),
                          l = t.match('^\\t{' + (e.currentIndent - 1) + '}}')
                        o
                          ? e.parseNodeBegin(t, o)
                          : a
                          ? e.parseNodeProperty(t, a, n[++i])
                          : l
                          ? e.popStack()
                          : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
                      }
                    }),
                    this.allNodes
                  )
                },
                parseNodeBegin: function (t, e) {
                  var n = e[1].trim().replace(/^"/, '').replace(/"$/, ''),
                    i = e[2].split(',').map(function (t) {
                      return t.trim().replace(/^"/, '').replace(/"$/, '')
                    }),
                    r = { name: n },
                    s = this.parseNodeAttr(i),
                    o = this.getCurrentNode()
                  0 === this.currentIndent
                    ? this.allNodes.add(n, r)
                    : n in o
                    ? ('PoseNode' === n
                        ? o.PoseNode.push(r)
                        : void 0 !== o[n].id && ((o[n] = {}), (o[n][o[n].id] = o[n])),
                      '' !== s.id && (o[n][s.id] = r))
                    : 'number' == typeof s.id
                    ? ((o[n] = {}), (o[n][s.id] = r))
                    : 'Properties70' !== n && (o[n] = 'PoseNode' === n ? [r] : r),
                    'number' == typeof s.id && (r.id = s.id),
                    '' !== s.name && (r.attrName = s.name),
                    '' !== s.type && (r.attrType = s.type),
                    this.pushStack(r)
                },
                parseNodeAttr: function (t) {
                  var e = t[0]
                  '' !== t[0] && ((e = parseInt(t[0])), isNaN(e) && (e = t[0]))
                  var n = '',
                    i = ''
                  return t.length > 1 && ((n = t[1].replace(/^(\w+)::/, '')), (i = t[2])), { id: e, name: n, type: i }
                },
                parseNodeProperty: function (t, e, n) {
                  var i = e[1].replace(/^"/, '').replace(/"$/, '').trim(),
                    r = e[2].replace(/^"/, '').replace(/"$/, '').trim()
                  'Content' === i && ',' === r && (r = n.replace(/"/g, '').replace(/,$/, '').trim())
                  var s = this.getCurrentNode()
                  if ('Properties70' !== s.name) {
                    if ('C' === i) {
                      var o = r.split(',').slice(1),
                        a = parseInt(o[0]),
                        l = parseInt(o[1]),
                        c = r.split(',').slice(3)
                      ;(i = 'connections'),
                        (function (t, e) {
                          for (var n = 0, i = t.length, r = e.length; n < r; n++, i++) t[i] = e[n]
                        })(
                          (r = [a, l]),
                          (c = c.map(function (t) {
                            return t.trim().replace(/^"/, '')
                          }))
                        ),
                        void 0 === s[i] && (s[i] = [])
                    }
                    'Node' === i && (s.id = r),
                      i in s && Array.isArray(s[i]) ? s[i].push(r) : 'a' !== i ? (s[i] = r) : (s.a = r),
                      this.setCurrentProp(s, i),
                      'a' === i && ',' !== r.slice(-1) && (s.a = b(r))
                  } else this.parseNodeSpecialProperty(t, i, r)
                },
                parseNodePropertyContinued: function (t) {
                  var e = this.getCurrentNode()
                  ;(e.a += t), ',' !== t.slice(-1) && (e.a = b(e.a))
                },
                parseNodeSpecialProperty: function (t, e, n) {
                  var i = n.split('",').map(function (t) {
                      return t.trim().replace(/^\"/, '').replace(/\s/, '_')
                    }),
                    r = i[0],
                    s = i[1],
                    o = i[2],
                    a = i[3],
                    l = i[4]
                  switch (s) {
                    case 'int':
                    case 'enum':
                    case 'bool':
                    case 'ULongLong':
                    case 'double':
                    case 'Number':
                    case 'FieldOfView':
                      l = parseFloat(l)
                      break
                    case 'Color':
                    case 'ColorRGB':
                    case 'Vector3D':
                    case 'Lcl_Translation':
                    case 'Lcl_Rotation':
                    case 'Lcl_Scaling':
                      l = b(l)
                  }
                  ;(this.getPrevNode()[r] = { type: s, type2: o, flag: a, value: l }),
                    this.setCurrentProp(this.getPrevNode(), r)
                }
              }),
              (c.prototype = {
                constructor: c,
                parse: function (t) {
                  var e = new h(t)
                  e.skip(23)
                  var n = e.getUint32()
                  if (n < 6400) throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + n)
                  for (var i = new u(); !this.endOfContent(e); ) {
                    var r = this.parseNode(e, n)
                    null !== r && i.add(r.name, r)
                  }
                  return i
                },
                endOfContent: function (t) {
                  return t.size() % 16 == 0
                    ? ((t.getOffset() + 160 + 16) & -16) >= t.size()
                    : t.getOffset() + 160 + 16 >= t.size()
                },
                parseNode: function (t, e) {
                  var n = {},
                    i = e >= 7500 ? t.getUint64() : t.getUint32(),
                    r = e >= 7500 ? t.getUint64() : t.getUint32()
                  e >= 7500 ? t.getUint64() : t.getUint32()
                  var s = t.getUint8(),
                    o = t.getString(s)
                  if (0 === i) return null
                  for (var a = [], l = 0; l < r; l++) a.push(this.parseProperty(t))
                  var c = a.length > 0 ? a[0] : '',
                    h = a.length > 1 ? a[1] : '',
                    u = a.length > 2 ? a[2] : ''
                  for (n.singleProperty = 1 === r && t.getOffset() === i; i > t.getOffset(); ) {
                    var d = this.parseNode(t, e)
                    null !== d && this.parseSubNode(o, n, d)
                  }
                  return (
                    (n.propertyList = a),
                    'number' == typeof c && (n.id = c),
                    '' !== h && (n.attrName = h),
                    '' !== u && (n.attrType = u),
                    '' !== o && (n.name = o),
                    n
                  )
                },
                parseSubNode: function (t, e, n) {
                  if (!0 === n.singleProperty) {
                    var i = n.propertyList[0]
                    Array.isArray(i) ? ((e[n.name] = n), (n.a = i)) : (e[n.name] = i)
                  } else if ('Connections' === t && 'C' === n.name) {
                    var r = []
                    n.propertyList.forEach(function (t, e) {
                      0 !== e && r.push(t)
                    }),
                      void 0 === e.connections && (e.connections = []),
                      e.connections.push(r)
                  } else if ('Properties70' === n.name)
                    Object.keys(n).forEach(function (t) {
                      e[t] = n[t]
                    })
                  else if ('Properties70' === t && 'P' === n.name) {
                    var s,
                      o = n.propertyList[0],
                      a = n.propertyList[1],
                      l = n.propertyList[2],
                      c = n.propertyList[3]
                    0 === o.indexOf('Lcl ') && (o = o.replace('Lcl ', 'Lcl_')),
                      0 === a.indexOf('Lcl ') && (a = a.replace('Lcl ', 'Lcl_')),
                      (s =
                        'Color' === a ||
                        'ColorRGB' === a ||
                        'Vector' === a ||
                        'Vector3D' === a ||
                        0 === a.indexOf('Lcl_')
                          ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]]
                          : n.propertyList[4]),
                      (e[o] = { type: a, type2: l, flag: c, value: s })
                  } else
                    void 0 === e[n.name]
                      ? 'number' == typeof n.id
                        ? ((e[n.name] = {}), (e[n.name][n.id] = n))
                        : (e[n.name] = n)
                      : 'PoseNode' === n.name
                      ? (Array.isArray(e[n.name]) || (e[n.name] = [e[n.name]]), e[n.name].push(n))
                      : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n)
                },
                parseProperty: function (t) {
                  var n = t.getString(1)
                  switch (n) {
                    case 'C':
                      return t.getBoolean()
                    case 'D':
                      return t.getFloat64()
                    case 'F':
                      return t.getFloat32()
                    case 'I':
                      return t.getInt32()
                    case 'L':
                      return t.getInt64()
                    case 'R':
                      var i = t.getUint32()
                      return t.getArrayBuffer(i)
                    case 'S':
                      return (i = t.getUint32()), t.getString(i)
                    case 'Y':
                      return t.getInt16()
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'f':
                    case 'i':
                    case 'l':
                      var r = t.getUint32(),
                        s = t.getUint32(),
                        o = t.getUint32()
                      if (0 === s)
                        switch (n) {
                          case 'b':
                          case 'c':
                            return t.getBooleanArray(r)
                          case 'd':
                            return t.getFloat64Array(r)
                          case 'f':
                            return t.getFloat32Array(r)
                          case 'i':
                            return t.getInt32Array(r)
                          case 'l':
                            return t.getInt64Array(r)
                        }
                      void 0 === e && console.error('THREE.FBXLoader: External library fflate.min.js required.')
                      var a = new h(qg(new Uint8Array(t.getArrayBuffer(o))).buffer)
                      switch (n) {
                        case 'b':
                        case 'c':
                          return a.getBooleanArray(r)
                        case 'd':
                          return a.getFloat64Array(r)
                        case 'f':
                          return a.getFloat32Array(r)
                        case 'i':
                          return a.getInt32Array(r)
                        case 'l':
                          return a.getInt64Array(r)
                      }
                    default:
                      throw new Error('THREE.FBXLoader: Unknown property type ' + n)
                  }
                }
              }),
              (h.prototype = {
                constructor: h,
                getOffset: function () {
                  return this.offset
                },
                size: function () {
                  return this.dv.buffer.byteLength
                },
                skip: function (t) {
                  this.offset += t
                },
                getBoolean: function () {
                  return 1 == (1 & this.getUint8())
                },
                getBooleanArray: function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push(this.getBoolean())
                  return e
                },
                getUint8: function () {
                  var t = this.dv.getUint8(this.offset)
                  return (this.offset += 1), t
                },
                getInt16: function () {
                  var t = this.dv.getInt16(this.offset, this.littleEndian)
                  return (this.offset += 2), t
                },
                getInt32: function () {
                  var t = this.dv.getInt32(this.offset, this.littleEndian)
                  return (this.offset += 4), t
                },
                getInt32Array: function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push(this.getInt32())
                  return e
                },
                getUint32: function () {
                  var t = this.dv.getUint32(this.offset, this.littleEndian)
                  return (this.offset += 4), t
                },
                getInt64: function () {
                  var t, e
                  return (
                    this.littleEndian
                      ? ((t = this.getUint32()), (e = this.getUint32()))
                      : ((e = this.getUint32()), (t = this.getUint32())),
                    2147483648 & e
                      ? ((e = 4294967295 & ~e),
                        4294967295 == (t = 4294967295 & ~t) && (e = (e + 1) & 4294967295),
                        -(4294967296 * e + (t = (t + 1) & 4294967295)))
                      : 4294967296 * e + t
                  )
                },
                getInt64Array: function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push(this.getInt64())
                  return e
                },
                getUint64: function () {
                  var t, e
                  return (
                    this.littleEndian
                      ? ((t = this.getUint32()), (e = this.getUint32()))
                      : ((e = this.getUint32()), (t = this.getUint32())),
                    4294967296 * e + t
                  )
                },
                getFloat32: function () {
                  var t = this.dv.getFloat32(this.offset, this.littleEndian)
                  return (this.offset += 4), t
                },
                getFloat32Array: function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push(this.getFloat32())
                  return e
                },
                getFloat64: function () {
                  var t = this.dv.getFloat64(this.offset, this.littleEndian)
                  return (this.offset += 8), t
                },
                getFloat64Array: function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push(this.getFloat64())
                  return e
                },
                getArrayBuffer: function (t) {
                  var e = this.dv.buffer.slice(this.offset, this.offset + t)
                  return (this.offset += t), e
                },
                getString: function (t) {
                  for (var e = [], n = 0; n < t; n++) e[n] = this.getUint8()
                  var i = e.indexOf(0)
                  return i >= 0 && (e = e.slice(0, i)), Pu.decodeText(new Uint8Array(e))
                }
              }),
              (u.prototype = {
                constructor: u,
                add: function (t, e) {
                  this[t] = e
                }
              })
            var m = []
            function f(t, e, n, i) {
              var r
              switch (i.mappingType) {
                case 'ByPolygonVertex':
                  r = t
                  break
                case 'ByPolygon':
                  r = e
                  break
                case 'ByVertice':
                  r = n
                  break
                case 'AllSame':
                  r = i.indices[0]
                  break
                default:
                  console.warn('THREE.FBXLoader: unknown attribute mapping type ' + i.mappingType)
              }
              'IndexToDirect' === i.referenceType && (r = i.indices[r])
              var s = r * i.dataSize,
                o = s + i.dataSize
              return (function (t, e, n, i) {
                for (var r = n, s = 0; r < i; r++, s++) t[s] = e[r]
                return t
              })(m, i.buffer, s, o)
            }
            var g = new Gi(),
              v = new ei()
            function y(t) {
              var e,
                n = new Ii(),
                i = new Ii(),
                r = new Ii(),
                s = new Ii(),
                o = new Ii(),
                a = new Ii(),
                l = new Ii(),
                c = new Ii(),
                h = new Ii(),
                u = new Ii(),
                d = new Ii(),
                p = new Ii(),
                m = t.inheritType ? t.inheritType : 0
              t.translation && n.setPosition(v.fromArray(t.translation)),
                t.preRotation &&
                  ((e = t.preRotation.map(Vn.degToRad)).push(t.eulerOrder), i.makeRotationFromEuler(g.fromArray(e))),
                t.rotation &&
                  ((e = t.rotation.map(Vn.degToRad)).push(t.eulerOrder), r.makeRotationFromEuler(g.fromArray(e))),
                t.postRotation &&
                  ((e = t.postRotation.map(Vn.degToRad)).push(t.eulerOrder),
                  s.makeRotationFromEuler(g.fromArray(e)),
                  s.invert()),
                t.scale && o.scale(v.fromArray(t.scale)),
                t.scalingOffset && l.setPosition(v.fromArray(t.scalingOffset)),
                t.scalingPivot && a.setPosition(v.fromArray(t.scalingPivot)),
                t.rotationOffset && c.setPosition(v.fromArray(t.rotationOffset)),
                t.rotationPivot && h.setPosition(v.fromArray(t.rotationPivot)),
                t.parentMatrixWorld && (d.copy(t.parentMatrix), u.copy(t.parentMatrixWorld))
              var f = new Ii().copy(i).multiply(r).multiply(s),
                y = new Ii()
              y.extractRotation(u)
              var x = new Ii()
              x.copyPosition(u)
              var b = new Ii(),
                w = new Ii().copy(x).invert().multiply(u)
              b.copy(y).invert().multiply(w)
              var _ = o,
                M = new Ii()
              if (0 === m) M.copy(y).multiply(f).multiply(b).multiply(_)
              else if (1 === m) M.copy(y).multiply(b).multiply(f).multiply(_)
              else {
                var T = new Ii().scale(new ei().setFromMatrixScale(d)),
                  S = new Ii().copy(T).invert(),
                  E = new Ii().copy(b).multiply(S)
                M.copy(y).multiply(f).multiply(E).multiply(_)
              }
              var A = new Ii()
              A.copy(h).invert()
              var L = new Ii()
              L.copy(a).invert()
              var R = new Ii()
              R.copy(n)
                .multiply(c)
                .multiply(h)
                .multiply(i)
                .multiply(r)
                .multiply(s)
                .multiply(A)
                .multiply(l)
                .multiply(a)
                .multiply(o)
                .multiply(L)
              var P = new Ii().copyPosition(R),
                C = new Ii().copy(u).multiply(P)
              return p.copyPosition(C), (R = new Ii().copy(p).multiply(M)).premultiply(u.invert()), R
            }
            function x(t) {
              var e = ['ZYX', 'YZX', 'XZY', 'ZXY', 'YXZ', 'XYZ']
              return 6 === (t = t || 0)
                ? (console.warn(
                    'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.'
                  ),
                  e[0])
                : e[t]
            }
            function b(t) {
              return t.split(',').map(function (t) {
                return parseFloat(t)
              })
            }
            function w(t, e, n) {
              return void 0 === e && (e = 0), void 0 === n && (n = t.byteLength), Pu.decodeText(new Uint8Array(t, e, n))
            }
            function _(t, e, n) {
              return t.slice(0, e).concat(n).concat(t.slice(e))
            }
            return r
          })(),
          qv = (function () {
            function t(t) {
              Ch.call(this, t),
                (this.dracoLoader = null),
                (this.ktx2Loader = null),
                (this.meshoptDecoder = null),
                (this.pluginCallbacks = []),
                this.register(function (t) {
                  return new s(t)
                }),
                this.register(function (t) {
                  return new a(t)
                }),
                this.register(function (t) {
                  return new l(t)
                }),
                this.register(function (t) {
                  return new o(t)
                }),
                this.register(function (t) {
                  return new i(t)
                }),
                this.register(function (t) {
                  return new c(t)
                })
            }
            function e() {
              var t = {}
              return {
                get: function (e) {
                  return t[e]
                },
                add: function (e, n) {
                  t[e] = n
                },
                remove: function (e) {
                  delete t[e]
                },
                removeAll: function () {
                  t = {}
                }
              }
            }
            t.prototype = Object.assign(Object.create(Ch.prototype), {
              constructor: t,
              load: function (t, e, n, i) {
                var r,
                  s = this
                ;(r =
                  '' !== this.resourcePath ? this.resourcePath : '' !== this.path ? this.path : Pu.extractUrlBase(t)),
                  this.manager.itemStart(t)
                var o = function (e) {
                    i ? i(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t)
                  },
                  a = new Dh(this.manager)
                a.setPath(this.path),
                  a.setResponseType('arraybuffer'),
                  a.setRequestHeader(this.requestHeader),
                  a.setWithCredentials(this.withCredentials),
                  a.load(
                    t,
                    function (n) {
                      try {
                        s.parse(
                          n,
                          r,
                          function (n) {
                            e(n), s.manager.itemEnd(t)
                          },
                          o
                        )
                      } catch (t) {
                        o(t)
                      }
                    },
                    n,
                    o
                  )
              },
              setDRACOLoader: function (t) {
                return (this.dracoLoader = t), this
              },
              setDDSLoader: function () {
                throw new Error(
                  'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
                )
              },
              setKTX2Loader: function (t) {
                return (this.ktx2Loader = t), this
              },
              setMeshoptDecoder: function (t) {
                return (this.meshoptDecoder = t), this
              },
              register: function (t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
              },
              unregister: function (t) {
                return (
                  -1 !== this.pluginCallbacks.indexOf(t) &&
                    this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                  this
                )
              },
              parse: function (t, e, i, s) {
                var o,
                  a = {},
                  l = {}
                if ('string' == typeof t) o = t
                else if (Pu.decodeText(new Uint8Array(t, 0, 4)) === h) {
                  try {
                    a[n.KHR_BINARY_GLTF] = new u(t)
                  } catch (t) {
                    return void (s && s(t))
                  }
                  o = a[n.KHR_BINARY_GLTF].content
                } else o = Pu.decodeText(new Uint8Array(t))
                var c = JSON.parse(o)
                if (void 0 === c.asset || c.asset.version[0] < 2)
                  s && s(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))
                else {
                  var m = new I(c, {
                    path: e || this.resourcePath || '',
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                  })
                  m.fileLoader.setRequestHeader(this.requestHeader)
                  for (var v = 0; v < this.pluginCallbacks.length; v++) {
                    var y = this.pluginCallbacks[v](m)
                    ;(l[y.name] = y), (a[y.name] = !0)
                  }
                  if (c.extensionsUsed)
                    for (v = 0; v < c.extensionsUsed.length; ++v) {
                      var x = c.extensionsUsed[v],
                        b = c.extensionsRequired || []
                      switch (x) {
                        case n.KHR_MATERIALS_UNLIT:
                          a[x] = new r()
                          break
                        case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                          a[x] = new f()
                          break
                        case n.KHR_DRACO_MESH_COMPRESSION:
                          a[x] = new d(c, this.dracoLoader)
                          break
                        case n.KHR_TEXTURE_TRANSFORM:
                          a[x] = new p()
                          break
                        case n.KHR_MESH_QUANTIZATION:
                          a[x] = new g()
                          break
                        default:
                          b.indexOf(x) >= 0 &&
                            void 0 === l[x] &&
                            console.warn('THREE.GLTFLoader: Unknown extension "' + x + '".')
                      }
                    }
                  m.setExtensions(a), m.setPlugins(l), m.parse(i, s)
                }
              }
            })
            var n = {
              KHR_BINARY_GLTF: 'KHR_binary_glTF',
              KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
              KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
              KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
              KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
              KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
              KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
              KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
              KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
              KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
              EXT_TEXTURE_WEBP: 'EXT_texture_webp',
              EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
            }
            function i(t) {
              ;(this.parser = t), (this.name = n.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} })
            }
            function r() {
              this.name = n.KHR_MATERIALS_UNLIT
            }
            function s(t) {
              ;(this.parser = t), (this.name = n.KHR_MATERIALS_CLEARCOAT)
            }
            function o(t) {
              ;(this.parser = t), (this.name = n.KHR_MATERIALS_TRANSMISSION)
            }
            function a(t) {
              ;(this.parser = t), (this.name = n.KHR_TEXTURE_BASISU)
            }
            function l(t) {
              ;(this.parser = t), (this.name = n.EXT_TEXTURE_WEBP), (this.isSupported = null)
            }
            function c(t) {
              ;(this.name = n.EXT_MESHOPT_COMPRESSION), (this.parser = t)
            }
            ;(i.prototype._markDefs = function () {
              for (var t = this.parser, e = this.parser.json.nodes || [], n = 0, i = e.length; n < i; n++) {
                var r = e[n]
                r.extensions &&
                  r.extensions[this.name] &&
                  void 0 !== r.extensions[this.name].light &&
                  t._addNodeRef(this.cache, r.extensions[this.name].light)
              }
            }),
              (i.prototype._loadLight = function (t) {
                var e = this.parser,
                  n = 'light:' + t,
                  i = e.cache.get(n)
                if (i) return i
                var r,
                  s = e.json,
                  o = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t],
                  a = new Ar(16777215)
                void 0 !== o.color && a.fromArray(o.color)
                var l = void 0 !== o.range ? o.range : 0
                switch (o.type) {
                  case 'directional':
                    ;(r = new Tu(a)).target.position.set(0, 0, -1), r.add(r.target)
                    break
                  case 'point':
                    ;(r = new wu(a)).distance = l
                    break
                  case 'spot':
                    ;((r = new gu(a)).distance = l),
                      (o.spot = o.spot || {}),
                      (o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0),
                      (o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4),
                      (r.angle = o.spot.outerConeAngle),
                      (r.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle),
                      r.target.position.set(0, 0, -1),
                      r.add(r.target)
                    break
                  default:
                    throw new Error('THREE.GLTFLoader: Unexpected light type: ' + o.type)
                }
                return (
                  r.position.set(0, 0, 0),
                  (r.decay = 2),
                  void 0 !== o.intensity && (r.intensity = o.intensity),
                  (r.name = e.createUniqueName(o.name || 'light_' + t)),
                  (i = Promise.resolve(r)),
                  e.cache.add(n, i),
                  i
                )
              }),
              (i.prototype.createNodeAttachment = function (t) {
                var e = this,
                  n = this.parser,
                  i = n.json.nodes[t],
                  r = ((i.extensions && i.extensions[this.name]) || {}).light
                return void 0 === r
                  ? null
                  : this._loadLight(r).then(function (t) {
                      return n._getNodeRef(e.cache, r, t)
                    })
              }),
              (r.prototype.getMaterialType = function () {
                return Lr
              }),
              (r.prototype.extendParams = function (t, e, n) {
                var i = []
                ;(t.color = new Ar(1, 1, 1)), (t.opacity = 1)
                var r = e.pbrMetallicRoughness
                if (r) {
                  if (Array.isArray(r.baseColorFactor)) {
                    var s = r.baseColorFactor
                    t.color.fromArray(s), (t.opacity = s[3])
                  }
                  void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, 'map', r.baseColorTexture))
                }
                return Promise.all(i)
              }),
              (s.prototype.getMaterialType = function (t) {
                var e = this.parser.json.materials[t]
                return e.extensions && e.extensions[this.name] ? sh : null
              }),
              (s.prototype.extendMaterialParams = function (t, e) {
                var n = this.parser,
                  i = n.json.materials[t]
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
                var r = [],
                  s = i.extensions[this.name]
                if (
                  (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                  void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, 'clearcoatMap', s.clearcoatTexture)),
                  void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                  void 0 !== s.clearcoatRoughnessTexture &&
                    r.push(n.assignTexture(e, 'clearcoatRoughnessMap', s.clearcoatRoughnessTexture)),
                  void 0 !== s.clearcoatNormalTexture &&
                    (r.push(n.assignTexture(e, 'clearcoatNormalMap', s.clearcoatNormalTexture)),
                    void 0 !== s.clearcoatNormalTexture.scale))
                ) {
                  var o = s.clearcoatNormalTexture.scale
                  e.clearcoatNormalScale = new Wn(o, -o)
                }
                return Promise.all(r)
              }),
              (o.prototype.getMaterialType = function (t) {
                var e = this.parser.json.materials[t]
                return e.extensions && e.extensions[this.name] ? sh : null
              }),
              (o.prototype.extendMaterialParams = function (t, e) {
                var n = this.parser,
                  i = n.json.materials[t]
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
                var r = [],
                  s = i.extensions[this.name]
                return (
                  void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
                  void 0 !== s.transmissionTexture &&
                    r.push(n.assignTexture(e, 'transmissionMap', s.transmissionTexture)),
                  Promise.all(r)
                )
              }),
              (a.prototype.loadTexture = function (t) {
                var e = this.parser,
                  n = e.json,
                  i = n.textures[t]
                if (!i.extensions || !i.extensions[this.name]) return null
                var r = i.extensions[this.name],
                  s = n.images[r.source],
                  o = e.options.ktx2Loader
                if (!o) {
                  if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')
                  return null
                }
                return e.loadTextureImage(t, s, o)
              }),
              (l.prototype.loadTexture = function (t) {
                var e = this.name,
                  n = this.parser,
                  i = n.json,
                  r = i.textures[t]
                if (!r.extensions || !r.extensions[e]) return null
                var s = r.extensions[e],
                  o = i.images[s.source],
                  a = n.textureLoader
                if (o.uri) {
                  var l = n.options.manager.getHandler(o.uri)
                  null !== l && (a = l)
                }
                return this.detectSupport().then(function (r) {
                  if (r) return n.loadTextureImage(t, o, a)
                  if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                    throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
                  return n.loadTexture(t)
                })
              }),
              (l.prototype.detectSupport = function () {
                return (
                  this.isSupported ||
                    (this.isSupported = new Promise(function (t) {
                      var e = new Image()
                      ;(e.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                        (e.onload = e.onerror = function () {
                          t(1 === e.height)
                        })
                    })),
                  this.isSupported
                )
              }),
              (c.prototype.loadBufferView = function (t) {
                var e = this.parser.json,
                  n = e.bufferViews[t]
                if (n.extensions && n.extensions[this.name]) {
                  var i = n.extensions[this.name],
                    r = this.parser.getDependency('buffer', i.buffer),
                    s = this.parser.options.meshoptDecoder
                  if (!s || !s.supported) {
                    if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                      throw new Error(
                        'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
                      )
                    return null
                  }
                  return Promise.all([r, s.ready]).then(function (t) {
                    var e = i.byteOffset || 0,
                      n = i.byteLength || 0,
                      r = i.count,
                      o = i.byteStride,
                      a = new ArrayBuffer(r * o),
                      l = new Uint8Array(t[0], e, n)
                    return s.decodeGltfBuffer(new Uint8Array(a), r, o, l, i.mode, i.filter), a
                  })
                }
                return null
              })
            var h = 'glTF'
            function u(t) {
              ;(this.name = n.KHR_BINARY_GLTF), (this.content = null), (this.body = null)
              var e = new DataView(t, 0, 12)
              if (
                ((this.header = {
                  magic: Pu.decodeText(new Uint8Array(t.slice(0, 4))),
                  version: e.getUint32(4, !0),
                  length: e.getUint32(8, !0)
                }),
                this.header.magic !== h)
              )
                throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
              if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
              for (var i = this.header.length - 12, r = new DataView(t, 12), s = 0; s < i; ) {
                var o = r.getUint32(s, !0)
                s += 4
                var a = r.getUint32(s, !0)
                if (((s += 4), 1313821514 === a)) {
                  var l = new Uint8Array(t, 12 + s, o)
                  this.content = Pu.decodeText(l)
                } else if (5130562 === a) {
                  var c = 12 + s
                  this.body = t.slice(c, c + o)
                }
                s += o
              }
              if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.')
            }
            function d(t, e) {
              if (!e) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
              ;(this.name = n.KHR_DRACO_MESH_COMPRESSION),
                (this.json = t),
                (this.dracoLoader = e),
                this.dracoLoader.preload()
            }
            function p() {
              this.name = n.KHR_TEXTURE_TRANSFORM
            }
            function m(t) {
              rh.call(this), (this.isGLTFSpecularGlossinessMaterial = !0)
              var e = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\n'),
                n = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\n'),
                i = [
                  'vec3 specularFactor = specular;',
                  '#ifdef USE_SPECULARMAP',
                  '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
                  '\ttexelSpecular = sRGBToLinear( texelSpecular );',
                  '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tspecularFactor *= texelSpecular.rgb;',
                  '#endif'
                ].join('\n'),
                r = [
                  'float glossinessFactor = glossiness;',
                  '#ifdef USE_GLOSSINESSMAP',
                  '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
                  '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tglossinessFactor *= texelGlossiness.a;',
                  '#endif'
                ].join('\n'),
                s = [
                  'PhysicalMaterial material;',
                  'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
                  'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
                  'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
                  'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
                  'material.specularRoughness += geometryRoughness;',
                  'material.specularRoughness = min( material.specularRoughness, 1.0 );',
                  'material.specularColor = specularFactor;'
                ].join('\n'),
                o = {
                  specular: { value: new Ar().setHex(16777215) },
                  glossiness: { value: 1 },
                  specularMap: { value: null },
                  glossinessMap: { value: null }
                }
              ;(this._extraUniforms = o),
                (this.onBeforeCompile = function (t) {
                  for (var a in o) t.uniforms[a] = o[a]
                  t.fragmentShader = t.fragmentShader
                    .replace('uniform float roughness;', 'uniform vec3 specular;')
                    .replace('uniform float metalness;', 'uniform float glossiness;')
                    .replace('#include <roughnessmap_pars_fragment>', e)
                    .replace('#include <metalnessmap_pars_fragment>', n)
                    .replace('#include <roughnessmap_fragment>', i)
                    .replace('#include <metalnessmap_fragment>', r)
                    .replace('#include <lights_physical_fragment>', s)
                }),
                Object.defineProperties(this, {
                  specular: {
                    get: function () {
                      return o.specular.value
                    },
                    set: function (t) {
                      o.specular.value = t
                    }
                  },
                  specularMap: {
                    get: function () {
                      return o.specularMap.value
                    },
                    set: function (t) {
                      ;(o.specularMap.value = t),
                        t ? (this.defines.USE_SPECULARMAP = '') : delete this.defines.USE_SPECULARMAP
                    }
                  },
                  glossiness: {
                    get: function () {
                      return o.glossiness.value
                    },
                    set: function (t) {
                      o.glossiness.value = t
                    }
                  },
                  glossinessMap: {
                    get: function () {
                      return o.glossinessMap.value
                    },
                    set: function (t) {
                      ;(o.glossinessMap.value = t),
                        t
                          ? ((this.defines.USE_GLOSSINESSMAP = ''), (this.defines.USE_UV = ''))
                          : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                  }
                }),
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this.setValues(t)
            }
            function f() {
              return {
                name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: [
                  'color',
                  'map',
                  'lightMap',
                  'lightMapIntensity',
                  'aoMap',
                  'aoMapIntensity',
                  'emissive',
                  'emissiveIntensity',
                  'emissiveMap',
                  'bumpMap',
                  'bumpScale',
                  'normalMap',
                  'normalMapType',
                  'displacementMap',
                  'displacementScale',
                  'displacementBias',
                  'specularMap',
                  'specular',
                  'glossinessMap',
                  'glossiness',
                  'alphaMap',
                  'envMap',
                  'envMapIntensity',
                  'refractionRatio'
                ],
                getMaterialType: function () {
                  return m
                },
                extendParams: function (t, e, n) {
                  var i = e.extensions[this.name]
                  ;(t.color = new Ar(1, 1, 1)), (t.opacity = 1)
                  var r = []
                  if (Array.isArray(i.diffuseFactor)) {
                    var s = i.diffuseFactor
                    t.color.fromArray(s), (t.opacity = s[3])
                  }
                  if (
                    (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, 'map', i.diffuseTexture)),
                    (t.emissive = new Ar(0, 0, 0)),
                    (t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
                    (t.specular = new Ar(1, 1, 1)),
                    Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor),
                    void 0 !== i.specularGlossinessTexture)
                  ) {
                    var o = i.specularGlossinessTexture
                    r.push(n.assignTexture(t, 'glossinessMap', o)), r.push(n.assignTexture(t, 'specularMap', o))
                  }
                  return Promise.all(r)
                },
                createMaterial: function (t) {
                  var e = new m(t)
                  return (
                    (e.fog = !0),
                    (e.color = t.color),
                    (e.map = void 0 === t.map ? null : t.map),
                    (e.lightMap = null),
                    (e.lightMapIntensity = 1),
                    (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
                    (e.aoMapIntensity = 1),
                    (e.emissive = t.emissive),
                    (e.emissiveIntensity = 1),
                    (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
                    (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
                    (e.bumpScale = 1),
                    (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
                    (e.normalMapType = un),
                    t.normalScale && (e.normalScale = t.normalScale),
                    (e.displacementMap = null),
                    (e.displacementScale = 1),
                    (e.displacementBias = 0),
                    (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
                    (e.specular = t.specular),
                    (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
                    (e.glossiness = t.glossiness),
                    (e.alphaMap = null),
                    (e.envMap = void 0 === t.envMap ? null : t.envMap),
                    (e.envMapIntensity = 1),
                    (e.refractionRatio = 0.98),
                    e
                  )
                }
              }
            }
            function g() {
              this.name = n.KHR_MESH_QUANTIZATION
            }
            function v(t, e, n, i) {
              mh.call(this, t, e, n, i)
            }
            ;(d.prototype.decodePrimitive = function (t, e) {
              var n = this.json,
                i = this.dracoLoader,
                r = t.extensions[this.name].bufferView,
                s = t.extensions[this.name].attributes,
                o = {},
                a = {},
                l = {}
              for (var c in s) {
                var h = T[c] || c.toLowerCase()
                o[h] = s[c]
              }
              for (c in t.attributes)
                if (((h = T[c] || c.toLowerCase()), void 0 !== s[c])) {
                  var u = n.accessors[t.attributes[c]],
                    d = x[u.componentType]
                  ;(l[h] = d), (a[h] = !0 === u.normalized)
                }
              return e.getDependency('bufferView', r).then(function (t) {
                return new Promise(function (e) {
                  i.decodeDracoFile(
                    t,
                    function (t) {
                      for (var n in t.attributes) {
                        var i = t.attributes[n],
                          r = a[n]
                        void 0 !== r && (i.normalized = r)
                      }
                      e(t)
                    },
                    o,
                    l
                  )
                })
              })
            }),
              (p.prototype.extendTexture = function (t, e) {
                return (
                  (t = t.clone()),
                  void 0 !== e.offset && t.offset.fromArray(e.offset),
                  void 0 !== e.rotation && (t.rotation = e.rotation),
                  void 0 !== e.scale && t.repeat.fromArray(e.scale),
                  void 0 !== e.texCoord &&
                    console.warn(
                      'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'
                    ),
                  (t.needsUpdate = !0),
                  t
                )
              }),
              (m.prototype = Object.create(rh.prototype)),
              (m.prototype.constructor = m),
              (m.prototype.copy = function (t) {
                return (
                  rh.prototype.copy.call(this, t),
                  (this.specularMap = t.specularMap),
                  this.specular.copy(t.specular),
                  (this.glossinessMap = t.glossinessMap),
                  (this.glossiness = t.glossiness),
                  delete this.metalness,
                  delete this.roughness,
                  delete this.metalnessMap,
                  delete this.roughnessMap,
                  this
                )
              }),
              (v.prototype = Object.create(mh.prototype)),
              (v.prototype.constructor = v),
              (v.prototype.copySampleValue_ = function (t) {
                for (
                  var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i * 3 + i, s = 0;
                  s !== i;
                  s++
                )
                  e[s] = n[r + s]
                return e
              }),
              (v.prototype.beforeStart_ = v.prototype.copySampleValue_),
              (v.prototype.afterEnd_ = v.prototype.copySampleValue_),
              (v.prototype.interpolate_ = function (t, e, n, i) {
                for (
                  var r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = 2 * o,
                    l = 3 * o,
                    c = i - e,
                    h = (n - e) / c,
                    u = h * h,
                    d = u * h,
                    p = t * l,
                    m = p - l,
                    f = -2 * d + 3 * u,
                    g = d - u,
                    v = 1 - f,
                    y = g - u + h,
                    x = 0;
                  x !== o;
                  x++
                ) {
                  var b = s[m + x + o],
                    w = s[m + x + a] * c,
                    _ = s[p + x + o],
                    M = s[p + x] * c
                  r[x] = v * b + y * w + f * _ + g * M
                }
                return r
              })
            var x = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
              },
              w = { 9728: yt, 9729: Mt, 9984: xt, 9985: Tt, 9986: wt, 9987: Et },
              _ = { 33071: gt, 33648: vt, 10497: ft },
              M = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
              T = {
                POSITION: 'position',
                NORMAL: 'normal',
                TANGENT: 'tangent',
                TEXCOORD_0: 'uv',
                TEXCOORD_1: 'uv2',
                COLOR_0: 'color',
                WEIGHTS_0: 'skinWeight',
                JOINTS_0: 'skinIndex'
              },
              S = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' },
              E = { CUBICSPLINE: void 0, LINEAR: We, STEP: Ve }
            function A(t, e) {
              return 'string' != typeof t || '' === t
                ? ''
                : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
                  /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
            function L(t, e, n) {
              for (var i in n.extensions)
                void 0 === t[i] &&
                  ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
                  (e.userData.gltfExtensions[i] = n.extensions[i]))
            }
            function R(t, e) {
              void 0 !== e.extras &&
                ('object' == typeof e.extras
                  ? Object.assign(t.userData, e.extras)
                  : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras))
            }
            function P(t, e) {
              if ((t.updateMorphTargets(), void 0 !== e.weights))
                for (var n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n]
              if (e.extras && Array.isArray(e.extras.targetNames)) {
                var r = e.extras.targetNames
                if (t.morphTargetInfluences.length === r.length)
                  for (t.morphTargetDictionary = {}, n = 0, i = r.length; n < i; n++) t.morphTargetDictionary[r[n]] = n
                else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')
              }
            }
            function C(t) {
              for (var e = '', n = Object.keys(t).sort(), i = 0, r = n.length; i < r; i++)
                e += n[i] + ':' + t[n[i]] + ';'
              return e
            }
            function I(t, n) {
              ;(this.json = t || {}),
                (this.extensions = {}),
                (this.plugins = {}),
                (this.options = n || {}),
                (this.cache = new e()),
                (this.associations = new Map()),
                (this.primitiveCache = {}),
                (this.meshCache = { refs: {}, uses: {} }),
                (this.cameraCache = { refs: {}, uses: {} }),
                (this.lightCache = { refs: {}, uses: {} }),
                (this.nodeNamesUsed = {}),
                'undefined' != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent)
                  ? (this.textureLoader = new zu(this.options.manager))
                  : (this.textureLoader = new kh(this.options.manager)),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                (this.fileLoader = new Dh(this.options.manager)),
                this.fileLoader.setResponseType('arraybuffer'),
                'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            function D(t, e, n) {
              var i = e.attributes,
                r = []
              function s(e, i) {
                return n.getDependency('accessor', e).then(function (e) {
                  t.setAttribute(i, e)
                })
              }
              for (var o in i) {
                var a = T[o] || o.toLowerCase()
                a in t.attributes || r.push(s(i[o], a))
              }
              if (void 0 !== e.indices && !t.index) {
                var l = n.getDependency('accessor', e.indices).then(function (e) {
                  t.setIndex(e)
                })
                r.push(l)
              }
              return (
                R(t, e),
                (function (t, e, n) {
                  var i = e.attributes,
                    r = new ri()
                  if (void 0 !== i.POSITION) {
                    var s = (d = n.json.accessors[i.POSITION]).min,
                      o = d.max
                    if (void 0 !== s && void 0 !== o) {
                      r.set(new ei(s[0], s[1], s[2]), new ei(o[0], o[1], o[2]))
                      var a = e.targets
                      if (void 0 !== a) {
                        for (var l = new ei(), c = new ei(), h = 0, u = a.length; h < u; h++) {
                          var d,
                            p = a[h]
                          void 0 !== p.POSITION &&
                            ((s = (d = n.json.accessors[p.POSITION]).min),
                            (o = d.max),
                            void 0 !== s && void 0 !== o
                              ? (c.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                                c.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                                c.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                                l.max(c))
                              : console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'))
                        }
                        r.expandByVector(l)
                      }
                      t.boundingBox = r
                      var m = new Mi()
                      r.getCenter(m.center), (m.radius = r.min.distanceTo(r.max) / 2), (t.boundingSphere = m)
                    } else console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
                  }
                })(t, e, n),
                Promise.all(r).then(function () {
                  return void 0 !== e.targets
                    ? (function (t, e, n) {
                        for (
                          var i = !1, r = !1, s = 0, o = e.length;
                          s < o &&
                          (void 0 !== (c = e[s]).POSITION && (i = !0), void 0 !== c.NORMAL && (r = !0), !i || !r);
                          s++
                        );
                        if (!i && !r) return Promise.resolve(t)
                        var a = [],
                          l = []
                        for (s = 0, o = e.length; s < o; s++) {
                          var c = e[s]
                          if (i) {
                            var h =
                              void 0 !== c.POSITION ? n.getDependency('accessor', c.POSITION) : t.attributes.position
                            a.push(h)
                          }
                          r &&
                            ((h = void 0 !== c.NORMAL ? n.getDependency('accessor', c.NORMAL) : t.attributes.normal),
                            l.push(h))
                        }
                        return Promise.all([Promise.all(a), Promise.all(l)]).then(function (e) {
                          var n = e[0],
                            s = e[1]
                          return (
                            i && (t.morphAttributes.position = n),
                            r && (t.morphAttributes.normal = s),
                            (t.morphTargetsRelative = !0),
                            t
                          )
                        })
                      })(t, e.targets, n)
                    : t
                })
              )
            }
            function O(t, e) {
              var n = t.getIndex()
              if (null === n) {
                var i = [],
                  r = t.getAttribute('position')
                if (void 0 === r)
                  return (
                    console.error(
                      'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
                    ),
                    t
                  )
                for (var s = 0; s < r.count; s++) i.push(s)
                t.setIndex(i), (n = t.getIndex())
              }
              var o = n.count - 2,
                a = []
              if (e === $e) for (s = 1; s <= o; s++) a.push(n.getX(0)), a.push(n.getX(s)), a.push(n.getX(s + 1))
              else
                for (s = 0; s < o; s++)
                  s % 2 == 0
                    ? (a.push(n.getX(s)), a.push(n.getX(s + 1)), a.push(n.getX(s + 2)))
                    : (a.push(n.getX(s + 2)), a.push(n.getX(s + 1)), a.push(n.getX(s)))
              a.length / 3 !== o &&
                console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')
              var l = t.clone()
              return l.setIndex(a), l
            }
            return (
              (I.prototype.setExtensions = function (t) {
                this.extensions = t
              }),
              (I.prototype.setPlugins = function (t) {
                this.plugins = t
              }),
              (I.prototype.parse = function (t, e) {
                var n = this,
                  i = this.json,
                  r = this.extensions
                this.cache.removeAll(),
                  this._invokeAll(function (t) {
                    return t._markDefs && t._markDefs()
                  }),
                  Promise.all(
                    this._invokeAll(function (t) {
                      return t.beforeRoot && t.beforeRoot()
                    })
                  )
                    .then(function () {
                      return Promise.all([
                        n.getDependencies('scene'),
                        n.getDependencies('animation'),
                        n.getDependencies('camera')
                      ])
                    })
                    .then(function (e) {
                      var s = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                      }
                      L(r, s, i),
                        R(s, i),
                        Promise.all(
                          n._invokeAll(function (t) {
                            return t.afterRoot && t.afterRoot(s)
                          })
                        ).then(function () {
                          t(s)
                        })
                    })
                    .catch(e)
              }),
              (I.prototype._markDefs = function () {
                for (
                  var t = this.json.nodes || [],
                    e = this.json.skins || [],
                    n = this.json.meshes || [],
                    i = 0,
                    r = e.length;
                  i < r;
                  i++
                )
                  for (var s = e[i].joints, o = 0, a = s.length; o < a; o++) t[s[o]].isBone = !0
                for (var l = 0, c = t.length; l < c; l++) {
                  var h = t[l]
                  void 0 !== h.mesh &&
                    (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (n[h.mesh].isSkinnedMesh = !0)),
                    void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera)
                }
              }),
              (I.prototype._addNodeRef = function (t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
              }),
              (I.prototype._getNodeRef = function (t, e, n) {
                if (t.refs[e] <= 1) return n
                var i = n.clone()
                return (i.name += '_instance_' + t.uses[e]++), i
              }),
              (I.prototype._invokeOne = function (t) {
                var e = Object.values(this.plugins)
                e.push(this)
                for (var n = 0; n < e.length; n++) {
                  var i = t(e[n])
                  if (i) return i
                }
              }),
              (I.prototype._invokeAll = function (t) {
                var e = Object.values(this.plugins)
                e.unshift(this)
                for (var n = [], i = 0; i < e.length; i++) {
                  var r = t(e[i])
                  r && n.push(r)
                }
                return n
              }),
              (I.prototype.getDependency = function (t, e) {
                var n = t + ':' + e,
                  i = this.cache.get(n)
                if (!i) {
                  switch (t) {
                    case 'scene':
                      i = this.loadScene(e)
                      break
                    case 'node':
                      i = this.loadNode(e)
                      break
                    case 'mesh':
                      i = this._invokeOne(function (t) {
                        return t.loadMesh && t.loadMesh(e)
                      })
                      break
                    case 'accessor':
                      i = this.loadAccessor(e)
                      break
                    case 'bufferView':
                      i = this._invokeOne(function (t) {
                        return t.loadBufferView && t.loadBufferView(e)
                      })
                      break
                    case 'buffer':
                      i = this.loadBuffer(e)
                      break
                    case 'material':
                      i = this._invokeOne(function (t) {
                        return t.loadMaterial && t.loadMaterial(e)
                      })
                      break
                    case 'texture':
                      i = this._invokeOne(function (t) {
                        return t.loadTexture && t.loadTexture(e)
                      })
                      break
                    case 'skin':
                      i = this.loadSkin(e)
                      break
                    case 'animation':
                      i = this.loadAnimation(e)
                      break
                    case 'camera':
                      i = this.loadCamera(e)
                      break
                    default:
                      throw new Error('Unknown type: ' + t)
                  }
                  this.cache.add(n, i)
                }
                return i
              }),
              (I.prototype.getDependencies = function (t) {
                var e = this.cache.get(t)
                if (!e) {
                  var n = this,
                    i = this.json[t + ('mesh' === t ? 'es' : 's')] || []
                  ;(e = Promise.all(
                    i.map(function (e, i) {
                      return n.getDependency(t, i)
                    })
                  )),
                    this.cache.add(t, e)
                }
                return e
              }),
              (I.prototype.loadBuffer = function (t) {
                var e = this.json.buffers[t],
                  i = this.fileLoader
                if (e.type && 'arraybuffer' !== e.type)
                  throw new Error('THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.')
                if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body)
                var r = this.options
                return new Promise(function (t, n) {
                  i.load(A(e.uri, r.path), t, void 0, function () {
                    n(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                  })
                })
              }),
              (I.prototype.loadBufferView = function (t) {
                var e = this.json.bufferViews[t]
                return this.getDependency('buffer', e.buffer).then(function (t) {
                  var n = e.byteLength || 0,
                    i = e.byteOffset || 0
                  return t.slice(i, i + n)
                })
              }),
              (I.prototype.loadAccessor = function (t) {
                var e = this,
                  n = this.json,
                  i = this.json.accessors[t]
                if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null)
                var r = []
                return (
                  void 0 !== i.bufferView ? r.push(this.getDependency('bufferView', i.bufferView)) : r.push(null),
                  void 0 !== i.sparse &&
                    (r.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
                    r.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
                  Promise.all(r).then(function (t) {
                    var r,
                      s = t[0],
                      o = M[i.type],
                      a = x[i.componentType],
                      l = a.BYTES_PER_ELEMENT,
                      c = l * o,
                      h = i.byteOffset || 0,
                      u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                      d = !0 === i.normalized
                    if (u && u !== c) {
                      var p = Math.floor(h / u),
                        m = 'InterleavedBuffer:' + i.bufferView + ':' + i.componentType + ':' + p + ':' + i.count,
                        f = e.cache.get(m)
                      f || ((f = new Qa(new a(s, p * u, (i.count * u) / l), u / l)), e.cache.add(m, f)),
                        (r = new tl(f, o, (h % u) / l, d))
                    } else r = new Cr(null === s ? new a(i.count * o) : new a(s, h, i.count * o), o, d)
                    if (void 0 !== i.sparse) {
                      var g = M.SCALAR,
                        v = x[i.sparse.indices.componentType],
                        y = i.sparse.indices.byteOffset || 0,
                        b = i.sparse.values.byteOffset || 0,
                        w = new v(t[1], y, i.sparse.count * g),
                        _ = new a(t[2], b, i.sparse.count * o)
                      null !== s && (r = new Cr(r.array.slice(), r.itemSize, r.normalized))
                      for (var T = 0, S = w.length; T < S; T++) {
                        var E = w[T]
                        if (
                          (r.setX(E, _[T * o]),
                          o >= 2 && r.setY(E, _[T * o + 1]),
                          o >= 3 && r.setZ(E, _[T * o + 2]),
                          o >= 4 && r.setW(E, _[T * o + 3]),
                          o >= 5)
                        )
                          throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
                      }
                    }
                    return r
                  })
                )
              }),
              (I.prototype.loadTexture = function (t) {
                var e = this.json,
                  n = this.options,
                  i = e.textures[t],
                  r = e.images[i.source],
                  s = this.textureLoader
                if (r.uri) {
                  var o = n.manager.getHandler(r.uri)
                  null !== o && (s = o)
                }
                return this.loadTextureImage(t, r, s)
              }),
              (I.prototype.loadTextureImage = function (t, e, n) {
                var i = this,
                  r = this.json,
                  s = this.options,
                  o = r.textures[t],
                  a = self.URL || self.webkitURL,
                  l = e.uri,
                  c = !1,
                  h = !0
                if (('image/jpeg' === e.mimeType && (h = !1), void 0 !== e.bufferView))
                  l = i.getDependency('bufferView', e.bufferView).then(function (t) {
                    if ('image/png' === e.mimeType) {
                      var n = new DataView(t, 25, 1).getUint8(0, !1)
                      h = 6 === n || 4 === n || 3 === n
                    }
                    c = !0
                    var i = new Blob([t], { type: e.mimeType })
                    return (l = a.createObjectURL(i))
                  })
                else if (void 0 === e.uri)
                  throw new Error('THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView')
                return Promise.resolve(l)
                  .then(function (t) {
                    return new Promise(function (e, i) {
                      var r = e
                      !0 === n.isImageBitmapLoader &&
                        (r = function (t) {
                          e(new ec(t))
                        }),
                        n.load(A(t, s.path), r, void 0, i)
                    })
                  })
                  .then(function (e) {
                    !0 === c && a.revokeObjectURL(l), (e.flipY = !1), o.name && (e.name = o.name), h || (e.format = Ht)
                    var n = (r.samplers || {})[o.sampler] || {}
                    return (
                      (e.magFilter = w[n.magFilter] || Mt),
                      (e.minFilter = w[n.minFilter] || Et),
                      (e.wrapS = _[n.wrapS] || ft),
                      (e.wrapT = _[n.wrapT] || ft),
                      i.associations.set(e, { type: 'textures', index: t }),
                      e
                    )
                  })
              }),
              (I.prototype.assignTexture = function (t, e, i) {
                var r = this
                return this.getDependency('texture', i.index).then(function (s) {
                  if (
                    (void 0 === i.texCoord ||
                      0 == i.texCoord ||
                      ('aoMap' === e && 1 == i.texCoord) ||
                      console.warn(
                        'THREE.GLTFLoader: Custom UV set ' + i.texCoord + ' for texture ' + e + ' not yet supported.'
                      ),
                    r.extensions[n.KHR_TEXTURE_TRANSFORM])
                  ) {
                    var o = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0
                    if (o) {
                      var a = r.associations.get(s)
                      ;(s = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(s, o)), r.associations.set(s, a)
                    }
                  }
                  t[e] = s
                })
              }),
              (I.prototype.assignFinalMaterial = function (t) {
                var e = t.geometry,
                  n = t.material,
                  i = void 0 !== e.attributes.tangent,
                  r = void 0 !== e.attributes.color,
                  s = void 0 === e.attributes.normal,
                  o = !0 === t.isSkinnedMesh,
                  a = Object.keys(e.morphAttributes).length > 0,
                  l = a && void 0 !== e.morphAttributes.normal
                if (t.isPoints) {
                  var c = 'PointsMaterial:' + n.uuid,
                    h = this.cache.get(c)
                  h ||
                    ((h = new ql()),
                    br.prototype.copy.call(h, n),
                    h.color.copy(n.color),
                    (h.map = n.map),
                    (h.sizeAttenuation = !1),
                    this.cache.add(c, h)),
                    (n = h)
                } else if (t.isLine) {
                  c = 'LineBasicMaterial:' + n.uuid
                  var u = this.cache.get(c)
                  u || ((u = new Nl()), br.prototype.copy.call(u, n), u.color.copy(n.color), this.cache.add(c, u)),
                    (n = u)
                }
                if (i || r || s || o || a) {
                  ;(c = 'ClonedMaterial:' + n.uuid + ':'),
                    n.isGLTFSpecularGlossinessMaterial && (c += 'specular-glossiness:'),
                    o && (c += 'skinning:'),
                    i && (c += 'vertex-tangents:'),
                    r && (c += 'vertex-colors:'),
                    s && (c += 'flat-shading:'),
                    a && (c += 'morph-targets:'),
                    l && (c += 'morph-normals:')
                  var d = this.cache.get(c)
                  d ||
                    ((d = n.clone()),
                    o && (d.skinning = !0),
                    r && (d.vertexColors = !0),
                    s && (d.flatShading = !0),
                    a && (d.morphTargets = !0),
                    l && (d.morphNormals = !0),
                    i &&
                      ((d.vertexTangents = !0),
                      d.normalScale && (d.normalScale.y *= -1),
                      d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)),
                    this.cache.add(c, d),
                    this.associations.set(d, this.associations.get(n))),
                    (n = d)
                }
                n.aoMap &&
                  void 0 === e.attributes.uv2 &&
                  void 0 !== e.attributes.uv &&
                  e.setAttribute('uv2', e.attributes.uv),
                  (t.material = n)
              }),
              (I.prototype.getMaterialType = function () {
                return rh
              }),
              (I.prototype.loadMaterial = function (t) {
                var e,
                  i = this,
                  r = this.json,
                  s = this.extensions,
                  o = r.materials[t],
                  a = {},
                  l = o.extensions || {},
                  c = []
                if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                  var h = s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
                  ;(e = h.getMaterialType()), c.push(h.extendParams(a, o, i))
                } else if (l[n.KHR_MATERIALS_UNLIT]) {
                  var u = s[n.KHR_MATERIALS_UNLIT]
                  ;(e = u.getMaterialType()), c.push(u.extendParams(a, o, i))
                } else {
                  var d = o.pbrMetallicRoughness || {}
                  if (((a.color = new Ar(1, 1, 1)), (a.opacity = 1), Array.isArray(d.baseColorFactor))) {
                    var p = d.baseColorFactor
                    a.color.fromArray(p), (a.opacity = p[3])
                  }
                  void 0 !== d.baseColorTexture && c.push(i.assignTexture(a, 'map', d.baseColorTexture)),
                    (a.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1),
                    (a.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1),
                    void 0 !== d.metallicRoughnessTexture &&
                      (c.push(i.assignTexture(a, 'metalnessMap', d.metallicRoughnessTexture)),
                      c.push(i.assignTexture(a, 'roughnessMap', d.metallicRoughnessTexture))),
                    (e = this._invokeOne(function (e) {
                      return e.getMaterialType && e.getMaterialType(t)
                    })),
                    c.push(
                      Promise.all(
                        this._invokeAll(function (e) {
                          return e.extendMaterialParams && e.extendMaterialParams(t, a)
                        })
                      )
                    )
                }
                !0 === o.doubleSided && (a.side = b)
                var f = o.alphaMode || 'OPAQUE'
                return (
                  'BLEND' === f
                    ? ((a.transparent = !0), (a.depthWrite = !1))
                    : ((a.transparent = !1),
                      'MASK' === f && (a.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : 0.5)),
                  void 0 !== o.normalTexture &&
                    e !== Lr &&
                    (c.push(i.assignTexture(a, 'normalMap', o.normalTexture)),
                    (a.normalScale = new Wn(1, -1)),
                    void 0 !== o.normalTexture.scale &&
                      a.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)),
                  void 0 !== o.occlusionTexture &&
                    e !== Lr &&
                    (c.push(i.assignTexture(a, 'aoMap', o.occlusionTexture)),
                    void 0 !== o.occlusionTexture.strength && (a.aoMapIntensity = o.occlusionTexture.strength)),
                  void 0 !== o.emissiveFactor && e !== Lr && (a.emissive = new Ar().fromArray(o.emissiveFactor)),
                  void 0 !== o.emissiveTexture &&
                    e !== Lr &&
                    c.push(i.assignTexture(a, 'emissiveMap', o.emissiveTexture)),
                  Promise.all(c).then(function () {
                    var r
                    return (
                      (r = e === m ? s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new e(a)),
                      o.name && (r.name = o.name),
                      r.map && (r.map.encoding = en),
                      r.emissiveMap && (r.emissiveMap.encoding = en),
                      R(r, o),
                      i.associations.set(r, { type: 'materials', index: t }),
                      o.extensions && L(s, r, o),
                      r
                    )
                  })
                )
              }),
              (I.prototype.createUniqueName = function (t) {
                for (var e = _d.sanitizeNodeName(t || ''), n = e, i = 1; this.nodeNamesUsed[n]; ++i) n = e + '_' + i
                return (this.nodeNamesUsed[n] = !0), n
              }),
              (I.prototype.loadGeometries = function (t) {
                var e = this,
                  i = this.extensions,
                  r = this.primitiveCache
                function s(t) {
                  return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) {
                    return D(n, t, e)
                  })
                }
                for (var o, a, l = [], c = 0, h = t.length; c < h; c++) {
                  var u,
                    d = t[c],
                    p =
                      (void 0,
                      (a = (o = d).extensions && o.extensions[n.KHR_DRACO_MESH_COMPRESSION])
                        ? 'draco:' + a.bufferView + ':' + a.indices + ':' + C(a.attributes)
                        : o.indices + ':' + C(o.attributes) + ':' + o.mode),
                    m = r[p]
                  m
                    ? l.push(m.promise)
                    : ((u = d.extensions && d.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? s(d) : D(new Qr(), d, e)),
                      (r[p] = { primitive: d, promise: u }),
                      l.push(u))
                }
                return Promise.all(l)
              }),
              (I.prototype.loadMesh = function (t) {
                for (
                  var e,
                    n = this,
                    i = this.json,
                    r = this.extensions,
                    s = i.meshes[t],
                    o = s.primitives,
                    a = [],
                    l = 0,
                    c = o.length;
                  l < c;
                  l++
                ) {
                  var h =
                    void 0 === o[l].material
                      ? (void 0 === (e = this.cache).DefaultMaterial &&
                          (e.DefaultMaterial = new rh({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: y
                          })),
                        e.DefaultMaterial)
                      : this.getDependency('material', o[l].material)
                  a.push(h)
                }
                return (
                  a.push(n.loadGeometries(o)),
                  Promise.all(a).then(function (e) {
                    for (
                      var i = e.slice(0, e.length - 1), a = e[e.length - 1], l = [], c = 0, h = a.length;
                      c < h;
                      c++
                    ) {
                      var u,
                        d = a[c],
                        p = o[c],
                        m = i[c]
                      if (4 === p.mode || 5 === p.mode || 6 === p.mode || void 0 === p.mode)
                        !0 !== (u = !0 === s.isSkinnedMesh ? new Sl(d, m) : new gs(d, m)).isSkinnedMesh ||
                          u.geometry.attributes.skinWeight.normalized ||
                          u.normalizeSkinWeights(),
                          5 === p.mode
                            ? (u.geometry = O(u.geometry, Qe))
                            : 6 === p.mode && (u.geometry = O(u.geometry, $e))
                      else if (1 === p.mode) u = new Wl(d, m)
                      else if (3 === p.mode) u = new Hl(d, m)
                      else if (2 === p.mode) u = new jl(d, m)
                      else {
                        if (0 !== p.mode) throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + p.mode)
                        u = new Kl(d, m)
                      }
                      Object.keys(u.geometry.morphAttributes).length > 0 && P(u, s),
                        (u.name = n.createUniqueName(s.name || 'mesh_' + t)),
                        R(u, s),
                        p.extensions && L(r, u, p),
                        n.assignFinalMaterial(u),
                        l.push(u)
                    }
                    if (1 === l.length) return l[0]
                    var f = new Va()
                    for (c = 0, h = l.length; c < h; c++) f.add(l[c])
                    return f
                  })
                )
              }),
              (I.prototype.loadCamera = function (t) {
                var e,
                  n = this.json.cameras[t],
                  i = n[n.type]
                if (i)
                  return (
                    'perspective' === n.type
                      ? (e = new Ts(Vn.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6))
                      : 'orthographic' === n.type && (e = new _u(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
                    n.name && (e.name = this.createUniqueName(n.name)),
                    R(e, n),
                    Promise.resolve(e)
                  )
                console.warn('THREE.GLTFLoader: Missing camera parameters.')
              }),
              (I.prototype.loadSkin = function (t) {
                var e = this.json.skins[t],
                  n = { joints: e.joints }
                return void 0 === e.inverseBindMatrices
                  ? Promise.resolve(n)
                  : this.getDependency('accessor', e.inverseBindMatrices).then(function (t) {
                      return (n.inverseBindMatrices = t), n
                    })
              }),
              (I.prototype.loadAnimation = function (t) {
                for (
                  var e = this.json.animations[t], n = [], i = [], r = [], s = [], o = [], a = 0, l = e.channels.length;
                  a < l;
                  a++
                ) {
                  var c = e.channels[a],
                    h = e.samplers[c.sampler],
                    u = c.target,
                    d = void 0 !== u.node ? u.node : u.id,
                    p = void 0 !== e.parameters ? e.parameters[h.input] : h.input,
                    m = void 0 !== e.parameters ? e.parameters[h.output] : h.output
                  n.push(this.getDependency('node', d)),
                    i.push(this.getDependency('accessor', p)),
                    r.push(this.getDependency('accessor', m)),
                    s.push(h),
                    o.push(u)
                }
                return Promise.all([
                  Promise.all(n),
                  Promise.all(i),
                  Promise.all(r),
                  Promise.all(s),
                  Promise.all(o)
                ]).then(function (n) {
                  for (var i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = [], c = 0, h = i.length; c < h; c++) {
                    var u = i[c],
                      d = r[c],
                      p = s[c],
                      m = o[c],
                      f = a[c]
                    if (void 0 !== u) {
                      var g
                      switch ((u.updateMatrix(), (u.matrixAutoUpdate = !0), S[f.path])) {
                        case S.weights:
                          g = wh
                          break
                        case S.rotation:
                          g = Mh
                          break
                        case S.position:
                        case S.scale:
                        default:
                          g = Sh
                      }
                      var y = u.name ? u.name : u.uuid,
                        x = void 0 !== m.interpolation ? E[m.interpolation] : We,
                        b = []
                      S[f.path] === S.weights
                        ? u.traverse(function (t) {
                            !0 === t.isMesh && t.morphTargetInfluences && b.push(t.name ? t.name : t.uuid)
                          })
                        : b.push(y)
                      var w = p.array
                      if (p.normalized) {
                        var _
                        if (w.constructor === Int8Array) _ = 1 / 127
                        else if (w.constructor === Uint8Array) _ = 1 / 255
                        else if (w.constructor == Int16Array) _ = 1 / 32767
                        else {
                          if (w.constructor !== Uint16Array)
                            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.')
                          _ = 1 / 65535
                        }
                        for (var M = new Float32Array(w.length), T = 0, A = w.length; T < A; T++) M[T] = w[T] * _
                        w = M
                      }
                      for (T = 0, A = b.length; T < A; T++) {
                        var L = new g(b[T] + '.' + S[f.path], d.array, w, x)
                        'CUBICSPLINE' === m.interpolation &&
                          ((L.createInterpolant = function (t) {
                            return new v(this.times, this.values, this.getValueSize() / 3, t)
                          }),
                          (L.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                          l.push(L)
                      }
                    }
                  }
                  var R = e.name ? e.name : 'animation_' + t
                  return new Eh(R, void 0, l)
                })
              }),
              (I.prototype.loadNode = function (t) {
                var e,
                  n = this.json,
                  i = this.extensions,
                  r = this,
                  s = n.nodes[t],
                  o = s.name ? r.createUniqueName(s.name) : ''
                return ((e = []),
                void 0 !== s.mesh &&
                  e.push(
                    r.getDependency('mesh', s.mesh).then(function (t) {
                      var e = r._getNodeRef(r.meshCache, s.mesh, t)
                      return (
                        void 0 !== s.weights &&
                          e.traverse(function (t) {
                            if (t.isMesh)
                              for (var e = 0, n = s.weights.length; e < n; e++)
                                t.morphTargetInfluences[e] = s.weights[e]
                          }),
                        e
                      )
                    })
                  ),
                void 0 !== s.camera &&
                  e.push(
                    r.getDependency('camera', s.camera).then(function (t) {
                      return r._getNodeRef(r.cameraCache, s.camera, t)
                    })
                  ),
                r
                  ._invokeAll(function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t)
                  })
                  .forEach(function (t) {
                    e.push(t)
                  }),
                Promise.all(e)).then(function (e) {
                  var n
                  if (
                    (n = !0 === s.isBone ? new El() : e.length > 1 ? new Va() : 1 === e.length ? e[0] : new ir()) !==
                    e[0]
                  )
                    for (var a = 0, l = e.length; a < l; a++) n.add(e[a])
                  if (
                    (s.name && ((n.userData.name = s.name), (n.name = o)),
                    R(n, s),
                    s.extensions && L(i, n, s),
                    void 0 !== s.matrix)
                  ) {
                    var c = new Ii()
                    c.fromArray(s.matrix), n.applyMatrix4(c)
                  } else void 0 !== s.translation && n.position.fromArray(s.translation), void 0 !== s.rotation && n.quaternion.fromArray(s.rotation), void 0 !== s.scale && n.scale.fromArray(s.scale)
                  return r.associations.set(n, { type: 'nodes', index: t }), n
                })
              }),
              (I.prototype.loadScene = (function () {
                function t(e, n, i, r) {
                  var s = i.nodes[e]
                  return r
                    .getDependency('node', e)
                    .then(function (t) {
                      return void 0 === s.skin
                        ? t
                        : r
                            .getDependency('skin', s.skin)
                            .then(function (t) {
                              for (var n = [], i = 0, s = (e = t).joints.length; i < s; i++)
                                n.push(r.getDependency('node', e.joints[i]))
                              return Promise.all(n)
                            })
                            .then(function (n) {
                              return (
                                t.traverse(function (t) {
                                  if (t.isMesh) {
                                    for (var i = [], r = [], s = 0, o = n.length; s < o; s++) {
                                      var a = n[s]
                                      if (a) {
                                        i.push(a)
                                        var l = new Ii()
                                        void 0 !== e.inverseBindMatrices &&
                                          l.fromArray(e.inverseBindMatrices.array, 16 * s),
                                          r.push(l)
                                      } else
                                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[s])
                                    }
                                    t.bind(new Rl(i, r), t.matrixWorld)
                                  }
                                }),
                                t
                              )
                            })
                      var e
                    })
                    .then(function (e) {
                      n.add(e)
                      var o = []
                      if (s.children)
                        for (var a = s.children, l = 0, c = a.length; l < c; l++) {
                          var h = a[l]
                          o.push(t(h, e, i, r))
                        }
                      return Promise.all(o)
                    })
                }
                return function (e) {
                  var n = this.json,
                    i = this.extensions,
                    r = this.json.scenes[e],
                    s = new Va()
                  r.name && (s.name = this.createUniqueName(r.name)), R(s, r), r.extensions && L(i, s, r)
                  for (var o = r.nodes || [], a = [], l = 0, c = o.length; l < c; l++) a.push(t(o[l], s, n, this))
                  return Promise.all(a).then(function () {
                    return s
                  })
                }
              })()),
              t
            )
          })(),
          Xv = function (t) {
            Ch.call(this, t), (this.defaultDPI = 90), (this.defaultUnit = 'px')
          }
        ;(Xv.prototype = Object.assign(Object.create(Ch.prototype), {
          constructor: Xv,
          load: function (t, e, n, i) {
            var r = this,
              s = new Dh(r.manager)
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(n))
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t)
                  }
                },
                n,
                i
              )
          },
          parse: function (t) {
            var e = this
            function n(t, e, n, r, s, o, a, l) {
              if (0 != e && 0 != n) {
                ;(r = (r * Math.PI) / 180), (e = Math.abs(e)), (n = Math.abs(n))
                var c = (a.x - l.x) / 2,
                  h = (a.y - l.y) / 2,
                  u = Math.cos(r) * c + Math.sin(r) * h,
                  d = -Math.sin(r) * c + Math.cos(r) * h,
                  p = e * e,
                  m = n * n,
                  f = u * u,
                  g = d * d,
                  v = f / p + g / m
                if (v > 1) {
                  var y = Math.sqrt(v)
                  ;(p = (e *= y) * e), (m = (n *= y) * n)
                }
                var x = p * g + m * f,
                  b = (p * m - x) / x,
                  w = Math.sqrt(Math.max(0, b))
                s === o && (w = -w)
                var _ = (w * e * d) / n,
                  M = (-w * n * u) / e,
                  T = Math.cos(r) * _ - Math.sin(r) * M + (a.x + l.x) / 2,
                  S = Math.sin(r) * _ + Math.cos(r) * M + (a.y + l.y) / 2,
                  E = i(1, 0, (u - _) / e, (d - M) / n),
                  A = i((u - _) / e, (d - M) / n, (-u - _) / e, (-d - M) / n) % (2 * Math.PI)
                t.currentPath.absellipse(T, S, e, n, E, E + A, 0 === o, r)
              } else t.lineTo(l.x, l.y)
            }
            function i(t, e, n, i) {
              var r = t * n + e * i,
                s = Math.sqrt(t * t + e * e) * Math.sqrt(n * n + i * i),
                o = Math.acos(Math.max(-1, Math.min(1, r / s)))
              return t * i - e * n < 0 && (o = -o), o
            }
            function r(t, e) {
              e = Object.assign({}, e)
              var n = {}
              if (t.hasAttribute('class'))
                for (
                  var i = t
                      .getAttribute('class')
                      .split(/\s/)
                      .filter(Boolean)
                      .map(t => t.trim()),
                    r = 0;
                  r < i.length;
                  r++
                )
                  n = Object.assign(n, p['.' + i[r]])
              function s(i, r, s) {
                void 0 === s &&
                  (s = function (t) {
                    return (
                      t.startsWith('url') && console.warn('SVGLoader: url access in attributes is not implemented.'), t
                    )
                  }),
                  t.hasAttribute(i) && (e[r] = s(t.getAttribute(i))),
                  n[i] && (e[r] = s(n[i])),
                  t.style && '' !== t.style[i] && (e[r] = s(t.style[i]))
              }
              function o(t) {
                return Math.max(0, Math.min(1, c(t)))
              }
              function a(t) {
                return Math.max(0, c(t))
              }
              return (
                t.hasAttribute('id') && (n = Object.assign(n, p['#' + t.getAttribute('id')])),
                s('fill', 'fill'),
                s('fill-opacity', 'fillOpacity', o),
                s('opacity', 'opacity', o),
                s('stroke', 'stroke'),
                s('stroke-opacity', 'strokeOpacity', o),
                s('stroke-width', 'strokeWidth', a),
                s('stroke-linejoin', 'strokeLineJoin'),
                s('stroke-linecap', 'strokeLineCap'),
                s('stroke-miterlimit', 'strokeMiterLimit', a),
                s('visibility', 'visibility'),
                e
              )
            }
            function s(t, e) {
              return t - (e - t)
            }
            function o(t, e, n) {
              if ('string' != typeof t) throw new TypeError('Invalid input: ' + typeof t)
              var i = {
                  SEPARATOR: /[ \t\r\n\,.\-+]/,
                  WHITESPACE: /[ \t\r\n]/,
                  DIGIT: /[\d]/,
                  SIGN: /[-+]/,
                  POINT: /\./,
                  COMMA: /,/,
                  EXP: /e/i,
                  FLAGS: /[01]/
                },
                r = 0,
                s = !0,
                o = [],
                a = '',
                l = ''
              function c(t, e, n) {
                var i = new SyntaxError('Unexpected character "' + t + '" at index ' + e + '.')
                throw ((i.partial = n), i)
              }
              function h() {
                '' !== a && ('' === l ? o.push(Number(a)) : o.push(Number(a) * Math.pow(10, Number(l)))),
                  (a = ''),
                  (l = '')
              }
              var u,
                d = 0,
                p = t.length
              for (d = 0; d < p; d++)
                if (((u = t[d]), Array.isArray(e) && e.includes(o.length % n) && i.FLAGS.test(u))) (r = 1), (a = u), h()
                else {
                  if (0 === r) {
                    if (i.WHITESPACE.test(u)) continue
                    if (i.DIGIT.test(u) || i.SIGN.test(u)) {
                      ;(r = 1), (a = u)
                      continue
                    }
                    if (i.POINT.test(u)) {
                      ;(r = 2), (a = u)
                      continue
                    }
                    i.COMMA.test(u) && (s && c(u, d, o), (s = !0))
                  }
                  if (1 === r) {
                    if (i.DIGIT.test(u)) {
                      a += u
                      continue
                    }
                    if (i.POINT.test(u)) {
                      ;(a += u), (r = 2)
                      continue
                    }
                    if (i.EXP.test(u)) {
                      r = 3
                      continue
                    }
                    i.SIGN.test(u) && 1 === a.length && i.SIGN.test(a[0]) && c(u, d, o)
                  }
                  if (2 === r) {
                    if (i.DIGIT.test(u)) {
                      a += u
                      continue
                    }
                    if (i.EXP.test(u)) {
                      r = 3
                      continue
                    }
                    i.POINT.test(u) && '.' === a[a.length - 1] && c(u, d, o)
                  }
                  if (3 === r) {
                    if (i.DIGIT.test(u)) {
                      l += u
                      continue
                    }
                    if (i.SIGN.test(u)) {
                      if ('' === l) {
                        l += u
                        continue
                      }
                      1 === l.length && i.SIGN.test(l) && c(u, d, o)
                    }
                  }
                  i.WHITESPACE.test(u)
                    ? (h(), (r = 0), (s = !1))
                    : i.COMMA.test(u)
                    ? (h(), (r = 0), (s = !0))
                    : i.SIGN.test(u)
                    ? (h(), (r = 1), (a = u))
                    : i.POINT.test(u)
                    ? (h(), (r = 2), (a = u))
                    : c(u, d, o)
                }
              return h(), o
            }
            var a = ['mm', 'cm', 'in', 'pt', 'pc', 'px'],
              l = {
                mm: { mm: 1, cm: 0.1, in: 1 / 25.4, pt: 72 / 25.4, pc: 6 / 25.4, px: -1 },
                cm: { mm: 10, cm: 1, in: 1 / 2.54, pt: 72 / 2.54, pc: 6 / 2.54, px: -1 },
                in: { mm: 25.4, cm: 2.54, in: 1, pt: 72, pc: 6, px: -1 },
                pt: { mm: 25.4 / 72, cm: 2.54 / 72, in: 1 / 72, pt: 1, pc: 6 / 72, px: -1 },
                pc: { mm: 25.4 / 6, cm: 2.54 / 6, in: 1 / 6, pt: 12, pc: 1, px: -1 },
                px: { px: 1 }
              }
            function c(t) {
              var n = 'px'
              if ('string' == typeof t || t instanceof String)
                for (var i = 0, r = a.length; i < r; i++) {
                  var s = a[i]
                  if (t.endsWith(s)) {
                    ;(n = s), (t = t.substring(0, t.length - s.length))
                    break
                  }
                }
              var o = void 0
              return (
                'px' === n && 'px' !== e.defaultUnit
                  ? (o = l.in[e.defaultUnit] / e.defaultDPI)
                  : (o = l[n][e.defaultUnit]) < 0 && (o = l[n].in * e.defaultDPI),
                o * parseFloat(t)
              )
            }
            function h(t) {
              var e = t.elements
              return Math.sqrt(e[0] * e[0] + e[1] * e[1])
            }
            function u(t) {
              var e = t.elements
              return Math.sqrt(e[3] * e[3] + e[4] * e[4])
            }
            var d = [],
              p = {},
              m = [],
              f = new jn(),
              g = new jn(),
              v = new jn(),
              y = new jn(),
              x = new Wn(),
              b = new ei(),
              w = new jn(),
              _ = new DOMParser().parseFromString(t, 'image/svg+xml')
            return (
              (function t(e, i) {
                if (1 === e.nodeType) {
                  var a = (function (t) {
                      if (
                        !(
                          t.hasAttribute('transform') ||
                          ('use' === t.nodeName && (t.hasAttribute('x') || t.hasAttribute('y')))
                        )
                      )
                        return null
                      var e = (function (t) {
                        var e = new jn(),
                          n = f
                        if ('use' === t.nodeName && (t.hasAttribute('x') || t.hasAttribute('y'))) {
                          var i = c(t.getAttribute('x')),
                            r = c(t.getAttribute('y'))
                          e.translate(i, r)
                        }
                        if (t.hasAttribute('transform'))
                          for (var s = t.getAttribute('transform').split(')'), a = s.length - 1; a >= 0; a--) {
                            var l = s[a].trim()
                            if ('' !== l) {
                              var h = l.indexOf('('),
                                u = l.length
                              if (h > 0 && h < u) {
                                var d = l.substr(0, h),
                                  p = o(l.substr(h + 1, u - h - 1))
                                switch ((n.identity(), d)) {
                                  case 'translate':
                                    p.length >= 1 && ((r = i = p[0]), p.length >= 2 && (r = p[1]), n.translate(i, r))
                                    break
                                  case 'rotate':
                                    if (p.length >= 1) {
                                      var m,
                                        x = 0,
                                        b = 0
                                      ;(m = (-p[0] * Math.PI) / 180),
                                        p.length >= 3 && ((x = p[1]), (b = p[2])),
                                        g.identity().translate(-x, -b),
                                        v.identity().rotate(m),
                                        y.multiplyMatrices(v, g),
                                        g.identity().translate(x, b),
                                        n.multiplyMatrices(g, y)
                                    }
                                    break
                                  case 'scale':
                                    if (p.length >= 1) {
                                      var w = p[0],
                                        _ = w
                                      p.length >= 2 && (_ = p[1]), n.scale(w, _)
                                    }
                                    break
                                  case 'skewX':
                                    1 === p.length && n.set(1, Math.tan((p[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)
                                    break
                                  case 'skewY':
                                    1 === p.length && n.set(1, 0, 0, Math.tan((p[0] * Math.PI) / 180), 1, 0, 0, 0, 1)
                                    break
                                  case 'matrix':
                                    6 === p.length && n.set(p[0], p[2], p[4], p[1], p[3], p[5], 0, 0, 1)
                                }
                              }
                              e.premultiply(n)
                            }
                          }
                        return e
                      })(t)
                      return m.length > 0 && e.premultiply(m[m.length - 1]), w.copy(e), m.push(e), e
                    })(e),
                    l = !0,
                    _ = null
                  switch (e.nodeName) {
                    case 'svg':
                      break
                    case 'style':
                      !(function (t) {
                        if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length)
                          for (var e = 0; e < t.sheet.cssRules.length; e++) {
                            var n = t.sheet.cssRules[e]
                            if (1 === n.type)
                              for (
                                var i = n.selectorText
                                    .split(/,/gm)
                                    .filter(Boolean)
                                    .map(t => t.trim()),
                                  r = 0;
                                r < i.length;
                                r++
                              )
                                p[i[r]] = Object.assign(p[i[r]] || {}, n.style)
                          }
                      })(e)
                      break
                    case 'g':
                      i = r(e, i)
                      break
                    case 'path':
                      ;(i = r(e, i)),
                        e.hasAttribute('d') &&
                          (_ = (function (t) {
                            for (
                              var e = new ku(),
                                i = new Wn(),
                                r = new Wn(),
                                a = new Wn(),
                                l = !0,
                                c = !1,
                                h = t.getAttribute('d').match(/[a-df-z][^a-df-z]*/gi),
                                u = 0,
                                d = h.length;
                              u < d;
                              u++
                            ) {
                              var p = h[u],
                                m = p.charAt(0),
                                f = p.substr(1).trim()
                              switch ((!0 === l && ((c = !0), (l = !1)), m)) {
                                case 'M':
                                  for (var g = 0, v = (w = o(f)).length; g < v; g += 2)
                                    (i.x = w[g + 0]),
                                      (i.y = w[g + 1]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      0 === g ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'H':
                                  for (g = 0, v = (w = o(f)).length; g < v; g++)
                                    (i.x = w[g]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'V':
                                  for (g = 0, v = (w = o(f)).length; g < v; g++)
                                    (i.y = w[g]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'L':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 2)
                                    (i.x = w[g + 0]),
                                      (i.y = w[g + 1]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'C':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 6)
                                    e.bezierCurveTo(w[g + 0], w[g + 1], w[g + 2], w[g + 3], w[g + 4], w[g + 5]),
                                      (r.x = w[g + 2]),
                                      (r.y = w[g + 3]),
                                      (i.x = w[g + 4]),
                                      (i.y = w[g + 5]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'S':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 4)
                                    e.bezierCurveTo(s(i.x, r.x), s(i.y, r.y), w[g + 0], w[g + 1], w[g + 2], w[g + 3]),
                                      (r.x = w[g + 0]),
                                      (r.y = w[g + 1]),
                                      (i.x = w[g + 2]),
                                      (i.y = w[g + 3]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'Q':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 4)
                                    e.quadraticCurveTo(w[g + 0], w[g + 1], w[g + 2], w[g + 3]),
                                      (r.x = w[g + 0]),
                                      (r.y = w[g + 1]),
                                      (i.x = w[g + 2]),
                                      (i.y = w[g + 3]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'T':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 2) {
                                    var y = s(i.x, r.x),
                                      x = s(i.y, r.y)
                                    e.quadraticCurveTo(y, x, w[g + 0], w[g + 1]),
                                      (r.x = y),
                                      (r.y = x),
                                      (i.x = w[g + 0]),
                                      (i.y = w[g + 1]),
                                      0 === g && !0 === c && a.copy(i)
                                  }
                                  break
                                case 'A':
                                  for (g = 0, v = (w = o(f, [3, 4], 7)).length; g < v; g += 7)
                                    if (w[g + 5] != i.x || w[g + 6] != i.y) {
                                      var b = i.clone()
                                      ;(i.x = w[g + 5]),
                                        (i.y = w[g + 6]),
                                        (r.x = i.x),
                                        (r.y = i.y),
                                        n(e, w[g], w[g + 1], w[g + 2], w[g + 3], w[g + 4], b, i),
                                        0 === g && !0 === c && a.copy(i)
                                    }
                                  break
                                case 'm':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 2)
                                    (i.x += w[g + 0]),
                                      (i.y += w[g + 1]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      0 === g ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'h':
                                  for (g = 0, v = (w = o(f)).length; g < v; g++)
                                    (i.x += w[g]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'v':
                                  for (g = 0, v = (w = o(f)).length; g < v; g++)
                                    (i.y += w[g]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'l':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 2)
                                    (i.x += w[g + 0]),
                                      (i.y += w[g + 1]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      e.lineTo(i.x, i.y),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'c':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 6)
                                    e.bezierCurveTo(
                                      i.x + w[g + 0],
                                      i.y + w[g + 1],
                                      i.x + w[g + 2],
                                      i.y + w[g + 3],
                                      i.x + w[g + 4],
                                      i.y + w[g + 5]
                                    ),
                                      (r.x = i.x + w[g + 2]),
                                      (r.y = i.y + w[g + 3]),
                                      (i.x += w[g + 4]),
                                      (i.y += w[g + 5]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 's':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 4)
                                    e.bezierCurveTo(
                                      s(i.x, r.x),
                                      s(i.y, r.y),
                                      i.x + w[g + 0],
                                      i.y + w[g + 1],
                                      i.x + w[g + 2],
                                      i.y + w[g + 3]
                                    ),
                                      (r.x = i.x + w[g + 0]),
                                      (r.y = i.y + w[g + 1]),
                                      (i.x += w[g + 2]),
                                      (i.y += w[g + 3]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'q':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 4)
                                    e.quadraticCurveTo(i.x + w[g + 0], i.y + w[g + 1], i.x + w[g + 2], i.y + w[g + 3]),
                                      (r.x = i.x + w[g + 0]),
                                      (r.y = i.y + w[g + 1]),
                                      (i.x += w[g + 2]),
                                      (i.y += w[g + 3]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 't':
                                  for (g = 0, v = (w = o(f)).length; g < v; g += 2)
                                    (y = s(i.x, r.x)),
                                      (x = s(i.y, r.y)),
                                      e.quadraticCurveTo(y, x, i.x + w[g + 0], i.y + w[g + 1]),
                                      (r.x = y),
                                      (r.y = x),
                                      (i.x = i.x + w[g + 0]),
                                      (i.y = i.y + w[g + 1]),
                                      0 === g && !0 === c && a.copy(i)
                                  break
                                case 'a':
                                  var w
                                  for (g = 0, v = (w = o(f, [3, 4], 7)).length; g < v; g += 7)
                                    (0 == w[g + 5] && 0 == w[g + 6]) ||
                                      ((b = i.clone()),
                                      (i.x += w[g + 5]),
                                      (i.y += w[g + 6]),
                                      (r.x = i.x),
                                      (r.y = i.y),
                                      n(e, w[g], w[g + 1], w[g + 2], w[g + 3], w[g + 4], b, i),
                                      0 === g && !0 === c && a.copy(i))
                                  break
                                case 'Z':
                                case 'z':
                                  ;(e.currentPath.autoClose = !0),
                                    e.currentPath.curves.length > 0 &&
                                      (i.copy(a), e.currentPath.currentPoint.copy(i), (l = !0))
                                  break
                                default:
                                  console.warn(p)
                              }
                              c = !1
                            }
                            return e
                          })(e))
                      break
                    case 'rect':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = c(t.getAttribute('x') || 0),
                            n = c(t.getAttribute('y') || 0),
                            i = c(t.getAttribute('rx') || 0),
                            r = c(t.getAttribute('ry') || 0),
                            s = c(t.getAttribute('width')),
                            o = c(t.getAttribute('height')),
                            a = new ku()
                          return (
                            a.moveTo(e + 2 * i, n),
                            a.lineTo(e + s - 2 * i, n),
                            (0 !== i || 0 !== r) && a.bezierCurveTo(e + s, n, e + s, n, e + s, n + 2 * r),
                            a.lineTo(e + s, n + o - 2 * r),
                            (0 !== i || 0 !== r) && a.bezierCurveTo(e + s, n + o, e + s, n + o, e + s - 2 * i, n + o),
                            a.lineTo(e + 2 * i, n + o),
                            (0 !== i || 0 !== r) && a.bezierCurveTo(e, n + o, e, n + o, e, n + o - 2 * r),
                            a.lineTo(e, n + 2 * r),
                            (0 !== i || 0 !== r) && a.bezierCurveTo(e, n, e, n, e + 2 * i, n),
                            a
                          )
                        })(e))
                      break
                    case 'polygon':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = new ku(),
                            n = 0
                          return (
                            t.getAttribute('points').replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, function (t, i, r) {
                              var s = c(i),
                                o = c(r)
                              0 === n ? e.moveTo(s, o) : e.lineTo(s, o), n++
                            }),
                            (e.currentPath.autoClose = !0),
                            e
                          )
                        })(e))
                      break
                    case 'polyline':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = new ku(),
                            n = 0
                          return (
                            t.getAttribute('points').replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, function (t, i, r) {
                              var s = c(i),
                                o = c(r)
                              0 === n ? e.moveTo(s, o) : e.lineTo(s, o), n++
                            }),
                            (e.currentPath.autoClose = !1),
                            e
                          )
                        })(e))
                      break
                    case 'circle':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = c(t.getAttribute('cx') || 0),
                            n = c(t.getAttribute('cy') || 0),
                            i = c(t.getAttribute('r') || 0),
                            r = new au()
                          r.absarc(e, n, i, 0, 2 * Math.PI)
                          var s = new ku()
                          return s.subPaths.push(r), s
                        })(e))
                      break
                    case 'ellipse':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = c(t.getAttribute('cx') || 0),
                            n = c(t.getAttribute('cy') || 0),
                            i = c(t.getAttribute('rx') || 0),
                            r = c(t.getAttribute('ry') || 0),
                            s = new au()
                          s.absellipse(e, n, i, r, 0, 2 * Math.PI)
                          var o = new ku()
                          return o.subPaths.push(s), o
                        })(e))
                      break
                    case 'line':
                      ;(i = r(e, i)),
                        (_ = (function (t) {
                          var e = c(t.getAttribute('x1') || 0),
                            n = c(t.getAttribute('y1') || 0),
                            i = c(t.getAttribute('x2') || 0),
                            r = c(t.getAttribute('y2') || 0),
                            s = new ku()
                          return s.moveTo(e, n), s.lineTo(i, r), (s.currentPath.autoClose = !1), s
                        })(e))
                      break
                    case 'defs':
                      l = !1
                      break
                    case 'use':
                      i = r(e, i)
                      var M = e.href.baseVal.substring(1),
                        T = e.viewportElement.getElementById(M)
                      T ? t(T, i) : console.warn("SVGLoader: 'use node' references non-existent node id: " + M)
                  }
                  if (
                    (_ &&
                      (void 0 !== i.fill && 'none' !== i.fill && _.color.setStyle(i.fill),
                      (function (t, e) {
                        function n(t) {
                          b.set(t.x, t.y, 1).applyMatrix3(e), t.set(b.x, b.y)
                        }
                        for (
                          var i = (function (t) {
                              return 0 !== t.elements[1] || 0 !== t.elements[3]
                            })(e),
                            r = t.subPaths,
                            s = 0,
                            o = r.length;
                          s < o;
                          s++
                        )
                          for (var a = r[s].curves, l = 0; l < a.length; l++) {
                            var c = a[l]
                            c.isLineCurve
                              ? (n(c.v1), n(c.v2))
                              : c.isCubicBezierCurve
                              ? (n(c.v0), n(c.v1), n(c.v2), n(c.v3))
                              : c.isQuadraticBezierCurve
                              ? (n(c.v0), n(c.v1), n(c.v2))
                              : c.isEllipseCurve &&
                                (i &&
                                  console.warn(
                                    'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.'
                                  ),
                                x.set(c.aX, c.aY),
                                n(x),
                                (c.aX = x.x),
                                (c.aY = x.y),
                                (c.xRadius *= h(e)),
                                (c.yRadius *= u(e)))
                          }
                      })(_, w),
                      d.push(_),
                      (_.userData = { node: e, style: i })),
                    l)
                  )
                    for (var S = e.childNodes, E = 0; E < S.length; E++) t(S[E], i)
                  a && (m.pop(), m.length > 0 ? w.copy(m[m.length - 1]) : w.identity())
                }
              })(_.documentElement, {
                fill: '#000',
                fillOpacity: 1,
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLineJoin: 'miter',
                strokeLineCap: 'butt',
                strokeMiterLimit: 4
              }),
              { paths: d, xml: _.documentElement }
            )
          }
        })),
          (Xv.createShapes = function (t) {
            const e = 999999999,
              n = { loc: 0, t: 0 }
            function i(t, e, i, s) {
              var o = t.x,
                a = e.x,
                l = i.x,
                c = s.x,
                h = t.y,
                u = e.y,
                d = i.y,
                p = s.y,
                m = (c - l) * (h - d) - (p - d) * (o - l),
                f = (p - d) * (a - o) - (c - l) * (u - h),
                g = m / f,
                v = ((a - o) * (h - d) - (u - h) * (o - l)) / f
              if ((0 === f && 0 !== m) || g <= 0 || g >= 1 || v < 0 || v > 1) return null
              if (0 === m && 0 === f) {
                for (var y = 0; y < 2; y++) {
                  if ((r(0 === y ? i : s, t, e), 0 == n.loc)) return { x: (x = 0 === y ? i : s).x, y: x.y, t: n.t }
                  if (2 == n.loc)
                    return { x: +(o + n.t * (a - o)).toPrecision(10), y: +(h + n.t * (u - h)).toPrecision(10), t: n.t }
                }
                return null
              }
              for (y = 0; y < 2; y++) {
                var x
                if ((r(0 === y ? i : s, t, e), 0 == n.loc)) return { x: (x = 0 === y ? i : s).x, y: x.y, t: n.t }
              }
              return { x: +(o + g * (a - o)).toPrecision(10), y: +(h + g * (u - h)).toPrecision(10), t: g }
            }
            function r(t, e, i) {
              var r,
                s = i.x - e.x,
                o = i.y - e.y,
                a = t.x - e.x,
                l = t.y - e.y,
                c = s * l - a * o
              return t.x === e.x && t.y === e.y
                ? ((n.loc = 0), void (n.t = 0))
                : t.x === i.x && t.y === i.y
                ? ((n.loc = 1), void (n.t = 1))
                : void (c < -Number.EPSILON
                    ? (n.loc = 3)
                    : c > Number.EPSILON
                    ? (n.loc = 4)
                    : s * a < 0 || o * l < 0
                    ? (n.loc = 5)
                    : Math.sqrt(s * s + o * o) < Math.sqrt(a * a + l * l)
                    ? (n.loc = 6)
                    : ((r = 0 !== s ? a / s : l / o), (n.loc = 2), (n.t = r)))
            }
            let s = 0,
              o = e,
              a = -999999999,
              l = t.subPaths.map(t => {
                const n = t.getPoints()
                let i = -999999999,
                  r = e,
                  l = -999999999,
                  c = e
                for (let t = 0; t < n.length; t++) {
                  const e = n[t]
                  e.y > i && (i = e.y), e.y < r && (r = e.y), e.x > l && (l = e.x), e.x < c && (c = e.x)
                }
                return (
                  a <= l && (a = l + 1),
                  o >= c && (o = c - 1),
                  {
                    points: n,
                    isCW: Fc.isClockWise(n),
                    identifier: s++,
                    boundingBox: new Nd(new Wn(c, r), new Wn(l, i))
                  }
                )
              })
            l = l.filter(t => t.points.length > 0)
            const c = l.map(e =>
                (function (t, e, n, r, s) {
                  ;(null != s && '' !== s) || (s = 'nonzero')
                  const o = new Wn()
                  t.boundingBox.getCenter(o)
                  const a = (function (t, e, n) {
                    const r = new Wn()
                    e.getCenter(r)
                    const s = []
                    return (
                      n.forEach(e => {
                        e.boundingBox.containsPoint(r) &&
                          (function (t, e) {
                            const n = [],
                              r = []
                            for (let s = 1; s < t.length; s++) {
                              const o = t[s - 1],
                                a = t[s]
                              for (let t = 1; t < e.length; t++) {
                                const s = i(o, a, e[t - 1], e[t])
                                null !== s &&
                                  void 0 === n.find(t => t.t <= s.t + Number.EPSILON && t.t >= s.t - Number.EPSILON) &&
                                  (n.push(s), r.push(new Wn(s.x, s.y)))
                              }
                            }
                            return r
                          })(t, e.points).forEach(t => {
                            s.push({ identifier: e.identifier, isCW: e.isCW, point: t })
                          })
                      }),
                      s.sort((t, e) => t.point.x - e.point.x),
                      s
                    )
                  })([new Wn(n, o.y), new Wn(r, o.y)], t.boundingBox, e)
                  a.sort((t, e) => t.point.x - e.point.x)
                  const l = [],
                    c = []
                  a.forEach(e => {
                    e.identifier === t.identifier ? l.push(e) : c.push(e)
                  })
                  const h = l[0].point.x,
                    u = []
                  let d = 0
                  for (; d < c.length && c[d].point.x < h; )
                    u.length > 0 && u[u.length - 1] === c[d].identifier ? u.pop() : u.push(c[d].identifier), d++
                  if ((u.push(t.identifier), 'evenodd' === s)) {
                    const e = u.length % 2 == 0,
                      n = u[u.length - 2]
                    return { identifier: t.identifier, isHole: e, for: n }
                  }
                  if ('nonzero' === s) {
                    let n = !0,
                      i = null,
                      r = null
                    for (let t = 0; t < u.length; t++) {
                      const s = u[t]
                      n ? ((r = e[s].isCW), (n = !1), (i = s)) : r !== e[s].isCW && ((r = e[s].isCW), (n = !0))
                    }
                    return { identifier: t.identifier, isHole: n, for: i }
                  }
                  console.warn('fill-rule: "' + s + '" is currently not implemented.')
                })(e, l, o, a, t.userData.style.fillRule)
              ),
              h = []
            return (
              l.forEach(t => {
                if (!c[t.identifier].isHole) {
                  const e = new lu(t.points)
                  c
                    .filter(e => e.isHole && e.for === t.identifier)
                    .forEach(t => {
                      const n = l[t.identifier]
                      e.holes.push(new au(n.points))
                    }),
                    h.push(e)
                }
              }),
              h
            )
          }),
          (Xv.getStrokeStyle = function (t, e, n, i, r) {
            return {
              strokeColor: (e = void 0 !== e ? e : '#000'),
              strokeWidth: (t = void 0 !== t ? t : 1),
              strokeLineJoin: (n = void 0 !== n ? n : 'miter'),
              strokeLineCap: (i = void 0 !== i ? i : 'butt'),
              strokeMiterLimit: (r = void 0 !== r ? r : 4)
            }
          }),
          (Xv.pointsToStroke = function (t, e, n, i) {
            var r = [],
              s = [],
              o = []
            if (0 === Xv.pointsToStrokeWithBuffers(t, e, n, i, r, s, o)) return null
            var a = new Qr()
            return (
              a.setAttribute('position', new Ur(r, 3)),
              a.setAttribute('normal', new Ur(s, 3)),
              a.setAttribute('uv', new Ur(o, 2)),
              a
            )
          }),
          (Xv.pointsToStrokeWithBuffers =
            ((Lv = new Wn()),
            (Rv = new Wn()),
            (Pv = new Wn()),
            (Cv = new Wn()),
            (Iv = new Wn()),
            (Dv = new Wn()),
            (Ov = new Wn()),
            (Nv = new Wn()),
            (Bv = new Wn()),
            (Fv = new Wn()),
            (zv = new Wn()),
            (kv = new Wn()),
            (Uv = new Wn()),
            (Hv = new Wn()),
            (Gv = new Wn()),
            (Vv = new Wn()),
            (Wv = new Wn()),
            function (t, e, n, i, r, s, o, a) {
              ;(n = void 0 !== n ? n : 12), (i = void 0 !== i ? i : 0.001), (a = void 0 !== a ? a : 0)
              var l = (t = (function (t) {
                for (var e = !1, n = 1, r = t.length - 1; n < r; n++)
                  if (t[n].distanceTo(t[n + 1]) < i) {
                    e = !0
                    break
                  }
                if (!e) return t
                var s = []
                for (s.push(t[0]), n = 1, r = t.length - 1; n < r; n++) t[n].distanceTo(t[n + 1]) >= i && s.push(t[n])
                return s.push(t[t.length - 1]), s
              })(t)).length
              if (l < 2) return 0
              var c,
                h,
                u,
                d,
                p,
                m = t[0].equals(t[l - 1]),
                f = t[0],
                g = e.strokeWidth / 2,
                v = 1 / (l - 1),
                y = 0,
                x = !1,
                b = 0,
                w = 3 * a,
                _ = 2 * a
              O(t[0], t[1], Lv).multiplyScalar(g),
                Nv.copy(t[0]).sub(Lv),
                Bv.copy(t[0]).add(Lv),
                Fv.copy(Nv),
                zv.copy(Bv)
              for (var M = 1; M < l; M++) {
                ;(c = t[M]), (h = M === l - 1 ? (m ? t[1] : void 0) : t[M + 1])
                var T = Lv
                O(f, c, T), Pv.copy(T).multiplyScalar(g), kv.copy(c).sub(Pv), Uv.copy(c).add(Pv)
                var S = y + v
                if (((u = !1), void 0 !== h)) {
                  O(c, h, Rv),
                    Pv.copy(Rv).multiplyScalar(g),
                    Hv.copy(c).sub(Pv),
                    Gv.copy(c).add(Pv),
                    (d = !0),
                    Pv.subVectors(h, f),
                    T.dot(Pv) < 0 && (d = !1),
                    1 === M && (x = d),
                    Pv.subVectors(h, c),
                    Pv.normalize()
                  var E = Math.abs(T.dot(Pv))
                  if (0 !== E) {
                    var A = g / E
                    Pv.multiplyScalar(-A), Cv.subVectors(c, f), Iv.copy(Cv).setLength(A).add(Pv), Vv.copy(Iv).negate()
                    var L = Iv.length(),
                      R = Cv.length()
                    Cv.divideScalar(R), Dv.subVectors(h, c)
                    var P = Dv.length()
                    switch (
                      (Dv.divideScalar(P),
                      Cv.dot(Vv) < R && Dv.dot(Vv) < P && (u = !0),
                      Wv.copy(Iv).add(c),
                      Vv.add(c),
                      (p = !1),
                      u ? (d ? (Gv.copy(Vv), Uv.copy(Vv)) : (Hv.copy(Vv), kv.copy(Vv))) : F(),
                      e.strokeLineJoin)
                    ) {
                      case 'bevel':
                        z(d, u, S)
                        break
                      case 'round':
                        k(d, u), d ? B(c, kv, Hv, S, 0) : B(c, Gv, Uv, S, 1)
                        break
                      case 'miter':
                      case 'miter-clip':
                      default:
                        var C = (g * e.strokeMiterLimit) / L
                        if (C < 1) {
                          if ('miter-clip' !== e.strokeLineJoin) {
                            z(d, u, S)
                            break
                          }
                          k(d, u),
                            d
                              ? (Dv.subVectors(Wv, kv).multiplyScalar(C).add(kv),
                                Ov.subVectors(Wv, Hv).multiplyScalar(C).add(Hv),
                                N(kv, S, 0),
                                N(Dv, S, 0),
                                N(c, S, 0.5),
                                N(c, S, 0.5),
                                N(Dv, S, 0),
                                N(Ov, S, 0),
                                N(c, S, 0.5),
                                N(Ov, S, 0),
                                N(Hv, S, 0))
                              : (Dv.subVectors(Wv, Uv).multiplyScalar(C).add(Uv),
                                Ov.subVectors(Wv, Gv).multiplyScalar(C).add(Gv),
                                N(Uv, S, 1),
                                N(Dv, S, 1),
                                N(c, S, 0.5),
                                N(c, S, 0.5),
                                N(Dv, S, 1),
                                N(Ov, S, 1),
                                N(c, S, 0.5),
                                N(Ov, S, 1),
                                N(Gv, S, 1))
                        } else
                          u
                            ? (d
                                ? (N(Bv, y, 1), N(Nv, y, 0), N(Wv, S, 0), N(Bv, y, 1), N(Wv, S, 0), N(Vv, S, 1))
                                : (N(Bv, y, 1), N(Nv, y, 0), N(Wv, S, 1), N(Nv, y, 0), N(Vv, S, 0), N(Wv, S, 1)),
                              d ? Hv.copy(Wv) : Gv.copy(Wv))
                            : d
                            ? (N(kv, S, 0), N(Wv, S, 0), N(c, S, 0.5), N(c, S, 0.5), N(Wv, S, 0), N(Hv, S, 0))
                            : (N(Uv, S, 1), N(Wv, S, 1), N(c, S, 0.5), N(c, S, 0.5), N(Wv, S, 1), N(Gv, S, 1)),
                            (p = !0)
                    }
                  } else F()
                } else F()
                m || M !== l - 1 || U(t[0], Fv, zv, d, !0, y), (y = S), (f = c), Nv.copy(Hv), Bv.copy(Gv)
              }
              if (m) {
                if (u && r) {
                  var I = Wv,
                    D = Vv
                  x !== d && ((I = Vv), (D = Wv)),
                    d
                      ? (p || x) && (D.toArray(r, 0), D.toArray(r, 9), p && I.toArray(r, 3))
                      : (!p && x) || (D.toArray(r, 3), D.toArray(r, 9), p && I.toArray(r, 0))
                }
              } else U(c, kv, Uv, d, !1, S)
              return b
              function O(t, e, n) {
                return n.subVectors(e, t), n.set(-n.y, n.x).normalize()
              }
              function N(t, e, n) {
                r &&
                  ((r[w] = t.x),
                  (r[w + 1] = t.y),
                  (r[w + 2] = 0),
                  s && ((s[w] = 0), (s[w + 1] = 0), (s[w + 2] = 1)),
                  (w += 3),
                  o && ((o[_] = e), (o[_ + 1] = n), (_ += 2))),
                  (b += 3)
              }
              function B(t, e, i, r, s) {
                Lv.copy(e).sub(t).normalize(), Rv.copy(i).sub(t).normalize()
                var o = Math.PI,
                  a = Lv.dot(Rv)
                Math.abs(a) < 1 && (o = Math.abs(Math.acos(a))), (o /= n), Pv.copy(e)
                for (var l = 0, c = n - 1; l < c; l++)
                  Cv.copy(Pv).rotateAround(t, o), N(Pv, r, s), N(Cv, r, s), N(t, r, 0.5), Pv.copy(Cv)
                N(Cv, r, s), N(i, r, s), N(t, r, 0.5)
              }
              function F() {
                N(Bv, y, 1), N(Nv, y, 0), N(kv, S, 0), N(Bv, y, 1), N(kv, S, 1), N(Uv, S, 0)
              }
              function z(t, e, n) {
                e
                  ? t
                    ? (N(Bv, y, 1),
                      N(Nv, y, 0),
                      N(kv, S, 0),
                      N(Bv, y, 1),
                      N(kv, S, 0),
                      N(Vv, S, 1),
                      N(kv, n, 0),
                      N(Hv, n, 0),
                      N(Vv, n, 0.5))
                    : (N(Bv, y, 1),
                      N(Nv, y, 0),
                      N(Uv, S, 1),
                      N(Nv, y, 0),
                      N(Vv, S, 0),
                      N(Uv, S, 1),
                      N(Uv, n, 1),
                      N(Gv, n, 0),
                      N(Vv, n, 0.5))
                  : t
                  ? (N(kv, n, 0), N(Hv, n, 0), N(c, n, 0.5))
                  : (N(Uv, n, 1), N(Gv, n, 0), N(c, n, 0.5))
              }
              function k(t, e) {
                e &&
                  (t
                    ? (N(Bv, y, 1),
                      N(Nv, y, 0),
                      N(kv, S, 0),
                      N(Bv, y, 1),
                      N(kv, S, 0),
                      N(Vv, S, 1),
                      N(kv, y, 0),
                      N(c, S, 0.5),
                      N(Vv, S, 1),
                      N(c, S, 0.5),
                      N(Hv, y, 0),
                      N(Vv, S, 1))
                    : (N(Bv, y, 1),
                      N(Nv, y, 0),
                      N(Uv, S, 1),
                      N(Nv, y, 0),
                      N(Vv, S, 0),
                      N(Uv, S, 1),
                      N(Uv, y, 1),
                      N(Vv, S, 0),
                      N(c, S, 0.5),
                      N(c, S, 0.5),
                      N(Vv, S, 0),
                      N(Gv, y, 1)))
              }
              function U(t, n, i, s, o, a) {
                switch (e.strokeLineCap) {
                  case 'round':
                    o ? B(t, i, n, a, 0.5) : B(t, n, i, a, 0.5)
                    break
                  case 'square':
                    if (o)
                      Lv.subVectors(n, t),
                        Rv.set(Lv.y, -Lv.x),
                        Pv.addVectors(Lv, Rv).add(t),
                        Cv.subVectors(Rv, Lv).add(t),
                        s
                          ? (Pv.toArray(r, 3), Cv.toArray(r, 0), Cv.toArray(r, 9))
                          : (Pv.toArray(r, 3), Pv.toArray(r, 9), Cv.toArray(r, 0))
                    else {
                      Lv.subVectors(i, t),
                        Rv.set(Lv.y, -Lv.x),
                        Pv.addVectors(Lv, Rv).add(t),
                        Cv.subVectors(Rv, Lv).add(t)
                      var l = r.length
                      s
                        ? (Pv.toArray(r, l - 3), Cv.toArray(r, l - 6), Cv.toArray(r, l - 12))
                        : (Pv.toArray(r, l - 6), Cv.toArray(r, l - 3), Cv.toArray(r, l - 12))
                    }
                }
              }
            }))
        var Yv = function (t, e, n, i) {
          return new (n || (n = Promise))(function (r, s) {
            function o(t) {
              try {
                l(i.next(t))
              } catch (t) {
                s(t)
              }
            }
            function a(t) {
              try {
                l(i.throw(t))
              } catch (t) {
                s(t)
              }
            }
            function l(t) {
              var e
              t.done
                ? r(t.value)
                : ((e = t.value),
                  e instanceof n
                    ? e
                    : new n(function (t) {
                        t(e)
                      })).then(o, a)
            }
            l((i = i.apply(t, e || [])).next())
          })
        }
        class Zv {
          constructor(t, e) {
            ;(this.cache = t), (this.textureAnisotropy = e)
          }
          get fileLoader() {
            return this._fileLoader || (this._fileLoader = new Dh()), this._fileLoader
          }
          get imageLoader() {
            return this._imgLoader || (this._imgLoader = new Bh()), this._imgLoader
          }
          get svgLoader() {
            return this._svgLoader || (this._svgLoader = new Xv()), this._svgLoader
          }
          get textureLoader() {
            return this._textureLoader || (this._textureLoader = new kh()), this._textureLoader
          }
          get objectLoader() {
            return this._objectLoader || (this._objectLoader = new Ou()), this._objectLoader
          }
          get gltfLoader() {
            return this._gltfLoader || (this._gltfLoader = new qv()), this._gltfLoader
          }
          get fbxLoader() {
            return this._fbxLoader || (this._fbxLoader = new jv()), this._fbxLoader
          }
          preload(t, e) {
            return Yv(this, void 0, void 0, function* () {
              return (
                this.cache.add(t, e),
                new Promise(t => {
                  const n = /\.fbx$|\.glb$|\.gltf$/.test(e)
                  ;/\.jpe?g$|\.png$/.test(e)
                    ? this.textureLoader.load(e, e => t(e))
                    : (n && this.fileLoader.setResponseType('arraybuffer'), this.fileLoader.load(e, e => t(e)))
                })
              )
            })
          }
          textureAtlas(t, e, n = 'JSONHash') {
            return Yv(this, void 0, void 0, function* () {
              let n = JSON.parse(yield this.file(e))
              if (n.textures) {
                const t = n.textures[0].frames
                let e = { frames: {} }
                t.forEach(t => {
                  e = Object.assign(Object.assign({}, e), {
                    frames: Object.assign(Object.assign({}, e.frames), {
                      [t.filename]: {
                        frame: t.frame,
                        rotated: t.rotated,
                        sourceSize: t.sourceSize,
                        spriteSourceSize: t.spriteSourceSize,
                        trimmed: t.trimmed
                      }
                    })
                  })
                }),
                  (n = e)
              }
              return { texture: yield this.texture(t), json: n }
            })
          }
          file(t) {
            const e = this.cache.get(t)
            return (
              (t = e || t),
              new Promise(e => {
                this.fileLoader.load(t, t => e(t))
              })
            )
          }
          svg(t) {
            const e = this.cache.get(t)
            return (
              (t = e || t),
              new Promise(e => {
                this.svgLoader.load(t, t => e(t))
              })
            )
          }
          texture(t) {
            if (!/^data:image\/[\S]+;base64,/gm.test(t)) {
              const e = this.cache.get(t)
              t = e || t
            }
            return new Promise(e => {
              this.textureLoader.load(t, t => {
                ;(t.anisotropy = this.textureAnisotropy), (t.needsUpdate = !0), e(t)
              })
            })
          }
          object(t) {
            const e = this.cache.get(t)
            return (
              (t = e || t),
              new Promise(e => {
                this.objectLoader.load(t, t => {
                  e(t)
                })
              })
            )
          }
          gltf(t) {
            const e = this.cache.get(t)
            return (
              (t = e || t),
              new Promise(e => {
                this.gltfLoader.load(t, t => {
                  e(t)
                })
              })
            )
          }
          fbx(t) {
            const e = this.cache.get(t)
            return (
              (t = e || t),
              new Promise(e => {
                this.fbxLoader.load(t, t => {
                  e(t)
                })
              })
            )
          }
        }
        class Jv extends ir {
          constructor(t, e, n, i) {
            super(),
              (this.scene = t),
              (this.light = e),
              (this.size = n),
              (this.color = i),
              (this.geo = new Yc(n || 0.2, 16, 8)),
              (this.mat = new Lr({ color: i || e.color })),
              (this.mesh = new gs(this.geo, this.mat)),
              this.add(this.mesh),
              e.add(this)
          }
          dispose() {
            this.mesh.geometry.dispose(),
              Array.isArray(this.mesh.material)
                ? this.mesh.material.forEach(t => t.dispose())
                : this.mesh.material.dispose(),
              this.remove(this.mesh)
          }
          update() {}
        }
        class Kv {
          constructor(t) {
            this.scene = t
          }
          get helper() {
            return {
              directionalLightHelper: (t, e, n) => {
                const i = new ip(t, e, n)
                return this.scene.add(i), i
              },
              spotLightHelper: (t, e) => {
                const n = new Hd(t, e)
                return this.scene.add(n), n
              },
              pointLightHelper: (t, e, n) => new Jv(this.scene, t, e, n)
            }
          }
          directionalLight(t = {}) {
            const { color: e = 16777215, intensity: n = 1 } = t,
              i = new Tu(e, n)
            return (i.castShadow = !0), this.scene.add(i), i
          }
          hemisphereLight(t = {}) {
            const { skyColor: e = 16777215, groundColor: n = 16777215, intensity: i = 1 } = t,
              r = new hu(e, n, i)
            return this.scene.add(r), r
          }
          ambientLight(t = {}) {
            const { color: e = 16777215, intensity: n = 1 } = t,
              i = new Su(e, n)
            return this.scene.add(i), i
          }
          pointLight(t = {}) {
            const { color: e = 16777215, intensity: n = 1, distance: i = 0, decay: r = 1 } = t,
              s = new wu(e, n, i, r)
            return (s.castShadow = !0), this.scene.add(s), s
          }
          spotLight(t = {}) {
            const {
                color: e = 16777215,
                intensity: n = 1,
                distance: i = 0,
                angle: r = Math.PI / 8,
                penumbra: s = 0,
                decay: o = 1
              } = t,
              a = new gu(e, n, i, r, s, o)
            return (a.castShadow = !0), this.scene.add(a), a
          }
          rectAreaLight(t = {}) {
            const { color: e = 16777215, intensity: n = 1, width: i = 10, height: r = 10 } = t,
              s = new Eu(e, n, i, r)
            return this.scene.add(s), s
          }
        }
        const Qv = new Ii(),
          $v = new ir(),
          ty = new ei()
        function ey() {
          ;(this.uuid = Vn.generateUUID()),
            (this.name = ''),
            (this.type = 'Geometry'),
            (this.vertices = []),
            (this.colors = []),
            (this.faces = []),
            (this.faceVertexUvs = [[]]),
            (this.morphTargets = []),
            (this.morphNormals = []),
            (this.skinWeights = []),
            (this.skinIndices = []),
            (this.lineDistances = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.elementsNeedUpdate = !1),
            (this.verticesNeedUpdate = !1),
            (this.uvsNeedUpdate = !1),
            (this.normalsNeedUpdate = !1),
            (this.colorsNeedUpdate = !1),
            (this.lineDistancesNeedUpdate = !1),
            (this.groupsNeedUpdate = !1)
        }
        ;(ey.prototype = Object.assign(Object.create(Un.prototype), {
          constructor: ey,
          isGeometry: !0,
          applyMatrix4: function (t) {
            const e = new jn().getNormalMatrix(t)
            for (let e = 0, n = this.vertices.length; e < n; e++) this.vertices[e].applyMatrix4(t)
            for (let t = 0, n = this.faces.length; t < n; t++) {
              const n = this.faces[t]
              n.normal.applyMatrix3(e).normalize()
              for (let t = 0, i = n.vertexNormals.length; t < i; t++) n.vertexNormals[t].applyMatrix3(e).normalize()
            }
            return (
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              (this.verticesNeedUpdate = !0),
              (this.normalsNeedUpdate = !0),
              this
            )
          },
          rotateX: function (t) {
            return Qv.makeRotationX(t), this.applyMatrix4(Qv), this
          },
          rotateY: function (t) {
            return Qv.makeRotationY(t), this.applyMatrix4(Qv), this
          },
          rotateZ: function (t) {
            return Qv.makeRotationZ(t), this.applyMatrix4(Qv), this
          },
          translate: function (t, e, n) {
            return Qv.makeTranslation(t, e, n), this.applyMatrix4(Qv), this
          },
          scale: function (t, e, n) {
            return Qv.makeScale(t, e, n), this.applyMatrix4(Qv), this
          },
          lookAt: function (t) {
            return $v.lookAt(t), $v.updateMatrix(), this.applyMatrix4($v.matrix), this
          },
          fromBufferGeometry: function (t) {
            const e = this,
              n = null !== t.index ? t.index : void 0,
              i = t.attributes
            if (void 0 === i.position)
              return (
                console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.'), this
              )
            const r = i.position,
              s = i.normal,
              o = i.color,
              a = i.uv,
              l = i.uv2
            void 0 !== l && (this.faceVertexUvs[1] = [])
            for (let t = 0; t < r.count; t++)
              e.vertices.push(new ei().fromBufferAttribute(r, t)),
                void 0 !== o && e.colors.push(new Ar().fromBufferAttribute(o, t))
            function c(t, n, i, r) {
              const c = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                h =
                  void 0 === s
                    ? []
                    : [
                        new ei().fromBufferAttribute(s, t),
                        new ei().fromBufferAttribute(s, n),
                        new ei().fromBufferAttribute(s, i)
                      ],
                u = new iy(t, n, i, h, c, r)
              e.faces.push(u),
                void 0 !== a &&
                  e.faceVertexUvs[0].push([
                    new Wn().fromBufferAttribute(a, t),
                    new Wn().fromBufferAttribute(a, n),
                    new Wn().fromBufferAttribute(a, i)
                  ]),
                void 0 !== l &&
                  e.faceVertexUvs[1].push([
                    new Wn().fromBufferAttribute(l, t),
                    new Wn().fromBufferAttribute(l, n),
                    new Wn().fromBufferAttribute(l, i)
                  ])
            }
            const h = t.groups
            if (h.length > 0)
              for (let t = 0; t < h.length; t++) {
                const e = h[t],
                  i = e.start
                for (let t = i, r = i + e.count; t < r; t += 3)
                  void 0 !== n
                    ? c(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex)
                    : c(t, t + 1, t + 2, e.materialIndex)
              }
            else if (void 0 !== n) for (let t = 0; t < n.count; t += 3) c(n.getX(t), n.getX(t + 1), n.getX(t + 2))
            else for (let t = 0; t < r.count; t += 3) c(t, t + 1, t + 2)
            return (
              this.computeFaceNormals(),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              this
            )
          },
          center: function () {
            return (
              this.computeBoundingBox(), this.boundingBox.getCenter(ty).negate(), this.translate(ty.x, ty.y, ty.z), this
            )
          },
          normalize: function () {
            this.computeBoundingSphere()
            const t = this.boundingSphere.center,
              e = this.boundingSphere.radius,
              n = 0 === e ? 1 : 1 / e,
              i = new Ii()
            return (
              i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
            )
          },
          computeFaceNormals: function () {
            const t = new ei(),
              e = new ei()
            for (let n = 0, i = this.faces.length; n < i; n++) {
              const i = this.faces[n],
                r = this.vertices[i.a],
                s = this.vertices[i.b],
                o = this.vertices[i.c]
              t.subVectors(o, s), e.subVectors(r, s), t.cross(e), t.normalize(), i.normal.copy(t)
            }
          },
          computeVertexNormals: function (t = !0) {
            const e = new Array(this.vertices.length)
            for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new ei()
            if (t) {
              const t = new ei(),
                n = new ei()
              for (let i = 0, r = this.faces.length; i < r; i++) {
                const r = this.faces[i],
                  s = this.vertices[r.a],
                  o = this.vertices[r.b],
                  a = this.vertices[r.c]
                t.subVectors(a, o), n.subVectors(s, o), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
              }
            } else {
              this.computeFaceNormals()
              for (let t = 0, n = this.faces.length; t < n; t++) {
                const n = this.faces[t]
                e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
              }
            }
            for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize()
            for (let t = 0, n = this.faces.length; t < n; t++) {
              const n = this.faces[t],
                i = n.vertexNormals
              3 === i.length
                ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c]))
                : ((i[0] = e[n.a].clone()), (i[1] = e[n.b].clone()), (i[2] = e[n.c].clone()))
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
          },
          computeFlatVertexNormals: function () {
            this.computeFaceNormals()
            for (let t = 0, e = this.faces.length; t < e; t++) {
              const e = this.faces[t],
                n = e.vertexNormals
              3 === n.length
                ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal))
                : ((n[0] = e.normal.clone()), (n[1] = e.normal.clone()), (n[2] = e.normal.clone()))
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
          },
          computeMorphNormals: function () {
            for (let t = 0, e = this.faces.length; t < e; t++) {
              const e = this.faces[t]
              e.__originalFaceNormal
                ? e.__originalFaceNormal.copy(e.normal)
                : (e.__originalFaceNormal = e.normal.clone()),
                e.__originalVertexNormals || (e.__originalVertexNormals = [])
              for (let t = 0, n = e.vertexNormals.length; t < n; t++)
                e.__originalVertexNormals[t]
                  ? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
                  : (e.__originalVertexNormals[t] = e.vertexNormals[t].clone())
            }
            const t = new ey()
            t.faces = this.faces
            for (let e = 0, n = this.morphTargets.length; e < n; e++) {
              if (!this.morphNormals[e]) {
                ;(this.morphNormals[e] = {}),
                  (this.morphNormals[e].faceNormals = []),
                  (this.morphNormals[e].vertexNormals = [])
                const t = this.morphNormals[e].faceNormals,
                  n = this.morphNormals[e].vertexNormals
                for (let e = 0, i = this.faces.length; e < i; e++) {
                  const e = new ei(),
                    i = { a: new ei(), b: new ei(), c: new ei() }
                  t.push(e), n.push(i)
                }
              }
              const n = this.morphNormals[e]
              ;(t.vertices = this.morphTargets[e].vertices), t.computeFaceNormals(), t.computeVertexNormals()
              for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t],
                  i = n.faceNormals[t],
                  r = n.vertexNormals[t]
                i.copy(e.normal),
                  r.a.copy(e.vertexNormals[0]),
                  r.b.copy(e.vertexNormals[1]),
                  r.c.copy(e.vertexNormals[2])
              }
            }
            for (let t = 0, e = this.faces.length; t < e; t++) {
              const e = this.faces[t]
              ;(e.normal = e.__originalFaceNormal), (e.vertexNormals = e.__originalVertexNormals)
            }
          },
          computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ri()), this.boundingBox.setFromPoints(this.vertices)
          },
          computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Mi()),
              this.boundingSphere.setFromPoints(this.vertices)
          },
          merge: function (t, e, n = 0) {
            if (!t || !t.isGeometry)
              return void console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', t)
            let i
            const r = this.vertices.length,
              s = this.vertices,
              o = t.vertices,
              a = this.faces,
              l = t.faces,
              c = this.colors,
              h = t.colors
            void 0 !== e && (i = new jn().getNormalMatrix(e))
            for (let t = 0, n = o.length; t < n; t++) {
              const n = o[t].clone()
              void 0 !== e && n.applyMatrix4(e), s.push(n)
            }
            for (let t = 0, e = h.length; t < e; t++) c.push(h[t].clone())
            for (let t = 0, e = l.length; t < e; t++) {
              const e = l[t]
              let s, o
              const c = e.vertexNormals,
                h = e.vertexColors,
                u = new iy(e.a + r, e.b + r, e.c + r)
              u.normal.copy(e.normal), void 0 !== i && u.normal.applyMatrix3(i).normalize()
              for (let t = 0, e = c.length; t < e; t++)
                (s = c[t].clone()), void 0 !== i && s.applyMatrix3(i).normalize(), u.vertexNormals.push(s)
              u.color.copy(e.color)
              for (let t = 0, e = h.length; t < e; t++) (o = h[t]), u.vertexColors.push(o.clone())
              ;(u.materialIndex = e.materialIndex + n), a.push(u)
            }
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
              const n = t.faceVertexUvs[e]
              void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = [])
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t],
                  r = []
                for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone())
                this.faceVertexUvs[e].push(r)
              }
            }
          },
          mergeMesh: function (t) {
            t && t.isMesh
              ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
              : console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', t)
          },
          mergeVertices: function (t = 4) {
            const e = {},
              n = [],
              i = [],
              r = Math.pow(10, t)
            for (let t = 0, s = this.vertices.length; t < s; t++) {
              const s = this.vertices[t],
                o = Math.round(s.x * r) + '_' + Math.round(s.y * r) + '_' + Math.round(s.z * r)
              void 0 === e[o] ? ((e[o] = t), n.push(this.vertices[t]), (i[t] = n.length - 1)) : (i[t] = i[e[o]])
            }
            const s = []
            for (let t = 0, e = this.faces.length; t < e; t++) {
              const e = this.faces[t]
              ;(e.a = i[e.a]), (e.b = i[e.b]), (e.c = i[e.c])
              const n = [e.a, e.b, e.c]
              for (let e = 0; e < 3; e++)
                if (n[e] === n[(e + 1) % 3]) {
                  s.push(t)
                  break
                }
            }
            for (let t = s.length - 1; t >= 0; t--) {
              const e = s[t]
              this.faces.splice(e, 1)
              for (let t = 0, n = this.faceVertexUvs.length; t < n; t++) this.faceVertexUvs[t].splice(e, 1)
            }
            const o = this.vertices.length - n.length
            return (this.vertices = n), o
          },
          setFromPoints: function (t) {
            this.vertices = []
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e]
              this.vertices.push(new ei(n.x, n.y, n.z || 0))
            }
            return this
          },
          sortFacesByMaterialIndex: function () {
            const t = this.faces,
              e = t.length
            for (let n = 0; n < e; n++) t[n]._id = n
            t.sort(function (t, e) {
              return t.materialIndex - e.materialIndex
            })
            const n = this.faceVertexUvs[0],
              i = this.faceVertexUvs[1]
            let r, s
            n && n.length === e && (r = []), i && i.length === e && (s = [])
            for (let o = 0; o < e; o++) {
              const e = t[o]._id
              r && r.push(n[e]), s && s.push(i[e])
            }
            r && (this.faceVertexUvs[0] = r), s && (this.faceVertexUvs[1] = s)
          },
          toJSON: function () {
            const t = { metadata: { version: 4.5, type: 'Geometry', generator: 'Geometry.toJSON' } }
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              '' !== this.name && (t.name = this.name),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters
              for (const n in e) void 0 !== e[n] && (t[n] = e[n])
              return t
            }
            const e = []
            for (let t = 0; t < this.vertices.length; t++) {
              const n = this.vertices[t]
              e.push(n.x, n.y, n.z)
            }
            const n = [],
              i = [],
              r = {},
              s = [],
              o = {},
              a = [],
              l = {}
            for (let t = 0; t < this.faces.length; t++) {
              const e = this.faces[t],
                i = !0,
                r = !1,
                s = void 0 !== this.faceVertexUvs[0][t],
                o = e.normal.length() > 0,
                a = e.vertexNormals.length > 0,
                l = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
                p = e.vertexColors.length > 0
              let m = 0
              if (
                ((m = c(m, 0, 0)),
                (m = c(m, 1, i)),
                (m = c(m, 2, r)),
                (m = c(m, 3, s)),
                (m = c(m, 4, o)),
                (m = c(m, 5, a)),
                (m = c(m, 6, l)),
                (m = c(m, 7, p)),
                n.push(m),
                n.push(e.a, e.b, e.c),
                n.push(e.materialIndex),
                s)
              ) {
                const e = this.faceVertexUvs[0][t]
                n.push(d(e[0]), d(e[1]), d(e[2]))
              }
              if ((o && n.push(h(e.normal)), a)) {
                const t = e.vertexNormals
                n.push(h(t[0]), h(t[1]), h(t[2]))
              }
              if ((l && n.push(u(e.color)), p)) {
                const t = e.vertexColors
                n.push(u(t[0]), u(t[1]), u(t[2]))
              }
            }
            function c(t, e, n) {
              return n ? t | (1 << e) : t & ~(1 << e)
            }
            function h(t) {
              const e = t.x.toString() + t.y.toString() + t.z.toString()
              return void 0 !== r[e] || ((r[e] = i.length / 3), i.push(t.x, t.y, t.z)), r[e]
            }
            function u(t) {
              const e = t.r.toString() + t.g.toString() + t.b.toString()
              return void 0 !== o[e] || ((o[e] = s.length), s.push(t.getHex())), o[e]
            }
            function d(t) {
              const e = t.x.toString() + t.y.toString()
              return void 0 !== l[e] || ((l[e] = a.length / 2), a.push(t.x, t.y)), l[e]
            }
            return (
              (t.data = {}),
              (t.data.vertices = e),
              (t.data.normals = i),
              s.length > 0 && (t.data.colors = s),
              a.length > 0 && (t.data.uvs = [a]),
              (t.data.faces = n),
              t
            )
          },
          clone: function () {
            return new ey().copy(this)
          },
          copy: function (t) {
            ;(this.vertices = []),
              (this.colors = []),
              (this.faces = []),
              (this.faceVertexUvs = [[]]),
              (this.morphTargets = []),
              (this.morphNormals = []),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.lineDistances = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.name = t.name)
            const e = t.vertices
            for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone())
            const n = t.colors
            for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone())
            const i = t.faces
            for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone())
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
              const n = t.faceVertexUvs[e]
              void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = [])
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t],
                  r = []
                for (let t = 0, e = i.length; t < e; t++) {
                  const e = i[t]
                  r.push(e.clone())
                }
                this.faceVertexUvs[e].push(r)
              }
            }
            const r = t.morphTargets
            for (let t = 0, e = r.length; t < e; t++) {
              const e = {}
              if (((e.name = r[t].name), void 0 !== r[t].vertices)) {
                e.vertices = []
                for (let n = 0, i = r[t].vertices.length; n < i; n++) e.vertices.push(r[t].vertices[n].clone())
              }
              if (void 0 !== r[t].normals) {
                e.normals = []
                for (let n = 0, i = r[t].normals.length; n < i; n++) e.normals.push(r[t].normals[n].clone())
              }
              this.morphTargets.push(e)
            }
            const s = t.morphNormals
            for (let t = 0, e = s.length; t < e; t++) {
              const e = {}
              if (void 0 !== s[t].vertexNormals) {
                e.vertexNormals = []
                for (let n = 0, i = s[t].vertexNormals.length; n < i; n++) {
                  const i = s[t].vertexNormals[n],
                    r = {}
                  ;(r.a = i.a.clone()), (r.b = i.b.clone()), (r.c = i.c.clone()), e.vertexNormals.push(r)
                }
              }
              if (void 0 !== s[t].faceNormals) {
                e.faceNormals = []
                for (let n = 0, i = s[t].faceNormals.length; n < i; n++) e.faceNormals.push(s[t].faceNormals[n].clone())
              }
              this.morphNormals.push(e)
            }
            const o = t.skinWeights
            for (let t = 0, e = o.length; t < e; t++) this.skinWeights.push(o[t].clone())
            const a = t.skinIndices
            for (let t = 0, e = a.length; t < e; t++) this.skinIndices.push(a[t].clone())
            const l = t.lineDistances
            for (let t = 0, e = l.length; t < e; t++) this.lineDistances.push(l[t])
            const c = t.boundingBox
            null !== c && (this.boundingBox = c.clone())
            const h = t.boundingSphere
            return (
              null !== h && (this.boundingSphere = h.clone()),
              (this.elementsNeedUpdate = t.elementsNeedUpdate),
              (this.verticesNeedUpdate = t.verticesNeedUpdate),
              (this.uvsNeedUpdate = t.uvsNeedUpdate),
              (this.normalsNeedUpdate = t.normalsNeedUpdate),
              (this.colorsNeedUpdate = t.colorsNeedUpdate),
              (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
              (this.groupsNeedUpdate = t.groupsNeedUpdate),
              this
            )
          },
          toBufferGeometry: function () {
            const t = new ny().fromGeometry(this),
              e = new Qr(),
              n = new Float32Array(3 * t.vertices.length)
            if ((e.setAttribute('position', new Cr(n, 3).copyVector3sArray(t.vertices)), t.normals.length > 0)) {
              const n = new Float32Array(3 * t.normals.length)
              e.setAttribute('normal', new Cr(n, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
              const n = new Float32Array(3 * t.colors.length)
              e.setAttribute('color', new Cr(n, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
              const n = new Float32Array(2 * t.uvs.length)
              e.setAttribute('uv', new Cr(n, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
              const n = new Float32Array(2 * t.uvs2.length)
              e.setAttribute('uv2', new Cr(n, 2).copyVector2sArray(t.uvs2))
            }
            e.groups = t.groups
            for (const n in t.morphTargets) {
              const i = [],
                r = t.morphTargets[n]
              for (let t = 0, e = r.length; t < e; t++) {
                const e = r[t],
                  n = new Ur(3 * e.data.length, 3)
                ;(n.name = e.name), i.push(n.copyVector3sArray(e.data))
              }
              e.morphAttributes[n] = i
            }
            if (t.skinIndices.length > 0) {
              const n = new Ur(4 * t.skinIndices.length, 4)
              e.setAttribute('skinIndex', n.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
              const n = new Ur(4 * t.skinWeights.length, 4)
              e.setAttribute('skinWeight', n.copyVector4sArray(t.skinWeights))
            }
            return (
              null !== t.boundingSphere && (e.boundingSphere = t.boundingSphere.clone()),
              null !== t.boundingBox && (e.boundingBox = t.boundingBox.clone()),
              e
            )
          },
          computeTangents: function () {
            console.error('THREE.Geometry: .computeTangents() has been removed.')
          },
          computeLineDistances: function () {
            console.error(
              'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.'
            )
          },
          applyMatrix: function (t) {
            return (
              console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().'), this.applyMatrix4(t)
            )
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' })
          }
        })),
          (ey.createBufferGeometryFromObject = function (t) {
            let e = new Qr()
            const n = t.geometry
            if (t.isPoints || t.isLine) {
              const t = new Ur(3 * n.vertices.length, 3),
                i = new Ur(3 * n.colors.length, 3)
              if (
                (e.setAttribute('position', t.copyVector3sArray(n.vertices)),
                e.setAttribute('color', i.copyColorsArray(n.colors)),
                n.lineDistances && n.lineDistances.length === n.vertices.length)
              ) {
                const t = new Ur(n.lineDistances.length, 1)
                e.setAttribute('lineDistance', t.copyArray(n.lineDistances))
              }
              null !== n.boundingSphere && (e.boundingSphere = n.boundingSphere.clone()),
                null !== n.boundingBox && (e.boundingBox = n.boundingBox.clone())
            } else t.isMesh && (e = n.toBufferGeometry())
            return e
          })
        class ny {
          constructor() {
            ;(this.vertices = []),
              (this.normals = []),
              (this.colors = []),
              (this.uvs = []),
              (this.uvs2 = []),
              (this.groups = []),
              (this.morphTargets = {}),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.verticesNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.groupsNeedUpdate = !1)
          }
          computeGroups(t) {
            const e = []
            let n, i, r
            const s = t.faces
            for (i = 0; i < s.length; i++) {
              const t = s[i]
              t.materialIndex !== r &&
                ((r = t.materialIndex),
                void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
                (n = { start: 3 * i, materialIndex: r }))
            }
            void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)), (this.groups = e)
          }
          fromGeometry(t) {
            const e = t.faces,
              n = t.vertices,
              i = t.faceVertexUvs,
              r = i[0] && i[0].length > 0,
              s = i[1] && i[1].length > 0,
              o = t.morphTargets,
              a = o.length
            let l
            if (a > 0) {
              l = []
              for (let t = 0; t < a; t++) l[t] = { name: o[t].name, data: [] }
              this.morphTargets.position = l
            }
            const c = t.morphNormals,
              h = c.length
            let u
            if (h > 0) {
              u = []
              for (let t = 0; t < h; t++) u[t] = { name: c[t].name, data: [] }
              this.morphTargets.normal = u
            }
            const d = t.skinIndices,
              p = t.skinWeights,
              m = d.length === n.length,
              f = p.length === n.length
            n.length > 0 &&
              0 === e.length &&
              console.error('THREE.DirectGeometry: Faceless geometries are not supported.')
            for (let t = 0; t < e.length; t++) {
              const g = e[t]
              this.vertices.push(n[g.a], n[g.b], n[g.c])
              const v = g.vertexNormals
              if (3 === v.length) this.normals.push(v[0], v[1], v[2])
              else {
                const t = g.normal
                this.normals.push(t, t, t)
              }
              const y = g.vertexColors
              if (3 === y.length) this.colors.push(y[0], y[1], y[2])
              else {
                const t = g.color
                this.colors.push(t, t, t)
              }
              if (!0 === r) {
                const e = i[0][t]
                void 0 !== e
                  ? this.uvs.push(e[0], e[1], e[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', t),
                    this.uvs.push(new Wn(), new Wn(), new Wn()))
              }
              if (!0 === s) {
                const e = i[1][t]
                void 0 !== e
                  ? this.uvs2.push(e[0], e[1], e[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', t),
                    this.uvs2.push(new Wn(), new Wn(), new Wn()))
              }
              for (let t = 0; t < a; t++) {
                const e = o[t].vertices
                l[t].data.push(e[g.a], e[g.b], e[g.c])
              }
              for (let e = 0; e < h; e++) {
                const n = c[e].vertexNormals[t]
                u[e].data.push(n.a, n.b, n.c)
              }
              m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), f && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
            }
            return (
              this.computeGroups(t),
              (this.verticesNeedUpdate = t.verticesNeedUpdate),
              (this.normalsNeedUpdate = t.normalsNeedUpdate),
              (this.colorsNeedUpdate = t.colorsNeedUpdate),
              (this.uvsNeedUpdate = t.uvsNeedUpdate),
              (this.groupsNeedUpdate = t.groupsNeedUpdate),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              this
            )
          }
        }
        class iy {
          constructor(t, e, n, i, r, s = 0) {
            ;(this.a = t),
              (this.b = e),
              (this.c = n),
              (this.normal = i && i.isVector3 ? i : new ei()),
              (this.vertexNormals = Array.isArray(i) ? i : []),
              (this.color = r && r.isColor ? r : new Ar()),
              (this.vertexColors = Array.isArray(r) ? r : []),
              (this.materialIndex = s)
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            ;(this.a = t.a),
              (this.b = t.b),
              (this.c = t.c),
              this.normal.copy(t.normal),
              this.color.copy(t.color),
              (this.materialIndex = t.materialIndex)
            for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone()
            for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone()
            return this
          }
        }
        class ry {
          constructor() {
            ;(this.vertices = []),
              (this.normals = []),
              (this.colors = []),
              (this.uvs = []),
              (this.uvs2 = []),
              (this.groups = []),
              (this.morphTargets = {}),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.verticesNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.groupsNeedUpdate = !1)
          }
          computeGroups(t) {
            const e = []
            let n, i, r
            const s = t.faces
            for (i = 0; i < s.length; i++) {
              const t = s[i]
              t.materialIndex !== r &&
                ((r = t.materialIndex),
                void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
                (n = { start: 3 * i, materialIndex: r }))
            }
            void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)), (this.groups = e)
          }
          fromGeometry(t) {
            const e = t.faces,
              n = t.vertices,
              i = t.faceVertexUvs,
              r = i[0] && i[0].length > 0,
              s = i[1] && i[1].length > 0,
              o = t.morphTargets,
              a = o.length
            let l
            if (a > 0) {
              l = []
              for (let t = 0; t < a; t++) l[t] = { name: o[t].name, data: [] }
              this.morphTargets.position = l
            }
            const c = t.morphNormals,
              h = c.length
            let u
            if (h > 0) {
              u = []
              for (let t = 0; t < h; t++) u[t] = { name: c[t].name, data: [] }
              this.morphTargets.normal = u
            }
            const d = t.skinIndices,
              p = t.skinWeights,
              m = d.length === n.length,
              f = p.length === n.length
            n.length > 0 &&
              0 === e.length &&
              console.error('THREE.DirectGeometry: Faceless geometries are not supported.')
            for (let t = 0; t < e.length; t++) {
              const g = e[t]
              this.vertices.push(n[g.a], n[g.b], n[g.c])
              const v = g.vertexNormals
              if (3 === v.length) this.normals.push(v[0], v[1], v[2])
              else {
                const t = g.normal
                this.normals.push(t, t, t)
              }
              const y = g.vertexColors
              if (3 === y.length) this.colors.push(y[0], y[1], y[2])
              else {
                const t = g.color
                this.colors.push(t, t, t)
              }
              if (!0 === r) {
                const e = i[0][t]
                void 0 !== e
                  ? this.uvs.push(e[0], e[1], e[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', t),
                    this.uvs.push(new Wn(), new Wn(), new Wn()))
              }
              if (!0 === s) {
                const e = i[1][t]
                void 0 !== e
                  ? this.uvs2.push(e[0], e[1], e[2])
                  : (console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', t),
                    this.uvs2.push(new Wn(), new Wn(), new Wn()))
              }
              for (let t = 0; t < a; t++) {
                const e = o[t].vertices
                l[t].data.push(e[g.a], e[g.b], e[g.c])
              }
              for (let e = 0; e < h; e++) {
                const n = c[e].vertexNormals[t]
                u[e].data.push(n.a, n.b, n.c)
              }
              m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), f && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
            }
            return (
              this.computeGroups(t),
              (this.verticesNeedUpdate = t.verticesNeedUpdate),
              (this.normalsNeedUpdate = t.normalsNeedUpdate),
              (this.colorsNeedUpdate = t.colorsNeedUpdate),
              (this.uvsNeedUpdate = t.uvsNeedUpdate),
              (this.groupsNeedUpdate = t.groupsNeedUpdate),
              null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
              null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
              this
            )
          }
        }
        const sy = (t, e) => {
            const n = new ry().fromGeometry(e)
            return oy(t, n)
          },
          oy = (t, e) => {
            var n, i
            const r = new Float32Array(3 * e.vertices.length)
            if ((t.setAttribute('position', new Cr(r, 3).copyVector3sArray(e.vertices)), e.normals.length > 0)) {
              const n = new Float32Array(3 * e.normals.length)
              t.setAttribute('normal', new Cr(n, 3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
              const n = new Float32Array(3 * e.colors.length)
              t.setAttribute('color', new Cr(n, 3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
              const n = new Float32Array(2 * e.uvs.length)
              t.setAttribute('uv', new Cr(n, 2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
              const n = new Float32Array(2 * e.uvs2.length)
              t.setAttribute('uv2', new Cr(n, 2).copyVector2sArray(e.uvs2))
            }
            t.groups = e.groups
            for (const n in e.morphTargets) {
              const i = [],
                r = e.morphTargets[n]
              for (let t = 0, e = r.length; t < e; t++) {
                const e = r[t],
                  n = new Ur(3 * e.data.length, 3)
                ;(n.name = e.name), i.push(n.copyVector3sArray(e.data))
              }
              t.morphAttributes[n] = i
            }
            if (e.skinIndices.length > 0) {
              const n = new Ur(4 * e.skinIndices.length, 4)
              t.setAttribute('skinIndex', n.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
              const n = new Ur(4 * e.skinWeights.length, 4)
              t.setAttribute('skinWeight', n.copyVector4sArray(e.skinWeights))
            }
            return (
              null !== e.boundingSphere &&
                (t.boundingSphere = null === (n = e.boundingSphere) || void 0 === n ? void 0 : n.clone()),
              null !== e.boundingBox &&
                (t.boundingBox = null === (i = e.boundingBox) || void 0 === i ? void 0 : i.clone()),
              t
            )
          }
        class ay {
          constructor(t) {
            this.scene = t
          }
          add(t, e = {}) {
            const n = this.make(t, e)
            return n ? this.scene.add(n) : console.warn('Could not make heightmap'), n
          }
          make(t, e = {}) {
            const { image: n } = t,
              { width: i, height: r } = n,
              { colorScale: s } = e,
              o = document.createElement('canvas')
            ;(o.width = i), (o.height = r)
            const a = o.getContext('2d')
            if (!a) return
            a.drawImage(t.image, 0, 0)
            const l = a.getImageData(0, 0, i, r),
              c = new ey().fromBufferGeometry(new Ns(10, 10, i - 1, r - 1))
            let h = { color: 13421772, side: b }
            s && (h = Object.assign(Object.assign({}, h), { vertexColors: !0 }))
            const u = new oh(h),
              d = new Hm(c, u)
            ;(d.receiveShadow = d.castShadow = !0), (d.shape = 'concave')
            const p = d.geometry
            for (let t = 0; t < p.vertices.length; t++) p.vertices[t].z = l.data[4 * t] / 120
            return (
              s &&
                p.faces.forEach(
                  t =>
                    (t.color = new Ar(
                      s(
                        ((t, e) => {
                          var n = t.vertices[e.a].z,
                            i = t.vertices[e.b].z,
                            r = t.vertices[e.c].z
                          return Math.max(n, i, r)
                        })(p, t)
                      ).hex()
                    ))
                ),
              d.rotateX(-Math.PI / 2),
              d.updateMatrix(),
              c.computeFaceNormals(),
              c.computeVertexNormals(),
              (d.name = 'heightmap'),
              (d.geometry = sy(new Qr(), d.geometry)),
              d
            )
          }
        }
        var ly = function (t, e) {
          var n, i, r, s, o, a
          void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
            e === document &&
              console.error(
                'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
              ),
            (this.object = t),
            (this.domElement = e),
            (this.enabled = !0),
            (this.target = new ei()),
            (this.minDistance = 0),
            (this.maxDistance = 1 / 0),
            (this.minZoom = 0),
            (this.maxZoom = 1 / 0),
            (this.minPolarAngle = 0),
            (this.maxPolarAngle = Math.PI),
            (this.minAzimuthAngle = -1 / 0),
            (this.maxAzimuthAngle = 1 / 0),
            (this.enableDamping = !1),
            (this.dampingFactor = 0.05),
            (this.enableZoom = !0),
            (this.zoomSpeed = 1),
            (this.enableRotate = !0),
            (this.rotateSpeed = 1),
            (this.enablePan = !0),
            (this.panSpeed = 1),
            (this.screenSpacePanning = !0),
            (this.keyPanSpeed = 7),
            (this.autoRotate = !1),
            (this.autoRotateSpeed = 2),
            (this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }),
            (this.mouseButtons = { LEFT: l.ROTATE, MIDDLE: l.DOLLY, RIGHT: l.PAN }),
            (this.touches = { ONE: c.ROTATE, TWO: c.DOLLY_PAN }),
            (this.target0 = this.target.clone()),
            (this.position0 = this.object.position.clone()),
            (this.zoom0 = this.object.zoom),
            (this._domElementKeyEvents = null),
            (this.getPolarAngle = function () {
              return v.phi
            }),
            (this.getAzimuthalAngle = function () {
              return v.theta
            }),
            (this.listenToKeyEvents = function (t) {
              t.addEventListener('keydown', Q), (this._domElementKeyEvents = t)
            }),
            (this.saveState = function () {
              h.target0.copy(h.target), h.position0.copy(h.object.position), (h.zoom0 = h.object.zoom)
            }),
            (this.reset = function () {
              h.target.copy(h.target0),
                h.object.position.copy(h.position0),
                (h.object.zoom = h.zoom0),
                h.object.updateProjectionMatrix(),
                h.dispatchEvent(u),
                h.update(),
                (f = m.NONE)
            }),
            (this.update =
              ((n = new ei()),
              (i = new ti().setFromUnitVectors(t.up, new ei(0, 1, 0))),
              (r = i.clone().invert()),
              (s = new ei()),
              (o = new ti()),
              (a = 2 * Math.PI),
              function () {
                var t = h.object.position
                n.copy(t).sub(h.target),
                  n.applyQuaternion(i),
                  v.setFromVector3(n),
                  h.autoRotate && f === m.NONE && I(((2 * Math.PI) / 60 / 60) * h.autoRotateSpeed),
                  h.enableDamping
                    ? ((v.theta += y.theta * h.dampingFactor), (v.phi += y.phi * h.dampingFactor))
                    : ((v.theta += y.theta), (v.phi += y.phi))
                var e = h.minAzimuthAngle,
                  l = h.maxAzimuthAngle
                return (
                  isFinite(e) &&
                    isFinite(l) &&
                    (e < -Math.PI ? (e += a) : e > Math.PI && (e -= a),
                    l < -Math.PI ? (l += a) : l > Math.PI && (l -= a),
                    (v.theta =
                      e <= l
                        ? Math.max(e, Math.min(l, v.theta))
                        : v.theta > (e + l) / 2
                        ? Math.max(e, v.theta)
                        : Math.min(l, v.theta))),
                  (v.phi = Math.max(h.minPolarAngle, Math.min(h.maxPolarAngle, v.phi))),
                  v.makeSafe(),
                  (v.radius *= x),
                  (v.radius = Math.max(h.minDistance, Math.min(h.maxDistance, v.radius))),
                  !0 === h.enableDamping ? h.target.addScaledVector(b, h.dampingFactor) : h.target.add(b),
                  n.setFromSpherical(v),
                  n.applyQuaternion(r),
                  t.copy(h.target).add(n),
                  h.object.lookAt(h.target),
                  !0 === h.enableDamping
                    ? ((y.theta *= 1 - h.dampingFactor),
                      (y.phi *= 1 - h.dampingFactor),
                      b.multiplyScalar(1 - h.dampingFactor))
                    : (y.set(0, 0, 0), b.set(0, 0, 0)),
                  (x = 1),
                  !!(w || s.distanceToSquared(h.object.position) > g || 8 * (1 - o.dot(h.object.quaternion)) > g) &&
                    (h.dispatchEvent(u), s.copy(h.object.position), o.copy(h.object.quaternion), (w = !1), !0)
                )
              })),
            (this.dispose = function () {
              h.domElement.removeEventListener('contextmenu', nt),
                h.domElement.removeEventListener('pointerdown', Y),
                h.domElement.removeEventListener('wheel', K),
                h.domElement.removeEventListener('touchstart', $),
                h.domElement.removeEventListener('touchend', et),
                h.domElement.removeEventListener('touchmove', tt),
                h.domElement.ownerDocument.removeEventListener('pointermove', Z),
                h.domElement.ownerDocument.removeEventListener('pointerup', J),
                null !== h._domElementKeyEvents && h._domElementKeyEvents.removeEventListener('keydown', Q)
            })
          var h = this,
            u = { type: 'change' },
            d = { type: 'start' },
            p = { type: 'end' },
            m = {
              NONE: -1,
              ROTATE: 0,
              DOLLY: 1,
              PAN: 2,
              TOUCH_ROTATE: 3,
              TOUCH_PAN: 4,
              TOUCH_DOLLY_PAN: 5,
              TOUCH_DOLLY_ROTATE: 6
            },
            f = m.NONE,
            g = 1e-6,
            v = new Id(),
            y = new Id(),
            x = 1,
            b = new ei(),
            w = !1,
            _ = new Wn(),
            M = new Wn(),
            T = new Wn(),
            S = new Wn(),
            E = new Wn(),
            A = new Wn(),
            L = new Wn(),
            R = new Wn(),
            P = new Wn()
          function C() {
            return Math.pow(0.95, h.zoomSpeed)
          }
          function I(t) {
            y.theta -= t
          }
          function D(t) {
            y.phi -= t
          }
          var O,
            N =
              ((O = new ei()),
              function (t, e) {
                O.setFromMatrixColumn(e, 0), O.multiplyScalar(-t), b.add(O)
              }),
            B = (function () {
              var t = new ei()
              return function (e, n) {
                !0 === h.screenSpacePanning
                  ? t.setFromMatrixColumn(n, 1)
                  : (t.setFromMatrixColumn(n, 0), t.crossVectors(h.object.up, t)),
                  t.multiplyScalar(e),
                  b.add(t)
              }
            })(),
            F = (function () {
              var t = new ei()
              return function (e, n) {
                var i = h.domElement
                if (h.object.isPerspectiveCamera) {
                  var r = h.object.position
                  t.copy(r).sub(h.target)
                  var s = t.length()
                  ;(s *= Math.tan(((h.object.fov / 2) * Math.PI) / 180)),
                    N((2 * e * s) / i.clientHeight, h.object.matrix),
                    B((2 * n * s) / i.clientHeight, h.object.matrix)
                } else
                  h.object.isOrthographicCamera
                    ? (N((e * (h.object.right - h.object.left)) / h.object.zoom / i.clientWidth, h.object.matrix),
                      B((n * (h.object.top - h.object.bottom)) / h.object.zoom / i.clientHeight, h.object.matrix))
                    : (console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'),
                      (h.enablePan = !1))
              }
            })()
          function z(t) {
            h.object.isPerspectiveCamera
              ? (x /= t)
              : h.object.isOrthographicCamera
              ? ((h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom * t))),
                h.object.updateProjectionMatrix(),
                (w = !0))
              : (console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'),
                (h.enableZoom = !1))
          }
          function k(t) {
            h.object.isPerspectiveCamera
              ? (x *= t)
              : h.object.isOrthographicCamera
              ? ((h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom / t))),
                h.object.updateProjectionMatrix(),
                (w = !0))
              : (console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'),
                (h.enableZoom = !1))
          }
          function U(t) {
            _.set(t.clientX, t.clientY)
          }
          function H(t) {
            S.set(t.clientX, t.clientY)
          }
          function G(t) {
            if (1 == t.touches.length) _.set(t.touches[0].pageX, t.touches[0].pageY)
            else {
              var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
                n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)
              _.set(e, n)
            }
          }
          function V(t) {
            if (1 == t.touches.length) S.set(t.touches[0].pageX, t.touches[0].pageY)
            else {
              var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
                n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)
              S.set(e, n)
            }
          }
          function W(t) {
            var e = t.touches[0].pageX - t.touches[1].pageX,
              n = t.touches[0].pageY - t.touches[1].pageY,
              i = Math.sqrt(e * e + n * n)
            L.set(0, i)
          }
          function j(t) {
            if (1 == t.touches.length) M.set(t.touches[0].pageX, t.touches[0].pageY)
            else {
              var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
                n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)
              M.set(e, n)
            }
            T.subVectors(M, _).multiplyScalar(h.rotateSpeed)
            var i = h.domElement
            I((2 * Math.PI * T.x) / i.clientHeight), D((2 * Math.PI * T.y) / i.clientHeight), _.copy(M)
          }
          function q(t) {
            if (1 == t.touches.length) E.set(t.touches[0].pageX, t.touches[0].pageY)
            else {
              var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
                n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)
              E.set(e, n)
            }
            A.subVectors(E, S).multiplyScalar(h.panSpeed), F(A.x, A.y), S.copy(E)
          }
          function X(t) {
            var e = t.touches[0].pageX - t.touches[1].pageX,
              n = t.touches[0].pageY - t.touches[1].pageY,
              i = Math.sqrt(e * e + n * n)
            R.set(0, i), P.set(0, Math.pow(R.y / L.y, h.zoomSpeed)), z(P.y), L.copy(R)
          }
          function Y(t) {
            if (!1 !== h.enabled)
              switch (t.pointerType) {
                case 'mouse':
                case 'pen':
                  !(function (t) {
                    var e
                    switch (
                      (t.preventDefault(), h.domElement.focus ? h.domElement.focus() : window.focus(), t.button)
                    ) {
                      case 0:
                        e = h.mouseButtons.LEFT
                        break
                      case 1:
                        e = h.mouseButtons.MIDDLE
                        break
                      case 2:
                        e = h.mouseButtons.RIGHT
                        break
                      default:
                        e = -1
                    }
                    switch (e) {
                      case l.DOLLY:
                        if (!1 === h.enableZoom) return
                        !(function (t) {
                          L.set(t.clientX, t.clientY)
                        })(t),
                          (f = m.DOLLY)
                        break
                      case l.ROTATE:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                          if (!1 === h.enablePan) return
                          H(t), (f = m.PAN)
                        } else {
                          if (!1 === h.enableRotate) return
                          U(t), (f = m.ROTATE)
                        }
                        break
                      case l.PAN:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                          if (!1 === h.enableRotate) return
                          U(t), (f = m.ROTATE)
                        } else {
                          if (!1 === h.enablePan) return
                          H(t), (f = m.PAN)
                        }
                        break
                      default:
                        f = m.NONE
                    }
                    f !== m.NONE &&
                      (h.domElement.ownerDocument.addEventListener('pointermove', Z),
                      h.domElement.ownerDocument.addEventListener('pointerup', J),
                      h.dispatchEvent(d))
                  })(t)
              }
          }
          function Z(t) {
            if (!1 !== h.enabled)
              switch (t.pointerType) {
                case 'mouse':
                case 'pen':
                  !(function (t) {
                    if (!1 !== h.enabled)
                      switch ((t.preventDefault(), f)) {
                        case m.ROTATE:
                          if (!1 === h.enableRotate) return
                          !(function (t) {
                            M.set(t.clientX, t.clientY), T.subVectors(M, _).multiplyScalar(h.rotateSpeed)
                            var e = h.domElement
                            I((2 * Math.PI * T.x) / e.clientHeight),
                              D((2 * Math.PI * T.y) / e.clientHeight),
                              _.copy(M),
                              h.update()
                          })(t)
                          break
                        case m.DOLLY:
                          if (!1 === h.enableZoom) return
                          !(function (t) {
                            R.set(t.clientX, t.clientY),
                              P.subVectors(R, L),
                              P.y > 0 ? z(C()) : P.y < 0 && k(C()),
                              L.copy(R),
                              h.update()
                          })(t)
                          break
                        case m.PAN:
                          if (!1 === h.enablePan) return
                          !(function (t) {
                            E.set(t.clientX, t.clientY),
                              A.subVectors(E, S).multiplyScalar(h.panSpeed),
                              F(A.x, A.y),
                              S.copy(E),
                              h.update()
                          })(t)
                      }
                  })(t)
              }
          }
          function J(t) {
            switch (t.pointerType) {
              case 'mouse':
              case 'pen':
                h.domElement.ownerDocument.removeEventListener('pointermove', Z),
                  h.domElement.ownerDocument.removeEventListener('pointerup', J),
                  !1 !== h.enabled && (h.dispatchEvent(p), (f = m.NONE))
            }
          }
          function K(t) {
            !1 === h.enabled ||
              !1 === h.enableZoom ||
              (f !== m.NONE && f !== m.ROTATE) ||
              (t.preventDefault(),
              h.dispatchEvent(d),
              (function (t) {
                t.deltaY < 0 ? k(C()) : t.deltaY > 0 && z(C()), h.update()
              })(t),
              h.dispatchEvent(p))
          }
          function Q(t) {
            !1 !== h.enabled &&
              !1 !== h.enablePan &&
              (function (t) {
                var e = !1
                switch (t.code) {
                  case h.keys.UP:
                    F(0, h.keyPanSpeed), (e = !0)
                    break
                  case h.keys.BOTTOM:
                    F(0, -h.keyPanSpeed), (e = !0)
                    break
                  case h.keys.LEFT:
                    F(h.keyPanSpeed, 0), (e = !0)
                    break
                  case h.keys.RIGHT:
                    F(-h.keyPanSpeed, 0), (e = !0)
                }
                e && (t.preventDefault(), h.update())
              })(t)
          }
          function $(t) {
            if (!1 !== h.enabled) {
              switch ((t.preventDefault(), t.touches.length)) {
                case 1:
                  switch (h.touches.ONE) {
                    case c.ROTATE:
                      if (!1 === h.enableRotate) return
                      G(t), (f = m.TOUCH_ROTATE)
                      break
                    case c.PAN:
                      if (!1 === h.enablePan) return
                      V(t), (f = m.TOUCH_PAN)
                      break
                    default:
                      f = m.NONE
                  }
                  break
                case 2:
                  switch (h.touches.TWO) {
                    case c.DOLLY_PAN:
                      if (!1 === h.enableZoom && !1 === h.enablePan) return
                      !(function (t) {
                        h.enableZoom && W(t), h.enablePan && V(t)
                      })(t),
                        (f = m.TOUCH_DOLLY_PAN)
                      break
                    case c.DOLLY_ROTATE:
                      if (!1 === h.enableZoom && !1 === h.enableRotate) return
                      !(function (t) {
                        h.enableZoom && W(t), h.enableRotate && G(t)
                      })(t),
                        (f = m.TOUCH_DOLLY_ROTATE)
                      break
                    default:
                      f = m.NONE
                  }
                  break
                default:
                  f = m.NONE
              }
              f !== m.NONE && h.dispatchEvent(d)
            }
          }
          function tt(t) {
            if (!1 !== h.enabled)
              switch ((t.preventDefault(), f)) {
                case m.TOUCH_ROTATE:
                  if (!1 === h.enableRotate) return
                  j(t), h.update()
                  break
                case m.TOUCH_PAN:
                  if (!1 === h.enablePan) return
                  q(t), h.update()
                  break
                case m.TOUCH_DOLLY_PAN:
                  if (!1 === h.enableZoom && !1 === h.enablePan) return
                  !(function (t) {
                    h.enableZoom && X(t), h.enablePan && q(t)
                  })(t),
                    h.update()
                  break
                case m.TOUCH_DOLLY_ROTATE:
                  if (!1 === h.enableZoom && !1 === h.enableRotate) return
                  !(function (t) {
                    h.enableZoom && X(t), h.enableRotate && j(t)
                  })(t),
                    h.update()
                  break
                default:
                  f = m.NONE
              }
          }
          function et(t) {
            !1 !== h.enabled && (h.dispatchEvent(p), (f = m.NONE))
          }
          function nt(t) {
            !1 !== h.enabled && t.preventDefault()
          }
          h.domElement.addEventListener('contextmenu', nt),
            h.domElement.addEventListener('pointerdown', Y),
            h.domElement.addEventListener('wheel', K),
            h.domElement.addEventListener('touchstart', $),
            h.domElement.addEventListener('touchend', et),
            h.domElement.addEventListener('touchmove', tt),
            this.update()
        }
        ;(ly.prototype = Object.create(Un.prototype)).constructor = ly
        var cy = function (t, e) {
          ly.call(this, t, e),
            (this.screenSpacePanning = !1),
            (this.mouseButtons.LEFT = l.PAN),
            (this.mouseButtons.RIGHT = l.ROTATE),
            (this.touches.ONE = c.PAN),
            (this.touches.TWO = c.DOLLY_ROTATE)
        }
        ;(cy.prototype = Object.create(Un.prototype)).constructor = cy
        class hy {
          constructor(t, e, n, i, r, s, o) {
            ;(this.scene = t),
              (this.renderer = e),
              (this.camera = n),
              (this.lights = i),
              (this.physics = r),
              (this.load = s),
              (this.factories = o)
          }
          warpSpeed(...t) {
            return (function (t, e, n, i) {
              return new (n || (n = Promise))(function (r, s) {
                function o(t) {
                  try {
                    l(i.next(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function a(t) {
                  try {
                    l(i.throw(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function l(t) {
                  var e
                  t.done
                    ? r(t.value)
                    : ((e = t.value),
                      e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e)
                          })).then(o, a)
                }
                l((i = i.apply(t, e || [])).next())
              })
            })(this, void 0, void 0, function* () {
              let e = {}
              const n = t.filter(t => /^-\w+/.test(t)),
                i = n.length > 0
              if (
                ((0 === t.length || i) &&
                  (t = ['light', 'camera', 'lookAtCenter', 'ground', 'grid', 'orbitControls', 'fog', 'sky']),
                i &&
                  n
                    .map(t => t.substr(1))
                    .forEach(e => {
                      const n = t.indexOf(e)
                      t.splice(n, 1)
                    }),
                t.includes('sky'))
              ) {
                const t = [
                    'varying vec3 vWorldPosition;',
                    '',
                    'void main() {',
                    '',
                    'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
                    'vWorldPosition = worldPosition.xyz;',
                    '',
                    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
                    '',
                    '}'
                  ].join('\n'),
                  e = [
                    'uniform vec3 topColor;',
                    'uniform vec3 bottomColor;',
                    'uniform float offset;',
                    'uniform float exponent;',
                    '',
                    'varying vec3 vWorldPosition;',
                    '',
                    'void main() {',
                    '',
                    'float h = normalize( vWorldPosition + offset ).y;',
                    'gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );',
                    '',
                    '}'
                  ].join('\n'),
                  n = {
                    topColor: { value: new Ar(30719) },
                    bottomColor: { value: new Ar(15595007) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                  }
                var r = new gs(
                  new Yc(500, 32, 15),
                  new _s({ uniforms: n, vertexShader: t, fragmentShader: e, side: x })
                )
                this.scene.add(r)
              }
              if (
                (t.includes('camera') &&
                  (this.camera.position.set(0, 6, 12), (e = Object.assign({ camera: this.camera }, e))),
                t.includes('light'))
              ) {
                const t = 0.4,
                  n = this.lights.hemisphereLight({ skyColor: 16777215, groundColor: 0, intensity: t }),
                  i = this.lights.ambientLight({ color: 16777215, intensity: t }),
                  r = this.lights.directionalLight({ color: 16777215, intensity: t })
                r.position.set(100, 200, 50)
                const s = 20
                ;(r.shadow.camera.top = s),
                  (r.shadow.camera.bottom = -s),
                  (r.shadow.camera.left = -s),
                  (r.shadow.camera.right = s),
                  r.shadow.mapSize.set(1024, 1024)
                const o = { ambientLight: i, directionalLight: r, hemisphereLight: n }
                e = Object.assign({ lights: o }, e)
              }
              if ((t.includes('lookAtCenter') && this.camera.lookAt(this.scene.position), t.includes('ground'))) {
                const n = t.includes('grid'),
                  i =
                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC',
                  r = yield this.load.texture(i)
                ;(r.wrapS = r.wrapT = ft), r.repeat.set(21, 21)
                const s = { name: 'ground', width: 21, height: 21, depth: 1, y: -0.5 },
                  o = { phong: { map: n ? r : null, color: 16777215 } }
                let a
                window.__loadPhysics
                  ? ((a = this.physics.add.ground(s, o)), a.body.setRestitution(1))
                  : (a = this.factories.add.ground(s, o)),
                  (a.receiveShadow = !0),
                  (e = Object.assign({ ground: a }, e))
              }
              if (t.includes('orbitControls')) {
                const t = new ly(
                  this.camera,
                  document.getElementById('enable3d-phaser-canvas') || this.renderer.domElement
                )
                e = Object.assign({ orbitControls: t }, e)
              }
              return e
            })
          }
        }
        var uy = function (t, e) {
          gs.call(this, t), (this.type = 'Reflector')
          var n = this,
            i = void 0 !== (e = e || {}).color ? new Ar(e.color) : new Ar(8355711),
            r = e.textureWidth || 512,
            s = e.textureHeight || 512,
            o = e.clipBias || 0,
            a = e.shader || uy.ReflectorShader,
            l = new ar(),
            c = new ei(),
            h = new ei(),
            u = new ei(),
            d = new Ii(),
            p = new ei(0, 0, -1),
            m = new Kn(),
            f = new ei(),
            g = new ei(),
            v = new Kn(),
            y = new Ii(),
            x = new Ts(),
            b = new Qn(r, s, { minFilter: Mt, magFilter: Mt, format: Ht })
          ;(Vn.isPowerOfTwo(r) && Vn.isPowerOfTwo(s)) || (b.texture.generateMipmaps = !1)
          var w = new _s({
            uniforms: ws.clone(a.uniforms),
            fragmentShader: a.fragmentShader,
            vertexShader: a.vertexShader
          })
          ;(w.uniforms.tDiffuse.value = b.texture),
            (w.uniforms.color.value = i),
            (w.uniforms.textureMatrix.value = y),
            (this.material = w),
            (this.onBeforeRender = function (t, e, i) {
              if (
                (h.setFromMatrixPosition(n.matrixWorld),
                u.setFromMatrixPosition(i.matrixWorld),
                d.extractRotation(n.matrixWorld),
                c.set(0, 0, 1),
                c.applyMatrix4(d),
                f.subVectors(h, u),
                !(f.dot(c) > 0))
              ) {
                f.reflect(c).negate(),
                  f.add(h),
                  d.extractRotation(i.matrixWorld),
                  p.set(0, 0, -1),
                  p.applyMatrix4(d),
                  p.add(u),
                  g.subVectors(h, p),
                  g.reflect(c).negate(),
                  g.add(h),
                  x.position.copy(f),
                  x.up.set(0, 1, 0),
                  x.up.applyMatrix4(d),
                  x.up.reflect(c),
                  x.lookAt(g),
                  (x.far = i.far),
                  x.updateMatrixWorld(),
                  x.projectionMatrix.copy(i.projectionMatrix),
                  y.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                  y.multiply(x.projectionMatrix),
                  y.multiply(x.matrixWorldInverse),
                  y.multiply(n.matrixWorld),
                  l.setFromNormalAndCoplanarPoint(c, h),
                  l.applyMatrix4(x.matrixWorldInverse),
                  m.set(l.normal.x, l.normal.y, l.normal.z, l.constant)
                var r = x.projectionMatrix
                ;(v.x = (Math.sign(m.x) + r.elements[8]) / r.elements[0]),
                  (v.y = (Math.sign(m.y) + r.elements[9]) / r.elements[5]),
                  (v.z = -1),
                  (v.w = (1 + r.elements[10]) / r.elements[14]),
                  m.multiplyScalar(2 / m.dot(v)),
                  (r.elements[2] = m.x),
                  (r.elements[6] = m.y),
                  (r.elements[10] = m.z + 1 - o),
                  (r.elements[14] = m.w),
                  (b.texture.encoding = t.outputEncoding),
                  (n.visible = !1)
                var s = t.getRenderTarget(),
                  a = t.xr.enabled,
                  w = t.shadowMap.autoUpdate
                ;(t.xr.enabled = !1),
                  (t.shadowMap.autoUpdate = !1),
                  t.setRenderTarget(b),
                  t.state.buffers.depth.setMask(!0),
                  !1 === t.autoClear && t.clear(),
                  t.render(e, x),
                  (t.xr.enabled = a),
                  (t.shadowMap.autoUpdate = w),
                  t.setRenderTarget(s)
                var _ = i.viewport
                void 0 !== _ && t.state.viewport(_), (n.visible = !0)
              }
            }),
            (this.getRenderTarget = function () {
              return b
            })
        }
        ;(uy.prototype = Object.create(gs.prototype)),
          (uy.prototype.constructor = uy),
          (uy.ReflectorShader = {
            uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } },
            vertexShader: [
              'uniform mat4 textureMatrix;',
              'varying vec4 vUv;',
              'void main() {',
              '\tvUv = textureMatrix * vec4( position, 1.0 );',
              '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
              '}'
            ].join('\n'),
            fragmentShader: [
              'uniform vec3 color;',
              'uniform sampler2D tDiffuse;',
              'varying vec4 vUv;',
              'float blendOverlay( float base, float blend ) {',
              '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',
              '}',
              'vec3 blendOverlay( vec3 base, vec3 blend ) {',
              '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',
              '}',
              'void main() {',
              '\tvec4 base = texture2DProj( tDiffuse, vUv );',
              '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',
              '}'
            ].join('\n')
          })
        var dy = function (t, e) {
          gs.call(this, t), (this.type = 'Refractor')
          var n = this,
            i = void 0 !== (e = e || {}).color ? new Ar(e.color) : new Ar(8355711),
            r = e.textureWidth || 512,
            s = e.textureHeight || 512,
            o = e.clipBias || 0,
            a = e.shader || dy.RefractorShader,
            l = new Ts()
          ;(l.matrixAutoUpdate = !1), (l.userData.refractor = !0)
          var c = new ar(),
            h = new Ii(),
            u = new Qn(r, s, { minFilter: Mt, magFilter: Mt, format: Ht })
          ;(Vn.isPowerOfTwo(r) && Vn.isPowerOfTwo(s)) || (u.texture.generateMipmaps = !1),
            (this.material = new _s({
              uniforms: ws.clone(a.uniforms),
              vertexShader: a.vertexShader,
              fragmentShader: a.fragmentShader,
              transparent: !0
            })),
            (this.material.uniforms.color.value = i),
            (this.material.uniforms.tDiffuse.value = u.texture),
            (this.material.uniforms.textureMatrix.value = h)
          var d,
            p,
            m,
            f,
            g,
            v,
            y,
            x,
            b =
              ((d = new ei()),
              (p = new ei()),
              (m = new Ii()),
              (f = new ei()),
              (g = new ei()),
              function (t) {
                return (
                  d.setFromMatrixPosition(n.matrixWorld),
                  p.setFromMatrixPosition(t.matrixWorld),
                  f.subVectors(d, p),
                  m.extractRotation(n.matrixWorld),
                  g.set(0, 0, 1),
                  g.applyMatrix4(m),
                  f.dot(g) < 0
                )
              }),
            w = (function () {
              var t = new ei(),
                e = new ei(),
                i = new ti(),
                r = new ei()
              return function () {
                n.matrixWorld.decompose(e, i, r),
                  t.set(0, 0, 1).applyQuaternion(i).normalize(),
                  t.negate(),
                  c.setFromNormalAndCoplanarPoint(t, e)
              }
            })(),
            _ =
              ((v = new ar()),
              (y = new Kn()),
              (x = new Kn()),
              function (t) {
                l.matrixWorld.copy(t.matrixWorld),
                  l.matrixWorldInverse.copy(l.matrixWorld).invert(),
                  l.projectionMatrix.copy(t.projectionMatrix),
                  (l.far = t.far),
                  v.copy(c),
                  v.applyMatrix4(l.matrixWorldInverse),
                  y.set(v.normal.x, v.normal.y, v.normal.z, v.constant)
                var e = l.projectionMatrix
                ;(x.x = (Math.sign(y.x) + e.elements[8]) / e.elements[0]),
                  (x.y = (Math.sign(y.y) + e.elements[9]) / e.elements[5]),
                  (x.z = -1),
                  (x.w = (1 + e.elements[10]) / e.elements[14]),
                  y.multiplyScalar(2 / y.dot(x)),
                  (e.elements[2] = y.x),
                  (e.elements[6] = y.y),
                  (e.elements[10] = y.z + 1 - o),
                  (e.elements[14] = y.w)
              })
          ;(this.onBeforeRender = function (t, e, i) {
            ;(u.texture.encoding = t.outputEncoding),
              !0 !== i.userData.refractor &&
                1 != !b(i) &&
                (w(),
                (function (t) {
                  h.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                    h.multiply(t.projectionMatrix),
                    h.multiply(t.matrixWorldInverse),
                    h.multiply(n.matrixWorld)
                })(i),
                _(i),
                (function (t, e, i) {
                  n.visible = !1
                  var r = t.getRenderTarget(),
                    s = t.xr.enabled,
                    o = t.shadowMap.autoUpdate
                  ;(t.xr.enabled = !1),
                    (t.shadowMap.autoUpdate = !1),
                    t.setRenderTarget(u),
                    !1 === t.autoClear && t.clear(),
                    t.render(e, l),
                    (t.xr.enabled = s),
                    (t.shadowMap.autoUpdate = o),
                    t.setRenderTarget(r)
                  var a = i.viewport
                  void 0 !== a && t.state.viewport(a), (n.visible = !0)
                })(t, e, i))
          }),
            (this.getRenderTarget = function () {
              return u
            })
        }
        ;(dy.prototype = Object.create(gs.prototype)),
          (dy.prototype.constructor = dy),
          (dy.RefractorShader = {
            uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } },
            vertexShader: [
              'uniform mat4 textureMatrix;',
              'varying vec4 vUv;',
              'void main() {',
              '\tvUv = textureMatrix * vec4( position, 1.0 );',
              '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
              '}'
            ].join('\n'),
            fragmentShader: [
              'uniform vec3 color;',
              'uniform sampler2D tDiffuse;',
              'varying vec4 vUv;',
              'float blendOverlay( float base, float blend ) {',
              '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',
              '}',
              'vec3 blendOverlay( vec3 base, vec3 blend ) {',
              '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',
              '}',
              'void main() {',
              '\tvec4 base = texture2DProj( tDiffuse, vUv );',
              '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',
              '}'
            ].join('\n')
          })
        var py = function (t, e) {
          gs.call(this, t), (this.type = 'Water')
          var n = this,
            i = void 0 !== (e = e || {}).color ? new Ar(e.color) : new Ar(16777215),
            r = e.textureWidth || 512,
            s = e.textureHeight || 512,
            o = e.clipBias || 0,
            a = e.flowDirection || new Wn(1, 0),
            l = e.flowSpeed || 0.03,
            c = e.reflectivity || 0.02,
            h = e.scale || 1,
            u = e.shader || py.WaterShader,
            d = void 0 !== e.encoding ? e.encoding : tn,
            p = new kh(),
            m = e.flowMap || void 0,
            f = e.normalMap0 || p.load('textures/water/Water_1_M_Normal.jpg'),
            g = e.normalMap1 || p.load('textures/water/Water_2_M_Normal.jpg'),
            v = 0.15,
            y = 0.075,
            x = new Ii(),
            b = new Ku()
          if (void 0 !== uy)
            if (void 0 !== dy) {
              var w = new uy(t, { textureWidth: r, textureHeight: s, clipBias: o, encoding: d }),
                _ = new dy(t, { textureWidth: r, textureHeight: s, clipBias: o, encoding: d })
              ;(w.matrixAutoUpdate = !1),
                (_.matrixAutoUpdate = !1),
                (this.material = new _s({
                  uniforms: ws.merge([Fs.fog, u.uniforms]),
                  vertexShader: u.vertexShader,
                  fragmentShader: u.fragmentShader,
                  transparent: !0,
                  fog: !0
                })),
                void 0 !== m
                  ? ((this.material.defines.USE_FLOWMAP = ''),
                    (this.material.uniforms.tFlowMap = { type: 't', value: m }))
                  : (this.material.uniforms.flowDirection = { type: 'v2', value: a }),
                (f.wrapS = f.wrapT = ft),
                (g.wrapS = g.wrapT = ft),
                (this.material.uniforms.tReflectionMap.value = w.getRenderTarget().texture),
                (this.material.uniforms.tRefractionMap.value = _.getRenderTarget().texture),
                (this.material.uniforms.tNormalMap0.value = f),
                (this.material.uniforms.tNormalMap1.value = g),
                (this.material.uniforms.color.value = i),
                (this.material.uniforms.reflectivity.value = c),
                (this.material.uniforms.textureMatrix.value = x),
                (this.material.uniforms.config.value.x = 0),
                (this.material.uniforms.config.value.y = y),
                (this.material.uniforms.config.value.z = y),
                (this.material.uniforms.config.value.w = h),
                (this.onBeforeRender = function (t, e, i) {
                  var r, s
                  !(function (t) {
                    x.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                      x.multiply(t.projectionMatrix),
                      x.multiply(t.matrixWorldInverse),
                      x.multiply(n.matrixWorld)
                  })(i),
                    (r = b.getDelta()),
                    ((s = n.material.uniforms.config).value.x += l * r),
                    (s.value.y = s.value.x + y),
                    s.value.x >= v ? ((s.value.x = 0), (s.value.y = y)) : s.value.y >= v && (s.value.y = s.value.y - v),
                    (n.visible = !1),
                    w.matrixWorld.copy(n.matrixWorld),
                    _.matrixWorld.copy(n.matrixWorld),
                    w.onBeforeRender(t, e, i),
                    _.onBeforeRender(t, e, i),
                    (n.visible = !0)
                })
            } else console.error('THREE.Water: Required component Refractor not found.')
          else console.error('THREE.Water: Required component Reflector not found.')
        }
        ;(py.prototype = Object.create(gs.prototype)),
          (py.prototype.constructor = py),
          (py.WaterShader = {
            uniforms: {
              color: { type: 'c', value: null },
              reflectivity: { type: 'f', value: 0 },
              tReflectionMap: { type: 't', value: null },
              tRefractionMap: { type: 't', value: null },
              tNormalMap0: { type: 't', value: null },
              tNormalMap1: { type: 't', value: null },
              textureMatrix: { type: 'm4', value: null },
              config: { type: 'v4', value: new Kn() }
            },
            vertexShader: [
              '#include <common>',
              '#include <fog_pars_vertex>',
              '#include <logdepthbuf_pars_vertex>',
              'uniform mat4 textureMatrix;',
              'varying vec4 vCoord;',
              'varying vec2 vUv;',
              'varying vec3 vToEye;',
              'void main() {',
              '\tvUv = uv;',
              '\tvCoord = textureMatrix * vec4( position, 1.0 );',
              '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
              '\tvToEye = cameraPosition - worldPosition.xyz;',
              '\tvec4 mvPosition =  viewMatrix * worldPosition;',
              '\tgl_Position = projectionMatrix * mvPosition;',
              '\t#include <logdepthbuf_vertex>',
              '\t#include <fog_vertex>',
              '}'
            ].join('\n'),
            fragmentShader: [
              '#include <common>',
              '#include <fog_pars_fragment>',
              '#include <logdepthbuf_pars_fragment>',
              'uniform sampler2D tReflectionMap;',
              'uniform sampler2D tRefractionMap;',
              'uniform sampler2D tNormalMap0;',
              'uniform sampler2D tNormalMap1;',
              '#ifdef USE_FLOWMAP',
              '\tuniform sampler2D tFlowMap;',
              '#else',
              '\tuniform vec2 flowDirection;',
              '#endif',
              'uniform vec3 color;',
              'uniform float reflectivity;',
              'uniform vec4 config;',
              'varying vec4 vCoord;',
              'varying vec2 vUv;',
              'varying vec3 vToEye;',
              'void main() {',
              '\t#include <logdepthbuf_fragment>',
              '\tfloat flowMapOffset0 = config.x;',
              '\tfloat flowMapOffset1 = config.y;',
              '\tfloat halfCycle = config.z;',
              '\tfloat scale = config.w;',
              '\tvec3 toEye = normalize( vToEye );',
              '\tvec2 flow;',
              '\t#ifdef USE_FLOWMAP',
              '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',
              '\t#else',
              '\t\tflow = flowDirection;',
              '\t#endif',
              '\tflow.x *= - 1.0;',
              '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',
              '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',
              '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',
              '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',
              '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',
              '\tfloat theta = max( dot( toEye, normal ), 0.0 );',
              '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',
              '\tvec3 coord = vCoord.xyz / vCoord.w;',
              '\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;',
              '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',
              '\tvec4 refractColor = texture2D( tRefractionMap, uv );',
              '\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',
              '\t#include <tonemapping_fragment>',
              '\t#include <encodings_fragment>',
              '\t#include <fog_fragment>',
              '}'
            ].join('\n')
          })
        class my {
          constructor(t, e, n) {
            ;(this.scene = t), (this.renderer = e), (this.factories = n)
          }
          water(t = {}) {
            ;((t, e, i = {}) => {
              const {
                  width: r = 20,
                  height: s = 20,
                  x: o = 0,
                  y: a = 0,
                  z: l = 0,
                  color: c = '#ffffff',
                  scale: h = 4,
                  flowX: u = 1,
                  flowY: d = 1,
                  normalMap0: p,
                  normalMap1: m
                } = i,
                f = new gs(new Ns(r, s), new rh({ color: 30654, transparent: !0, opacity: 0.8 }))
              f.position.set(o, a, l), (f.rotation.x = -0.5 * Math.PI), t.add(f)
              const g = new Ns(r, s),
                v = new n.Water2(g, {
                  color: c,
                  scale: h,
                  flowDirection: new Wn(u, d),
                  textureWidth: 1024,
                  textureHeight: 1024,
                  normalMap0: p,
                  normalMap1: m,
                  encoding: e.outputEncoding
                })
              v.position.set(o, a + 0.1, l), (v.rotation.x = -0.5 * Math.PI), t.add(v)
            })(this.scene, this.renderer, t)
          }
          textureCube(t) {
            6 !== t.length && console.log('[enable3d] You need to pass 6 urls to textureCube()')
            const e = new fy()
            return (
              t.forEach((t, n) => {
                t.wrapS = t.wrapT = ft
                const i = this.factories.add.material({ phong: { map: t } })
                e.materials[n] = i
              }),
              e
            )
          }
        }
        class fy {
          constructor() {
            this.materials = new Array(6)
          }
          get texture() {
            return {
              left: this.getTexture(0),
              right: this.getTexture(1),
              up: this.getTexture(2),
              down: this.getTexture(3),
              front: this.getTexture(4),
              back: this.getTexture(5)
            }
          }
          getTexture(t) {
            return this.materials[t].map
          }
        }
        class gy {
          constructor(t, e) {
            ;(this.camera = t), (this.renderer = e)
          }
          static geometryToBufferGeometry(t) {
            return t.isGeometry ? sy(new Qr(), t) : t
          }
          static bufferGeometryToGeometry(t) {
            return t.isBufferGeometry ? new ey().fromBufferGeometry(t) : t
          }
          fromSVGtoShape(t, e = !1, n) {
            if (t) {
              const i = new Xv(),
                r = []
              return (
                i.parse(t).paths.forEach(t => {
                  t.toShapes(e, n).forEach(t => {
                    r.push(t)
                  })
                }),
                r
              )
            }
            return []
          }
          from3dto2d(t) {
            const e = new ei(t.x, t.y, t.z),
              n = this.renderer.domElement
            this.camera.updateMatrixWorld(), e.project(this.camera)
            const i = Math.round((e.x + 1) * (n.width / 2)),
              r = Math.round((1 - e.y) * (n.height / 2))
            return new Wn(i, r)
          }
          from2dto3d(t, e, n) {
            var i
            if (!this.tmpPlane) {
              const t = new Ns(1e4, 1e4),
                e = new Lr({ transparent: !0, opacity: 0.25 })
              ;(this.tmpPlane = new gs(t, e)), (this.tmpPlane.name = '_tmp_raycast_plane')
            }
            let r
            this.tmpRaycaster || (this.tmpRaycaster = new Rd()),
              this.tmpVector3 || (this.tmpVector3 = new ei()),
              this.tmpPlane.setRotationFromEuler(this.camera.rotation)
            const s = this.camera.position
            this.tmpPlane.position.set(s.x, s.y, s.z),
              this.camera.getWorldDirection(this.tmpVector3),
              this.tmpPlane.position.add(this.tmpVector3.clone().multiplyScalar(n)),
              this.tmpPlane.updateMatrix(),
              this.tmpPlane.updateMatrixWorld(!0),
              this.tmpRaycaster.setFromCamera({ x: t, y: e }, this.camera)
            const o = this.tmpRaycaster.intersectObjects([this.tmpPlane])
            return (
              '_tmp_raycast_plane' === (null === (i = o[0]) || void 0 === i ? void 0 : i.object.name) &&
                (r = o[0].point),
              r
            )
          }
        }
        const vy = {
          Handedness: Object.freeze({ NONE: 'none', LEFT: 'left', RIGHT: 'right' }),
          ComponentState: Object.freeze({ DEFAULT: 'default', TOUCHED: 'touched', PRESSED: 'pressed' }),
          ComponentProperty: Object.freeze({ BUTTON: 'button', X_AXIS: 'xAxis', Y_AXIS: 'yAxis', STATE: 'state' }),
          ComponentType: Object.freeze({
            TRIGGER: 'trigger',
            SQUEEZE: 'squeeze',
            TOUCHPAD: 'touchpad',
            THUMBSTICK: 'thumbstick',
            BUTTON: 'button'
          }),
          ButtonTouchThreshold: 0.05,
          AxisTouchThreshold: 0.1,
          VisualResponseProperty: Object.freeze({ TRANSFORM: 'transform', VISIBILITY: 'visibility' })
        }
        async function yy(t) {
          const e = await fetch(t)
          if (e.ok) return e.json()
          throw new Error(e.statusText)
        }
        const xy = { xAxis: 0, yAxis: 0, button: 0, state: vy.ComponentState.DEFAULT }
        class by {
          constructor(t) {
            ;(this.componentProperty = t.componentProperty),
              (this.states = t.states),
              (this.valueNodeName = t.valueNodeName),
              (this.valueNodeProperty = t.valueNodeProperty),
              this.valueNodeProperty === vy.VisualResponseProperty.TRANSFORM &&
                ((this.minNodeName = t.minNodeName), (this.maxNodeName = t.maxNodeName)),
              (this.value = 0),
              this.updateFromComponent(xy)
          }
          updateFromComponent({ xAxis: t, yAxis: e, button: n, state: i }) {
            const { normalizedXAxis: r, normalizedYAxis: s } = (function (t = 0, e = 0) {
              let n = t,
                i = e
              if (Math.sqrt(t * t + e * e) > 1) {
                const r = Math.atan2(e, t)
                ;(n = Math.cos(r)), (i = Math.sin(r))
              }
              return { normalizedXAxis: 0.5 * n + 0.5, normalizedYAxis: 0.5 * i + 0.5 }
            })(t, e)
            switch (this.componentProperty) {
              case vy.ComponentProperty.X_AXIS:
                this.value = this.states.includes(i) ? r : 0.5
                break
              case vy.ComponentProperty.Y_AXIS:
                this.value = this.states.includes(i) ? s : 0.5
                break
              case vy.ComponentProperty.BUTTON:
                this.value = this.states.includes(i) ? n : 0
                break
              case vy.ComponentProperty.STATE:
                this.valueNodeProperty === vy.VisualResponseProperty.VISIBILITY
                  ? (this.value = this.states.includes(i))
                  : (this.value = this.states.includes(i) ? 1 : 0)
                break
              default:
                throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)
            }
          }
        }
        class wy {
          constructor(t, e) {
            if (!(t && e && e.visualResponses && e.gamepadIndices && 0 !== Object.keys(e.gamepadIndices).length))
              throw new Error('Invalid arguments supplied')
            ;(this.id = t),
              (this.type = e.type),
              (this.rootNodeName = e.rootNodeName),
              (this.touchPointNodeName = e.touchPointNodeName),
              (this.visualResponses = {}),
              Object.keys(e.visualResponses).forEach(t => {
                const n = new by(e.visualResponses[t])
                this.visualResponses[t] = n
              }),
              (this.gamepadIndices = Object.assign({}, e.gamepadIndices)),
              (this.values = {
                state: vy.ComponentState.DEFAULT,
                button: void 0 !== this.gamepadIndices.button ? 0 : void 0,
                xAxis: void 0 !== this.gamepadIndices.xAxis ? 0 : void 0,
                yAxis: void 0 !== this.gamepadIndices.yAxis ? 0 : void 0
              })
          }
          get data() {
            return { id: this.id, ...this.values }
          }
          updateFromGamepad(t) {
            if (
              ((this.values.state = vy.ComponentState.DEFAULT),
              void 0 !== this.gamepadIndices.button && t.buttons.length > this.gamepadIndices.button)
            ) {
              const e = t.buttons[this.gamepadIndices.button]
              ;(this.values.button = e.value),
                (this.values.button = this.values.button < 0 ? 0 : this.values.button),
                (this.values.button = this.values.button > 1 ? 1 : this.values.button),
                e.pressed || 1 === this.values.button
                  ? (this.values.state = vy.ComponentState.PRESSED)
                  : (e.touched || this.values.button > vy.ButtonTouchThreshold) &&
                    (this.values.state = vy.ComponentState.TOUCHED)
            }
            void 0 !== this.gamepadIndices.xAxis &&
              t.axes.length > this.gamepadIndices.xAxis &&
              ((this.values.xAxis = t.axes[this.gamepadIndices.xAxis]),
              (this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis),
              (this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis),
              this.values.state === vy.ComponentState.DEFAULT &&
                Math.abs(this.values.xAxis) > vy.AxisTouchThreshold &&
                (this.values.state = vy.ComponentState.TOUCHED)),
              void 0 !== this.gamepadIndices.yAxis &&
                t.axes.length > this.gamepadIndices.yAxis &&
                ((this.values.yAxis = t.axes[this.gamepadIndices.yAxis]),
                (this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis),
                (this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis),
                this.values.state === vy.ComponentState.DEFAULT &&
                  Math.abs(this.values.yAxis) > vy.AxisTouchThreshold &&
                  (this.values.state = vy.ComponentState.TOUCHED)),
              Object.values(this.visualResponses).forEach(t => {
                t.updateFromComponent(this.values)
              })
          }
        }
        class _y {
          constructor(t, e, n) {
            if (!t) throw new Error('No xrInputSource supplied')
            if (!e) throw new Error('No profile supplied')
            ;(this.xrInputSource = t),
              (this.assetUrl = n),
              (this.id = e.profileId),
              (this.layoutDescription = e.layouts[t.handedness]),
              (this.components = {}),
              Object.keys(this.layoutDescription.components).forEach(t => {
                const e = this.layoutDescription.components[t]
                this.components[t] = new wy(t, e)
              }),
              this.updateFromGamepad()
          }
          get gripSpace() {
            return this.xrInputSource.gripSpace
          }
          get targetRaySpace() {
            return this.xrInputSource.targetRaySpace
          }
          get data() {
            const t = []
            return (
              Object.values(this.components).forEach(e => {
                t.push(e.data)
              }),
              t
            )
          }
          updateFromGamepad() {
            Object.values(this.components).forEach(t => {
              t.updateFromGamepad(this.xrInputSource.gamepad)
            })
          }
        }
        function My() {
          ir.call(this), (this.motionController = null), (this.envMap = null)
        }
        function Ty(t, e) {
          !(function (t, e) {
            Object.values(t.components).forEach(t => {
              const { type: n, touchPointNodeName: i, visualResponses: r } = t
              if (n === vy.ComponentType.TOUCHPAD)
                if (((t.touchPointNode = e.getObjectByName(i)), t.touchPointNode)) {
                  const e = new gs(new Yc(0.001), new Lr({ color: 255 }))
                  t.touchPointNode.add(e)
                } else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`)
              Object.values(r).forEach(t => {
                const { valueNodeName: n, minNodeName: i, maxNodeName: r, valueNodeProperty: s } = t
                if (s === vy.VisualResponseProperty.TRANSFORM) {
                  if (((t.minNode = e.getObjectByName(i)), (t.maxNode = e.getObjectByName(r)), !t.minNode))
                    return void console.warn(`Could not find ${i} in the model`)
                  if (!t.maxNode) return void console.warn(`Could not find ${r} in the model`)
                }
                ;(t.valueNode = e.getObjectByName(n)), t.valueNode || console.warn(`Could not find ${n} in the model`)
              })
            })
          })(t.motionController, e),
            t.envMap &&
              e.traverse(e => {
                e.isMesh && ((e.material.envMap = t.envMap), (e.material.needsUpdate = !0))
              }),
            t.add(e)
        }
        My.prototype = Object.assign(Object.create(ir.prototype), {
          constructor: My,
          setEnvironmentMap: function (t) {
            return (
              this.envMap == t ||
                ((this.envMap = t),
                this.traverse(t => {
                  t.isMesh && ((t.material.envMap = this.envMap), (t.material.needsUpdate = !0))
                })),
              this
            )
          },
          updateMatrixWorld: function (t) {
            ir.prototype.updateMatrixWorld.call(this, t),
              this.motionController &&
                (this.motionController.updateFromGamepad(),
                Object.values(this.motionController.components).forEach(t => {
                  Object.values(t.visualResponses).forEach(t => {
                    const { valueNode: e, minNode: n, maxNode: i, value: r, valueNodeProperty: s } = t
                    e &&
                      (s === vy.VisualResponseProperty.VISIBILITY
                        ? (e.visible = r)
                        : s === vy.VisualResponseProperty.TRANSFORM &&
                          (e.quaternion.slerpQuaternions(n.quaternion, i.quaternion, r),
                          e.position.lerpVectors(n.position, i.position, r)))
                  })
                }))
          }
        })
        var Sy = (function () {
          function t(t = null) {
            ;(this.gltfLoader = t),
              (this.path = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles'),
              (this._assetCache = {}),
              this.gltfLoader || (this.gltfLoader = new qv())
          }
          return (
            (t.prototype = {
              constructor: t,
              createControllerModel: function (t) {
                const e = new My()
                let n = null
                return (
                  t.addEventListener('connected', t => {
                    const i = t.data
                    'tracked-pointer' === i.targetRayMode &&
                      i.gamepad &&
                      (async function (t, e, n = null, i = !0) {
                        if (!t) throw new Error('No xrInputSource supplied')
                        if (!e) throw new Error('No basePath supplied')
                        const r = await (async function (t) {
                          if (!t) throw new Error('No basePath supplied')
                          return await yy(`${t}/profilesList.json`)
                        })(e)
                        let s
                        if (
                          (t.profiles.some(t => {
                            const n = r[t]
                            return (
                              n && (s = { profileId: t, profilePath: `${e}/${n.path}`, deprecated: !!n.deprecated }),
                              !!s
                            )
                          }),
                          !s)
                        ) {
                          if (!n) throw new Error('No matching profile name found')
                          const t = r[n]
                          if (!t) throw new Error(`No matching profile name found and default profile "${n}" missing.`)
                          s = { profileId: n, profilePath: `${e}/${t.path}`, deprecated: !!t.deprecated }
                        }
                        const o = await yy(s.profilePath)
                        let a
                        if (i) {
                          let e
                          if (
                            ((e =
                              'any' === t.handedness ? o.layouts[Object.keys(o.layouts)[0]] : o.layouts[t.handedness]),
                            !e)
                          )
                            throw new Error(`No matching handedness, ${t.handedness}, in profile ${s.profileId}`)
                          e.assetPath && (a = s.profilePath.replace('profile.json', e.assetPath))
                        }
                        return { profile: o, assetPath: a }
                      })(i, this.path, 'generic-trigger')
                        .then(({ profile: t, assetPath: r }) => {
                          e.motionController = new _y(i, t, r)
                          const s = this._assetCache[e.motionController.assetUrl]
                          if (s) (n = s.scene.clone()), Ty(e, n)
                          else {
                            if (!this.gltfLoader) throw new Error('GLTFLoader not set.')
                            this.gltfLoader.setPath(''),
                              this.gltfLoader.load(
                                e.motionController.assetUrl,
                                t => {
                                  ;(this._assetCache[e.motionController.assetUrl] = t), (n = t.scene.clone()), Ty(e, n)
                                },
                                null,
                                () => {
                                  throw new Error(`Asset ${e.motionController.assetUrl} missing or malformed.`)
                                }
                              )
                          }
                        })
                        .catch(t => {
                          console.warn(t)
                        })
                  }),
                  t.addEventListener('disconnected', () => {
                    ;(e.motionController = null), e.remove(n), (n = null)
                  }),
                  e
                )
              }
            }),
            t
          )
        })()
        class Ey {
          constructor(t, e, n) {
            ;(this._renderer = t),
              (this._scene = e),
              (this._camera = n),
              (this.controllerModelFactory = new Sy()),
              (this.cameraGroup = new Va()),
              this.cameraGroup.add(n),
              e.add(this.cameraGroup),
              (t.xr.enabled = !0)
            const i = class {
              static createButton(t, e) {
                e &&
                  console.error(
                    'THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.'
                  )
                const n = document.createElement('button')
                function i(t) {
                  ;(t.style.position = 'absolute'),
                    (t.style.bottom = '20px'),
                    (t.style.padding = '12px 6px'),
                    (t.style.border = '1px solid #fff'),
                    (t.style.borderRadius = '4px'),
                    (t.style.background = 'rgba(0,0,0,0.1)'),
                    (t.style.color = '#fff'),
                    (t.style.font = 'normal 13px sans-serif'),
                    (t.style.textAlign = 'center'),
                    (t.style.opacity = '0.5'),
                    (t.style.outline = 'none'),
                    (t.style.zIndex = '999')
                }
                if ('xr' in navigator)
                  return (
                    (n.id = 'VRButton'),
                    (n.style.display = 'none'),
                    i(n),
                    navigator.xr.isSessionSupported('immersive-vr').then(function (e) {
                      e
                        ? (function () {
                            let e = null
                            async function i(i) {
                              i.addEventListener('end', r),
                                await t.xr.setSession(i),
                                (n.textContent = 'EXIT VR'),
                                (e = i)
                            }
                            function r() {
                              e.removeEventListener('end', r), (n.textContent = 'ENTER VR'), (e = null)
                            }
                            ;(n.style.display = ''),
                              (n.style.cursor = 'pointer'),
                              (n.style.left = 'calc(50% - 50px)'),
                              (n.style.width = '100px'),
                              (n.textContent = 'ENTER VR'),
                              (n.onmouseenter = function () {
                                n.style.opacity = '1.0'
                              }),
                              (n.onmouseleave = function () {
                                n.style.opacity = '0.5'
                              }),
                              (n.onclick = function () {
                                if (null === e) {
                                  const t = { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] }
                                  navigator.xr.requestSession('immersive-vr', t).then(i)
                                } else e.end()
                              })
                          })()
                        : ((n.style.display = ''),
                          (n.style.cursor = 'auto'),
                          (n.style.left = 'calc(50% - 75px)'),
                          (n.style.width = '150px'),
                          (n.onmouseenter = null),
                          (n.onmouseleave = null),
                          (n.onclick = null),
                          (n.textContent = 'VR NOT SUPPORTED'))
                    }),
                    n
                  )
                {
                  const t = document.createElement('a')
                  return (
                    !1 === window.isSecureContext
                      ? ((t.href = document.location.href.replace(/^http:/, 'https:')),
                        (t.innerHTML = 'WEBXR NEEDS HTTPS'))
                      : ((t.href = 'https://immersiveweb.dev/'), (t.innerHTML = 'WEBXR NOT AVAILABLE')),
                    (t.style.left = 'calc(50% - 90px)'),
                    (t.style.width = '180px'),
                    (t.style.textDecoration = 'none'),
                    i(t),
                    t
                  )
                }
              }
            }.createButton(t)
            ;(i.style.cssText += 'background: rgba(0, 0, 0, 0.8); '), document.body.appendChild(i)
          }
          get isPresenting() {
            var t, e
            return !!(null === (e = null === (t = this._renderer) || void 0 === t ? void 0 : t.xr) || void 0 === e
              ? void 0
              : e.isPresenting)
          }
          getController(t) {
            const e = this._renderer.xr.getController(t)
            return this.cameraGroup.add(e), e
          }
          getControllerGrip(t) {
            const e = this._renderer.xr.getControllerGrip(t),
              n = this.controllerModelFactory.createControllerModel(e)
            return e.add(n), this.cameraGroup.add(e), e
          }
          getControllerRay(t) {
            const { targetRayMode: e } = t
            if ('tracked-pointer' === e) {
              const t = new Qr()
              return (
                t.setAttribute('position', new Ur([0, 0, 0, 0, 0, -1], 3)),
                t.setAttribute('color', new Ur([1, 0, 0, 1, 1, 1], 3)),
                new Hl(t, new Nl({ vertexColors: !0 }))
              )
            }
            if ('gaze' === e)
              return new gs(
                new qc(0.02, 0.04, 32).translate(0, 0, -1),
                new Lr({ color: 'red', opacity: 0.5, transparent: !0 })
              )
          }
          get camera() {
            return this.WebXRCamera
          }
          get WebXRCamera() {
            var t
            return {
              group: this.cameraGroup,
              position: null === (t = this.cameraGroup) || void 0 === t ? void 0 : t.position,
              rotation: this.isPresenting ? this._renderer.xr.getCamera(this._camera).rotation : void 0,
              getWorldDirection: t =>
                this.isPresenting ? this._renderer.xr.getCamera(this._camera).getWorldDirection(t) : void 0
            }
          }
        }
        class Ay {
          constructor(t, e, n, i, r, s = 0) {
            ;(this.a = t),
              (this.b = e),
              (this.c = n),
              (this.normal = i && i.isVector3 ? i : new ei()),
              (this.vertexNormals = Array.isArray(i) ? i : []),
              (this.color = r && r.isColor ? r : new Ar()),
              (this.vertexColors = Array.isArray(r) ? r : []),
              (this.materialIndex = s)
          }
          clone() {
            return new this.constructor().copy(this)
          }
          copy(t) {
            ;(this.a = t.a),
              (this.b = t.b),
              (this.c = t.c),
              this.normal.copy(t.normal),
              this.color.copy(t.color),
              (this.materialIndex = t.materialIndex)
            for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone()
            for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone()
            return this
          }
        }
        class Ly {
          static toGeometry(t, e) {
            ;(t.geometry = gy.bufferGeometryToGeometry(t.geometry)),
              (e.geometry = gy.bufferGeometryToGeometry(e.geometry))
          }
          static toBufferGeometry(t) {
            t.geometry = gy.geometryToBufferGeometry(t.geometry)
          }
          static union(t, e) {
            this.toGeometry(t, e)
            const n = this.doCSG(t, e, 'union')
            return this.toBufferGeometry(n), n
          }
          static subtract(t, e) {
            this.toGeometry(t, e)
            const n = this.doCSG(t, e, 'subtract')
            return this.toBufferGeometry(n), n
          }
          static intersect(t, e) {
            this.toGeometry(t, e)
            const n = this.doCSG(t, e, 'intersect')
            return this.toBufferGeometry(n), n
          }
          static doCSG(t, e, n) {
            t.updateMatrix(), e.updateMatrix()
            const i = Ry.fromMesh(t),
              r = Ry.fromMesh(e),
              s = i[n](r)
            return Ry.toMesh(s, t.matrix)
          }
        }
        class Ry {
          constructor() {
            this.polygons = []
          }
          static fromPolygons(t) {
            const e = new Ry()
            return (e.polygons = t), e
          }
          static fromGeometry(t) {
            t.isBufferGeometry && (t = new ey().fromBufferGeometry(t))
            const e = t.faces,
              n = t.vertices,
              i = [],
              r = ['a', 'b', 'c']
            for (let s = 0; s < e.length; s++) {
              const o = e[s],
                a = []
              for (let e = 0; e < 3; e++) {
                const i =
                  void 0 !== t.faceVertexUvs[0][s] && void 0 !== t.faceVertexUvs[0][s][e]
                    ? t.faceVertexUvs[0][s][e]
                    : void 0
                a.push(new Cy(n[o[r[e]]], o.vertexNormals[e], i))
              }
              i.push(new Dy(a))
            }
            return Ry.fromPolygons(i)
          }
          static fromMesh(t) {
            const e = Ry.fromGeometry(t.geometry)
            Ry._tmpm3.getNormalMatrix(t.matrix)
            for (const n of e.polygons)
              for (const e of n.vertices) e.pos.applyMatrix4(t.matrix), e.normal.applyMatrix3(Ry._tmpm3)
            return e
          }
          static toMesh(t, e) {
            const n = new ey(),
              i = t.polygons,
              r = n.vertices,
              s = n.faceVertexUvs[0]
            for (const t of i) {
              const e = t.vertices,
                i = r.length,
                o = e.length
              for (const t of e) r.push(new ei().copy(t.pos))
              for (let r = 3; r <= o; r++) {
                const o = new Ay(i, i + r - 2, i + r - 1),
                  a = []
                s.push(a)
                const l = o.vertexNormals
                l.push(new ei().copy(e[0].normal)),
                  l.push(new ei().copy(e[r - 2].normal)),
                  l.push(new ei().copy(e[r - 1].normal)),
                  e[0].uv &&
                    e[r - 2].uv &&
                    e[r - 1].uv &&
                    (a.push(new ei().copy(e[0].uv)),
                    a.push(new ei().copy(e[r - 2].uv)),
                    a.push(new ei().copy(e[r - 1].uv))),
                  (o.normal = new ei().copy(t.plane.normal)),
                  n.faces.push(o)
              }
            }
            const o = parseInt(a) >= 123 ? new Ii().copy(e).invert() : new Ii().getInverse(e)
            n.applyMatrix4(o),
              (n.verticesNeedUpdate = n.elementsNeedUpdate = n.normalsNeedUpdate = !0),
              n.computeBoundingSphere(),
              n.computeBoundingBox()
            const l = new gs(n)
            return l.matrix.copy(e), l.matrix.decompose(l.position, l.rotation, l.scale), l.updateMatrixWorld(), l
          }
          static iEval(t, e = 0) {
            var n
            if ('string' == typeof t) Ry.currentOp = t
            else if (t instanceof Array) for (const e of t) Ry.iEval(e, 0)
            else if ('object' == typeof t) {
              const e = Ry.currentOp
              t.updateMatrix(),
                t.updateMatrixWorld(),
                Ry.sourceMesh
                  ? ((Ry.nextPrim = Ry.fromMesh(t)), (Ry.currentPrim = Ry.currentPrim[e](Ry.nextPrim)))
                  : (Ry.currentPrim = Ry.fromMesh((Ry.sourceMesh = t))),
                Ry.doRemove && (null === (n = null == t ? void 0 : t.parent) || void 0 === n || n.remove(t))
            }
          }
          static eval(t, e) {
            delete Ry.currentOp, delete Ry.sourceMesh, (Ry.doRemove = e), Ry.iEval(t)
            const n = Ry.toMesh(Ry.currentPrim, Ry.sourceMesh.matrix)
            return (n.material = Ry.sourceMesh.material), (n.castShadow = n.receiveShadow = !0), n
          }
          clone() {
            const t = new Ry()
            return (t.polygons = this.polygons.map(t => t.clone())), t
          }
          toPolygons() {
            return this.polygons
          }
          union(t) {
            const e = new Oy(this.clone().polygons),
              n = new Oy(t.clone().polygons)
            return (
              e.clipTo(n),
              n.clipTo(e),
              n.invert(),
              n.clipTo(e),
              n.invert(),
              e.build(n.allPolygons()),
              Ry.fromPolygons(e.allPolygons())
            )
          }
          subtract(t) {
            const e = new Oy(this.clone().polygons),
              n = new Oy(t.clone().polygons)
            return (
              e.invert(),
              e.clipTo(n),
              n.clipTo(e),
              n.invert(),
              n.clipTo(e),
              n.invert(),
              e.build(n.allPolygons()),
              e.invert(),
              Ry.fromPolygons(e.allPolygons())
            )
          }
          intersect(t) {
            const e = new Oy(this.clone().polygons),
              n = new Oy(t.clone().polygons)
            return (
              e.invert(),
              n.clipTo(e),
              n.invert(),
              e.clipTo(n),
              n.clipTo(e),
              e.build(n.allPolygons()),
              e.invert(),
              Ry.fromPolygons(e.allPolygons())
            )
          }
          inverse() {
            const t = this.clone()
            return (
              t.polygons.map(t => {
                t.flip()
              }),
              t
            )
          }
        }
        Ry._tmpm3 = new jn()
        class Py extends ei {
          constructor(t, e, n) {
            if (3 === arguments.length) super(t, e, n)
            else if (Array.isArray(t)) super(t[0], t[1], t[2])
            else {
              if ('object' != typeof t) throw new Error('Invalid constructor to vector')
              this.copy(t)
            }
          }
          clone() {
            return new Py(this.x, this.y, this.z)
          }
          negated() {
            return this.clone().multiplyScalar(-1)
          }
          plus(t) {
            return this.clone().add(t)
          }
          minus(t) {
            return this.clone().sub(t)
          }
          times(t) {
            return this.clone().multiplyScalar(t)
          }
          dividedBy(t) {
            return this.clone().divideScalar(t)
          }
          lerp(t, e) {
            return this.plus(t.minus(this).times(e))
          }
          unit() {
            return this.dividedBy(this.length())
          }
          cross(t, e) {
            return ei.prototype.cross.call(this.clone(), t)
          }
        }
        class Cy {
          constructor(t, e, n) {
            ;(this.pos = new Py(t.x, t.y, t.z)),
              (this.normal = new Py(e.x, e.y, e.z)),
              n && (this.uv = new Py(n.x, n.y, n.z))
          }
          clone() {
            return new Cy(this.pos.clone(), this.normal.clone(), this.uv ? this.uv.clone() : void 0)
          }
          flip() {
            this.normal = this.normal.negated()
          }
          interpolate(t, e) {
            return new Cy(
              this.pos.lerp(t.pos, e),
              this.normal.lerp(t.normal, e),
              this.uv ? this.uv.lerp(t.uv, e) : void 0
            )
          }
        }
        class Iy {
          constructor(t, e) {
            ;(this.normal = t), (this.w = e)
          }
          static fromPoints(t, e, n) {
            const i = e.minus(t).cross(n.minus(t)).unit()
            return new Iy(i, i.dot(t))
          }
          clone() {
            return new Iy(this.normal.clone(), this.w)
          }
          flip() {
            ;(this.normal = this.normal.negated()), (this.w = -this.w)
          }
          splitPolygon(t, e, n, i, r) {
            let s = 0
            const o = []
            for (const e of t.vertices) {
              const t = this.normal.dot(e.pos) - this.w,
                n = t < -Iy.EPSILON ? 2 : t > Iy.EPSILON ? 1 : 0
              ;(s |= n), o.push(n)
            }
            switch (s) {
              case 0:
                this.normal.dot(t.plane.normal) > 0 ? e.push(t) : n.push(t)
                break
              case 1:
                i.push(t)
                break
              case 2:
                r.push(t)
                break
              case 3:
                const s = [],
                  a = []
                for (let e = 0; e < t.vertices.length; e++) {
                  const n = (e + 1) % t.vertices.length,
                    i = o[e],
                    r = o[n],
                    l = t.vertices[e],
                    c = t.vertices[n]
                  if ((2 !== i && s.push(l), 1 !== i && a.push(2 !== i ? l.clone() : l), 3 == (i | r))) {
                    const t = (this.w - this.normal.dot(l.pos)) / this.normal.dot(c.pos.minus(l.pos)),
                      e = l.interpolate(c, t)
                    s.push(e), a.push(e.clone())
                  }
                }
                s.length >= 3 && i.push(new Dy(s, t.shared)), a.length >= 3 && r.push(new Dy(a, t.shared))
            }
          }
        }
        Iy.EPSILON = 1e-5
        class Dy {
          constructor(t, e = null) {
            ;(this.vertices = t), (this.shared = e), (this.plane = Iy.fromPoints(t[0].pos, t[1].pos, t[2].pos))
          }
          clone() {
            const t = this.vertices.map(t => t.clone())
            return new Dy(t, this.shared)
          }
          flip() {
            this.vertices.reverse().map(t => {
              t.flip()
            }),
              this.plane.flip()
          }
        }
        class Oy {
          constructor(t) {
            delete this.plane, delete this.front, delete this.back, (this.polygons = []), t && this.build(t)
          }
          clone() {
            const t = new Oy()
            return (
              (t.plane = this.plane && this.plane.clone()),
              (t.front = this.front && this.front.clone()),
              (t.back = this.back && this.back.clone()),
              (t.polygons = this.polygons.map(t => t.clone())),
              t
            )
          }
          invert() {
            for (const t of this.polygons) t.flip()
            this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert()
            const t = this.front
            ;(this.front = this.back), (this.back = t)
          }
          clipPolygons(t) {
            if (!this.plane) return t.slice()
            let e = [],
              n = []
            for (const i of t) this.plane.splitPolygon(i, e, n, e, n)
            return (
              this.front && (e = this.front.clipPolygons(e)),
              (n = this.back ? this.back.clipPolygons(n) : []),
              e.concat(n)
            )
          }
          clipTo(t) {
            ;(this.polygons = t.clipPolygons(this.polygons)),
              this.front && this.front.clipTo(t),
              this.back && this.back.clipTo(t)
          }
          allPolygons() {
            let t = this.polygons.slice()
            return (
              this.front && (t = t.concat(this.front.allPolygons())),
              this.back && (t = t.concat(this.back.allPolygons())),
              t
            )
          }
          build(t) {
            if (!t.length) return
            this.plane || (this.plane = t[0].plane.clone())
            const e = [],
              n = []
            for (const i of t) this.plane.splitPolygon(i, this.polygons, this.polygons, e, n)
            e.length && (this.front || (this.front = new Oy()), this.front.build(e)),
              n.length && (this.back || (this.back = new Oy()), this.back.build(n))
          }
        }
        var Ny = r(298)
        class By extends Ny.Scene {
          constructor(t) {
            super(t)
          }
          warpSpeesd(...t) {
            return (function (t, e, n, i) {
              return new (n || (n = Promise))(function (r, s) {
                function o(t) {
                  try {
                    l(i.next(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function a(t) {
                  try {
                    l(i.throw(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function l(t) {
                  var e
                  t.done
                    ? r(t.value)
                    : ((e = t.value),
                      e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e)
                          })).then(o, a)
                }
                l((i = i.apply(t, e || [])).next())
              })
            })(this, void 0, void 0, function* () {
              return yield this.third.warpSpeed(...t)
            })
          }
          haveSomeFun(t = 20) {
            this.third.haveSomeFun(t)
          }
          requestThirdDimension() {
            console.warn(
              '[enable3d] You do not need requestThirdDimension() anymore. Place accessThirdDimension() inside init() instead!'
            )
          }
          clearThirdDimension() {
            for (const t in this.third) delete this.third[t]
            delete this.third
          }
          accessThirdDimension(t = {}) {
            this.clearThirdDimension(),
              (this.third = new (class extends class {
                constructor(t = {}) {
                  this.threeGraphicsConfig = t
                  const {
                    alpha: e = !1,
                    anisotropy: n = 1,
                    camera: i = Tm.Perspective({ z: 25, y: 5 }),
                    antialias: r = !1,
                    usePhysics: s = !0,
                    renderer: o
                  } = t
                  ;(this.textureAnisotropy = n),
                    (this.camera = i),
                    (this.scene = new Ka()),
                    (this.renderer = o || new Xa({ antialias: r, alpha: e })),
                    (this.renderer.shadowMap.enabled = !0),
                    (this.renderer.shadowMap.type = g),
                    (this.cache = Lh),
                    (this.cache.enabled = !0),
                    s &&
                      ('undefined' != typeof Ammo
                        ? (this.physics = new sf(this.scene, t))
                        : console.log('[enable3d]: Are you sure you included ammo.js?'))
                }
              } {
                constructor(t, e = {}) {
                  var n
                  const i = document.getElementById('enable3d-three-canvas')
                  let r = {}
                  i && (r = { canvas: i }),
                    (e.renderer = new Xa(Object.assign(Object.assign({}, r), { antialias: e.antialias || !1 }))),
                    super(e),
                    null === (n = t.sys.game.canvas.parentElement) ||
                      void 0 === n ||
                      n.insertBefore(e.renderer.domElement, t.sys.game.canvas),
                    (t.sys.game.canvas.style.position = 'relative')
                  const s = () => {
                    var n, i
                    if (!e.renderer) return
                    const { width: r, height: s, marginLeft: o, marginTop: a } = t.sys.game.canvas.style
                    ;(e.renderer.domElement.id = 'enable3d-three-canvas'),
                      null === (n = this.camera) ||
                        void 0 === n ||
                        (n.aspect = t.sys.game.scale.baseSize.width / t.sys.game.scale.baseSize.height),
                      null === (i = this.camera) || void 0 === i || i.updateProjectionMatrix(),
                      e.renderer.setSize(t.sys.game.scale.baseSize.width, t.sys.game.scale.baseSize.height),
                      (e.renderer.domElement.style.width = r),
                      (e.renderer.domElement.style.height = s),
                      (e.renderer.domElement.style.marginLeft = o),
                      (e.renderer.domElement.style.marginTop = a)
                  }
                  s(),
                    t.scale.on('resize', () => {
                      s()
                    })
                  const o = document.createElement('style')
                  ;(o.innerText =
                    '\n      #enable3d-phaser-canvas:focus,\n      #enable3d-three-canvas:focus {\n        outline: none;\n      }\n\n      #enable3d-three-canvas {\n        position: absolute;\n      }\n    '),
                    document.head.appendChild(o)
                  const { enableXR: a = !1 } = e
                  if (
                    ((this.isXrEnabled = a),
                    (this.scene3D = t),
                    a && (this.webXR = new Ey(this.renderer, this.scene, this.camera)),
                    this.isXrEnabled)
                  ) {
                    let e = 0
                    this.renderer.setAnimationLoop(n => {
                      if (this.renderer.xr.isPresenting) {
                        const i = n - e
                        ;(e = n),
                          t.updateLoopXR(n, i),
                          this.renderer.state.reset(),
                          this.preRender(),
                          this.composer ? this.composer.render() : this.renderer.render(this.scene, this.camera),
                          this.postRender()
                      }
                    })
                  }
                  ;(t.add.extern().render = t => {
                    this.renderer.xr.isPresenting ||
                      (this.preRender(),
                      this.composer ? this.composer.render() : this.renderer.render(this.scene, this.camera),
                      this.postRender())
                  }),
                    t.events.on('postupdate', (t, e) => {
                      var n, i, r
                      null === (n = this.animationMixers) || void 0 === n || n.update(e),
                        null === (i = this.physics) || void 0 === i || i.update(e),
                        null === (r = this.physics) || void 0 === r || r.updateDebugger()
                    }),
                    (this.load = new Zv(this.cache, this.textureAnisotropy)),
                    (this.lights = new Kv(this.scene)),
                    (this.transform = new gy(this.camera, this.renderer)),
                    (this.csg = Ly),
                    (this.heightMap = new ay(this.scene)),
                    (this.factories = new Wm(this.scene)),
                    (this.misc = new my(this.scene, this.renderer, this.factories)),
                    (this.cameras = new Tm()),
                    (this.ws = new hy(
                      this.scene,
                      this.renderer,
                      this.camera,
                      this.lights,
                      this.physics,
                      this.load,
                      this.factories
                    )),
                    (this.mixers = new (class {
                      constructor() {
                        this._mixers = []
                      }
                      animationMixer(t) {
                        const e = new Sd(t)
                        return this.mixers.add(e), e
                      }
                      get mixers() {
                        return {
                          create: t => this.animationMixer(t),
                          add: t => this._mixers.push(t),
                          get: () => this._mixers,
                          update: t => {
                            var e
                            return null === (e = this._mixers) || void 0 === e
                              ? void 0
                              : e.forEach(e => e.update(t / 1e3))
                          }
                        }
                      }
                    })()),
                    t.events.once('shutdown', () => {
                      t.clearThirdDimension(), t.events.removeListener('update')
                    })
                }
                preRender() {}
                postRender() {}
                destroy(t) {
                  var e
                  null === (e = this.physics) || void 0 === e || e.destroy(t.body), this.scene.remove(t), (t = null)
                }
                warpSpeed(...t) {
                  return (function (t, e, n, i) {
                    return new (n || (n = Promise))(function (r, s) {
                      function o(t) {
                        try {
                          l(i.next(t))
                        } catch (t) {
                          s(t)
                        }
                      }
                      function a(t) {
                        try {
                          l(i.throw(t))
                        } catch (t) {
                          s(t)
                        }
                      }
                      function l(t) {
                        var e
                        t.done
                          ? r(t.value)
                          : ((e = t.value),
                            e instanceof n
                              ? e
                              : new n(function (t) {
                                  t(e)
                                })).then(o, a)
                      }
                      l((i = i.apply(t, e || [])).next())
                    })
                  })(this, void 0, void 0, function* () {
                    return yield this.ws.warpSpeed(...t)
                  })
                }
                haveSomeFun(t = 20) {
                  ;((t = 20, e) => {
                    if (window.__loadPhysics)
                      for (let n = 0; n < t; n++) {
                        const t = ['standard', 'basic', 'normal', 'phong', 'line', 'points'],
                          n = (t, e) => Math.floor(Math.random() * (e - t + 1) + t),
                          i = t => t[Math.floor(Math.random() * t.length)]
                        Math.random() > 0.5
                          ? e.add
                              .box(
                                {
                                  x: n(-10, 10),
                                  y: n(10, 20),
                                  z: n(-10, 10),
                                  width: n(1, 2) / 10,
                                  height: n(1, 2) / 10,
                                  depth: n(1, 2) / 10,
                                  mass: 1
                                },
                                { [i(t)]: { color: Math.floor(16777215 * Math.random()) } }
                              )
                              .body.setRestitution(Math.floor(10 * Math.random()) / 20)
                          : e.add
                              .sphere(
                                { x: n(-10, 10), y: n(10, 20), z: n(-10, 10), radius: n(1, 2) / 10, mass: 1 },
                                { [i(t)]: { color: Math.floor(16777215 * Math.random()) } }
                              )
                              .body.setRestitution(Math.floor(10 * Math.random()) / 20)
                      }
                    else console.log('There is not much fun without physics enabled!')
                  })(t, this.physics)
                }
                get animationMixers() {
                  var t
                  return null === (t = this.mixers) || void 0 === t ? void 0 : t.mixers
                }
                get make() {
                  return this.factories.make
                }
                get add() {
                  return this.factories.add
                }
              })(this, t)),
              (this.cameras.main.transparent = !0),
              this.cameras.main.setBackgroundColor('rgba(0,0,0,0)'),
              (this.third.scene.background = new Ar('white'))
          }
          updateLoopXR(t, e) {
            this.preUpdateXR(t, e), this.updateXR(t, e), this.postUpdateXR(t, e)
          }
          preUpdateXR(t, e) {}
          updateXR(t, e) {}
          postUpdateXR(t, e) {
            this.third.isXrEnabled &&
              (this.time.update(t, e),
              this.third.physics.update(e),
              this.third.physics.updateDebugger(),
              this.third.animationMixers.update(e))
          }
        }
        ;(window.__loadPhysics = !1), (window.__ammoPath = '')
        const Fy = t => (
          window.setTimeout(() => {
            window.__loadPhysics
              ? Qm(window.__ammoPath, () => {
                  Ammo().then(() => {
                    t()
                  })
                })
              : t()
          }, 50),
          {
            withPhysics(t) {
              ;(window.__loadPhysics = !0), (window.__ammoPath = t)
            }
          }
        )
        const zy = (t = {}) => {
          const { antialias: e = !0, parent: n, canvasId: i = 'enable3d-phaser-canvas' } = t,
            r = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
          r.id = i
          const s = n ? document.getElementById(n) : document.body
          s ? s.appendChild(r) : console.error(`[enable3d] parent "${n}" not found!`)
          const o = { antialias: e },
            a = {
              alpha: void 0 === o.alpha || o.alpha,
              depth: void 0 === o.depth || o.depth,
              stencil: void 0 === o.stencil || o.stencil,
              antialias: void 0 !== o.antialias && o.antialias,
              premultipliedAlpha: void 0 === o.premultipliedAlpha || o.premultipliedAlpha,
              preserveDrawingBuffer: void 0 !== o.preserveDrawingBuffer && o.preserveDrawingBuffer,
              powerPreference: void 0 !== o.powerPreference ? o.powerPreference : 'default',
              failIfMajorPerformanceCaveat: void 0 !== o.failIfMajorPerformanceCaveat && o.failIfMajorPerformanceCaveat,
              xrCompatible: !0
            },
            l = Object.assign({}, a),
            c = (function () {
              try {
                var t = document.createElement('canvas')
                return !(!window.WebGL2RenderingContext || !t.getContext('webgl2'))
              } catch (t) {
                return !1
              }
            })()
              ? 'webgl2'
              : 'webgl',
            h = r.getContext(c, l)
          return { canvas: r, context: h }
        }
        class ky extends ir {
          constructor() {
            super(),
              (this.isExtendedObject3D = !0),
              (this.isGroup = !1),
              (this.vector3 = new ei()),
              (this.hasBody = !1),
              (this.fragmentDepth = 0),
              (this.breakable = !1),
              (this.fractureImpulse = 1),
              (this._currentAnimation = ''),
              (this._animationActions = new Map()),
              (this.name = `object-${this.id}`)
          }
          get world() {
            return { theta: this.worldTheta, phi: this.worldPhi }
          }
          get worldTheta() {
            return this.getWorldDirection(this.vector3), Math.atan2(this.vector3.x, this.vector3.z)
          }
          get worldPhi() {
            return this.getWorldDirection(this.vector3), Math.acos(this.vector3.y)
          }
          set animationMixer(t) {
            this._animationMixer = t
          }
          get animationMixer() {
            return this._animationMixer || (this._animationMixer = new Sd(this)), this._animationMixer
          }
          get anims() {
            return {
              current: this._currentAnimation,
              add: (t, e) => this._animsAdd(t, e),
              get: t => this._animsGet(t),
              play: (t, e = 500, n = !0) => this._animsPlay(t, e, n),
              mixer: this.animationMixer
            }
          }
          get animation() {
            return console.warn('[enable3d] Please use "anims" instead of "animation"'), this.anims
          }
          _animsAdd(t, e) {
            this._animationActions.set(t, this.animationMixer.clipAction(e))
          }
          _animsGet(t) {
            const e = this._animationActions.get(t)
            return e || console.warn(`[enable3d] Animation(${t}) not found!`), e
          }
          _animsPlay(t, e = 500, n = !0) {
            const i = this._animationActions.get(t),
              r = this._animationActions.get(this._currentAnimation)
            i &&
              (i.reset(),
              r && (i.crossFadeFrom(r, e / 1e3, !0), (i.clampWhenFinished = !0)),
              n || i.setLoop(Ue, 0),
              i.play()),
              (this._currentAnimation = t)
          }
          setAction(t) {
            console.warn(`[enable3d] setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)
          }
          traverse(t) {
            super.traverse(t)
          }
          traverseVisible(t) {
            super.traverseVisible(t)
          }
          traverseAncestors(t) {
            super.traverseAncestors(t)
          }
        }
        class Uy extends Va {
          constructor() {
            super(),
              (this.isExtendedGroup = !0),
              (this.isMesh = !1),
              (this.hasBody = !1),
              (this.fragmentDepth = 0),
              (this.breakable = !1),
              (this.fractureImpulse = 1),
              (this.name = `object-${this.id}`)
          }
        }
        var Hy = r(613)
        const Gy = [
          {
            name: 'pointer',
            enabled: !0,
            test: 'onpointerdown' in window,
            events: { down: 'pointerdown', move: 'pointermove', up: 'pointerup' }
          },
          {
            name: 'touch',
            enabled: !0,
            test: 'ontouchstart' in window && window.navigator.maxTouchPoints >= 1,
            events: { down: 'touchstart', move: 'touchmove', up: 'touchend' }
          },
          {
            name: 'mouse',
            enabled: !0,
            test: 'onmousedown' in window,
            events: { down: 'mousedown', move: 'mousemove', up: 'mouseup' }
          }
        ]
        class Vy {
          constructor(t) {
            ;(this._events = new Hy.Events()),
              (this.domElement = null),
              (this._isDown = !1),
              (this._isPaused = !1),
              (this.active = { touch: !1, mouse: !1, pointer: !1 }),
              (this.registered = { touch: !1, mouse: !1, pointer: !1 }),
              (this._currentPosition = { x: -1, y: -1 }),
              (this._lastPosition = { x: -1, y: -1 }),
              (this._isPointerLockAvailable = 'onpointerlockchange' in document),
              this._add(t)
          }
          static get VERSION() {
            return '0.0.3'
          }
          get isDown() {
            return this._isDown
          }
          set _position(t) {
            ;(t.x === this._currentPosition.x && t.y == this._currentPosition.y) ||
              ((this._lastPosition = this._currentPosition), (this._currentPosition = t))
          }
          get currentPosition() {
            return this._currentPosition
          }
          get lastPosition() {
            return this._lastPosition
          }
          get isPaused() {
            return this._isPaused
          }
          pause() {
            this._isPaused = !0
          }
          resume() {
            this._isPaused = !1
          }
          _onPointerLockChange() {
            return new Promise(t => {
              document.addEventListener(
                'pointerlockchange',
                e => {
                  t(e)
                },
                { once: !0 }
              )
            })
          }
          get pointerLock() {
            return {
              onceChange: this._onPointerLockChange,
              request: () =>
                new Promise((t, e) =>
                  this._isPointerLockAvailable
                    ? this.pointerLock.isLocked
                      ? e('Pointer is already locked!')
                      : (this._onPointerLockChange().then(e => {
                          t(e)
                        }),
                        void this.once.down(() => {
                          var t
                          null === (t = this.domElement) || void 0 === t || t.requestPointerLock()
                        }))
                    : e('PointerLock is not available!')
                ),
              exit: () =>
                new Promise((t, e) => {
                  if (!this.pointerLock.isLocked) return e('Pointer is not locked!')
                  this._onPointerLockChange().then(e => {
                    t(e)
                  }),
                    document.exitPointerLock()
                }),
              available: this._isPointerLockAvailable,
              isLocked: !!document.pointerLockElement
            }
          }
          get once() {
            return {
              down: t => {
                this._events.once('down', e => {
                  t(e)
                })
              },
              move: t => {
                this._events.once('move', e => {
                  t(e)
                })
              },
              up: t => {
                this._events.once('up', e => {
                  t(e)
                })
              }
            }
          }
          get on() {
            return {
              down: t => {
                this._events.on('down', e => {
                  this._isPaused || t(e)
                })
              },
              move: t => {
                this._events.on('move', e => {
                  this._isPaused || t(e)
                })
              },
              up: t => {
                this._events.on('up', e => {
                  this._isPaused || t(e)
                })
              }
            }
          }
          _add(t) {
            const e = (this.domElement = null != t ? t : window)
            e || console.warn('[tap] No domElement found!'),
              (this._onDown = this._onDown.bind(this)),
              (this._onMove = this._onMove.bind(this)),
              (this._onUp = this._onUp.bind(this)),
              Gy.forEach(t => {
                t.test &&
                  t.enabled &&
                  ((this.active[t.name] = !0),
                  e.addEventListener(t.events.down, this._onDown, !1),
                  e.addEventListener(t.events.move, this._onMove, !1),
                  e.addEventListener(t.events.up, this._onUp, !1))
              })
          }
          _remove(t) {
            if (!this.active[t]) return
            const e = this.domElement
            e || console.warn('[tap] No domElement found!'),
              Gy.forEach(n => {
                n.name === t &&
                  (e.removeEventListener(n.events.down, this._onDown, !1),
                  e.removeEventListener(n.events.move, this._onMove, !1),
                  e.removeEventListener(n.events.up, this._onUp, !1))
              }),
              (this.active[t] = !1)
          }
          destroy() {
            this.pause(),
              Object.keys(this.active).forEach(t => {
                this._remove(t)
              }),
              this._events.removeAllListeners(),
              (this._events = null),
              (this.domElement = null),
              (this._isDown = null),
              (this._isPaused = null),
              (this.active = null),
              (this.registered = null),
              (this._currentPosition = null),
              (this._lastPosition = null)
          }
          _calcPosition(t) {
            let e, n
            return (
              t.touches && t.touches[0]
                ? ((e = t.touches[0].pageX), (n = t.touches[0].pageY))
                : t.clientX
                ? ((e = t.clientX), (n = t.clientY))
                : ((e = this._currentPosition.x), (n = this._currentPosition.y)),
              this.pointerLock.isLocked && ((e = t.movementX), (n = t.movementY)),
              (this._position = { x: e, y: n }),
              { x: e, y: n }
            )
          }
          _removeDuplicates(t) {
            return (
              'pointerdown' === t.type && (this.registered.pointer = !0),
              'touchstart' === t.type && (this.registered.touch = !0),
              'mousedown' === t.type && (this.registered.mouse = !0),
              'touchstart' === t.type && this.active.touch && this.registered.pointer
                ? (this._remove('touch'), !1)
                : 'mousedown' !== t.type ||
                  !this.active.mouse ||
                  (!this.registered.pointer && !this.registered.touch) ||
                  (this._remove('mouse'), !1)
            )
          }
          _onDown(t) {
            this._removeDuplicates(t) &&
              ((this._isDown = !0), this._events.emit('down', { position: this._calcPosition(t), event: t }))
          }
          _onMove(t) {
            this._events.emit('move', { position: this._calcPosition(t), event: t, dragging: this._isDown })
          }
          _onUp(t) {
            ;(this._isDown = !1), this._events.emit('up', { position: this._calcPosition(t), event: t })
          }
        }
        const Wy = (t, e, n, i, r, s) => {
            i < 2 * s && (s = i / 2),
              r < 2 * s && (s = r / 2),
              t.beginPath(),
              t.moveTo(e + s, n),
              t.arcTo(e + i, n, e + i, n + r, s),
              t.arcTo(e + i, n + r, e, n + r, s),
              t.arcTo(e, n + r, e, n, s),
              t.arcTo(e, n, e + i, n, s),
              t.closePath()
          },
          jy = new Map(),
          qy = t => {
            const e = new Zn(t)
            return (e.minFilter = Mt), (e.generateMipmaps = !1), (e.needsUpdate = !0), e
          },
          Xy = document.createElement('canvas')
        let Yy,
          Zy,
          Jy,
          Ky = !1
        const Qy = [],
          $y = new Rd(),
          tx = new Wn(),
          ex = new Wn(),
          nx = new Wn(),
          ix = [],
          rx = t => {
            ix.includes(t) || (console.warn(t), ix.push(t))
          },
          sx = (t, e) => {
            ;(nx.x = t), (nx.y = e)
          },
          ox = () => Yy,
          ax = () => {
            lx(), Jy && Jy.destroy()
          },
          lx = () => {
            for (; Qy.length > 0; ) Qy.pop()
          },
          cx = t =>
            (function (t, e, n, i) {
              return new (n || (n = Promise))(function (r, s) {
                function o(t) {
                  try {
                    l(i.next(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function a(t) {
                  try {
                    l(i.throw(t))
                  } catch (t) {
                    s(t)
                  }
                }
                function l(t) {
                  var e
                  t.done
                    ? r(t.value)
                    : ((e = t.value),
                      e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e)
                          })).then(o, a)
                }
                l((i = i.apply(t, e || [])).next())
              })
            })(void 0, void 0, void 0, function* () {
              if (!Jy) return
              const {
                currentPosition: { x: e, y: n },
                isDown: i
              } = Jy
              if (tx.x === e && tx.y === n && Ky === i) return
              if (((Ky = i), (tx.x = e), (tx.y = n), 0 === nx.x || void 0 === nx.x))
                return void rx('[FLAT] Please call FLAT.setSize() first!')
              ;(ex.x = (e / nx.x) * 2 - 1), (ex.y = (-n / nx.y) * 2 + 1), $y.setFromCamera(ex, t)
              let r = [...Qy]
              const s = $y.intersectObjects(r)
              0 === s.length ? (document.body.style.cursor = 'default') : (document.body.style.cursor = 'pointer'),
                Zy && Zy.enabled && s.length >= 0 && (Zy.enabled = !1),
                Zy && !Zy.enabled && 0 === s.length && (Zy.enabled = !0)
              for (let t = 0; t < s.length; t++) {
                const e = s[t].object
                let n = !1
                if (e.pixelPerfect) {
                  const t = t => {
                      ;(Xy.width = t.width), (Xy.height = t.height)
                      const e = Xy.getContext('2d')
                      return e.drawImage(t, 0, 0), e.getImageData(0, 0, t.width, t.height)
                    },
                    i = (t, e, n) => {
                      const i = 4 * (e + t.width * n),
                        r = t.data
                      return { r: r[i], g: r[i + 1], b: r[i + 2], a: r[i + 3] }
                    },
                    r = s[0].uv,
                    { x: o, y: a } = e.texture.transformUv(r),
                    l = t(yield createImageBitmap(e.texture.image)),
                    { r: c, g: h, b: u, a: d } = i(l, Math.round(o * l.width), Math.round(a * l.height))
                  n = c + h + u + d === 0
                }
                if (e.pixelPerfect && n) continue
                e.event = Jy.isDown ? 'down' : 'over'
                const i = r.findIndex(t => t.uuid === e.uuid)
                r = [...r.slice(0, i), ...r.slice(i + 1)]
                break
              }
              return (
                r.forEach(t => {
                  t.event = 'out'
                }),
                s
              )
            })
        class hx extends fl {
          constructor(t, e = !0) {
            super(new el({ map: e ? t.clone() : t, color: 16777215 })),
              (this._event = 'out'),
              (this._pixelPerfect = !1),
              (this._isInteractive = !1),
              (this._depth = 0),
              (this._bodyOffset = { x: 0, y: 0 }),
              (this._internalScale = { x: 1, y: 1 }),
              (this._pixelRatio = 1),
              (this.onInputOver = () => {}),
              (this.onInputOut = () => {}),
              (this.onInputDown = () => {}),
              this._setTexture(),
              this.setScale(this._internalScale.x, this._internalScale.y),
              this.setDepth(this._calcZ())
          }
          _onInputOver() {}
          _onInputOut() {}
          _onInputDown() {}
          set event(t) {
            this._event !== t &&
              ((this._event = t),
              'over' === t
                ? (this._onInputOver(), this.onInputOver())
                : 'out' === t
                ? (this._onInputOut(), this.onInputOut())
                : 'down' === t && (this._onInputDown(), this.onInputDown()))
          }
          setPixelRatio(t) {
            ;(this._pixelRatio = t), this.setScale(this._internalScale.x, this._internalScale.y)
          }
          setInteractive({ pixelPerfect: t = !1 } = {}) {
            var e
            this._isInteractive ||
              ((this._isInteractive = !0),
              (this._pixelPerfect = t),
              (e = this),
              0 === Qy.length &&
                (() => {
                  const t = ox()
                  t ? (Jy = new Vy(t)) : rx('Please call "FLAT.initEvents()" first.')
                })(),
              Qy.push(e))
          }
          get pixelPerfect() {
            return this._pixelPerfect
          }
          _calcZ() {
            return this._depth / 100 - 1e-8 * this.id
          }
          getTexture() {
            return this.texture
          }
          setTexture(t) {
            this._setTexture(t)
          }
          get texture() {
            return this.material.map
          }
          _setTexture(t) {
            if (!this.material.map) return void console.warn('Something went wrong!')
            t && (this.material.map = t)
            const { width: e, height: n } = this.material.map.image
            ;(this.textureWidth = e), (this.textureHeight = n), (this.material.map.needsUpdate = !0)
          }
          getBodyOffset() {
            return { x: this._bodyOffset.x * this.getScale().x, y: this._bodyOffset.y * this.getScale().y }
          }
          setPosition(t, e) {
            this.position.set(t, e, this._calcZ())
          }
          setDepth(t) {
            ;(this._depth = t), this.position.setZ(this._calcZ())
          }
          setRotation(t) {
            this.material.rotation = t
          }
          getRotation() {
            return this.material.rotation
          }
          getPixelRatio() {
            return this._pixelRatio
          }
          getScale() {
            return { x: this._internalScale.x, y: this._internalScale.y }
          }
          setScale(t, e) {
            ;(this._internalScale.x = t), (this._internalScale.y = e || t)
            const n = t,
              i = e || t
            this.scale.set((n * this.textureWidth) / this._pixelRatio, (i * this.textureHeight) / this._pixelRatio, 1)
          }
        }
        class ux extends hx {
          constructor(t) {
            super(t),
              (this._anims = []),
              (this._flipX = !1),
              (this._frame = { name: '', index: -1, width: -1, height: -1 }),
              (this._currentIndex = 0),
              (this._currentAnimationName = '')
          }
          get frame() {
            return {
              name: this._frame.name,
              index: this._frame.index,
              width: (this._frame.width * this._internalScale.x * 1) / this._pixelRatio,
              height: (this._frame.height * this._internalScale.y * 1) / this._pixelRatio
            }
          }
          get anims() {
            return {
              add: this._add.bind(this),
              get: this.getAnimationByName.bind(this),
              play: this._play.bind(this),
              stop: this._stop.bind(this),
              getName: () => this._currentAnimationName,
              name: this._currentAnimationName
            }
          }
          getAnimationByName(t) {
            return this._anims.filter(e => e.name === t)[0]
          }
          _add(t, e) {
            const { start: n, end: i, rate: r = 30, repeat: s = -1, timeline: o = [] } = e
            if (this.getAnimationByName(t)) console.warn(`The animation "${t}" does already exist!`)
            else {
              if (0 === o.length) {
                if (void 0 === i || void 0 === n)
                  return void console.warn('You need to provide "start" and "end or a "timeline"!')
                for (let t = n; t <= i; t++) o.push(t)
              }
              this._anims.push({ name: t, timeline: o, rate: r, repeat: s })
            }
          }
          _stop() {
            this.interval && clearInterval(this.interval)
          }
          _play(t) {
            this._stop(), (this._currentAnimationName = t)
            const e = this.getAnimationByName(t)
            e || console.warn(`Animation "${t}" does not exist!`)
            const { timeline: n, rate: i, repeat: r } = e
            this._currentIndex = -1
            let s = 0
            const o = () => {
              if (
                (this._currentIndex++,
                this._currentIndex >= n.length && ((this._currentIndex = 0), s++),
                (this._currentIndex = n[this._currentIndex]),
                !(-1 === r || s < r))
              )
                return this._stop(), void this._events.emit('complete')
              this.setFrame(this._currentIndex)
            }
            return (
              o(),
              (this.interval = window.setInterval(() => {
                o()
              }, 1e3 / i)),
              { onComplete: t => this._events.once('complete', t) }
            )
          }
          get _events() {
            return {
              emit: t => {
                this._eventEmitter || (this._eventEmitter = new Hy.Events()), this._eventEmitter.emit(t)
              },
              once: (t, e) => {
                this._eventEmitter || (this._eventEmitter = new Hy.Events()), this._eventEmitter.once(t, e)
              }
            }
          }
        }
        class dx extends ux {
          constructor(t, e) {
            super(t)
            const { width: n = this.textureWidth, height: i = this.textureHeight } = e
            ;(this._tilesHoriz = this.textureWidth / n),
              (this._tilesVert = this.textureHeight / i),
              this._tilesHoriz !== Math.round(this._tilesHoriz) &&
                console.warn('The horizontal row does not seem to fit!'),
              this._tilesVert !== Math.round(this._tilesVert) && console.warn('The vertical row does not seem to fit!'),
              (this._width = n),
              (this._height = i),
              (this._frame.width = n),
              (this._frame.height = i),
              this.sizeFrame(1 / this._tilesHoriz, 1 / this._tilesVert),
              this.scaleFrame()
          }
          setScale(t, e) {
            super.setScale(t, e), this.scaleFrame()
          }
          scaleFrame() {
            this.scale.set(
              (this._width * this._internalScale.x) / this._pixelRatio,
              (this._height * this._internalScale.y) / this._pixelRatio,
              1
            )
          }
          getRow(t) {
            return Math.floor(t / this._tilesHoriz)
          }
          getColumn(t) {
            return t % this._tilesHoriz
          }
          sizeFrame(t, e) {
            ;(this.texture.wrapS = this.texture.wrapT = ft),
              this.texture.repeat.set(t, e),
              (this.texture.needsUpdate = !0)
          }
          offsetTexture(t, e) {
            this._flipX && (t += 1 / this._tilesHoriz), this.texture.offset.setX(t), this.texture.offset.setY(e)
          }
          flipX(t) {
            this._flipX = t
            let e = 1 / this._tilesHoriz
            const n = 1 / this._tilesVert
            t && (e *= -1), this.texture.repeat.set(e, n), this.setFrame(this._frame.index)
          }
          setFrame(t) {
            this._frame.index = t
            const e = this.getColumn(t) / this._tilesHoriz,
              n = (this._tilesVert - this.getRow(t) - 1) / this._tilesVert
            this.offsetTexture(e, n)
          }
        }
        class px extends dx {
          constructor(t, e, n, i, r) {
            super(t, e), (this.overFrame = n), (this.outFrame = i), (this.downFrame = r), this.setFrame(i)
          }
          _onInputOver() {
            this.setFrame(this.overFrame)
          }
          _onInputOut() {
            this.setFrame(this.outFrame)
          }
          _onInputDown() {
            this.setFrame(this.downFrame)
          }
        }
        class mx extends Zn {
          constructor(t, e, n) {
            const i = Xy.getContext('2d')
            i.clearRect(0, 0, Xy.width, Xy.height),
              (Xy.height = e),
              (Xy.width = t),
              n(i),
              super(i.getImageData(0, 0, Xy.width, Xy.height)),
              (this.minFilter = Mt),
              (this.generateMipmaps = !1),
              (this.width = t),
              (this.height = e),
              (this.drawCanvas = n),
              (this.needsUpdate = !0)
          }
          clone() {
            return new mx(this.width, this.height, this.drawCanvas).copy(this)
          }
        }
        class fx extends hx {
          constructor(t, e, n) {
            const i = Xy.getContext('2d')
            i.clearRect(0, 0, Xy.width, Xy.height), (Xy.height = e), (Xy.width = t), n(i)
            const r = i.getImageData(0, 0, Xy.width, Xy.height)
            super(qy(r)), (this._drawCanvas = n)
          }
          clone() {
            return new fx(this.textureWidth, this.textureHeight, this._drawCanvas).clone()
          }
        }
        const gx = ({ canvas: t, orbitControls: e }) => {
          ;(t => {
            t && (Zy = t)
          })(e),
            (t => {
              Yy = t
            })(t)
        }
        class vx extends Zn {
          constructor(t, e = {}) {
            const { imageData: n, width: i, height: r } = xx(t, e)
            super(n),
              (this.width = i),
              (this.height = r),
              (this._text = t),
              (this._styles = e),
              (this._image = n),
              (this.minFilter = Mt),
              (this.generateMipmaps = !1),
              (this.needsUpdate = !0)
          }
          getText() {
            return this._text
          }
          getStyles() {
            return this._styles
          }
          clone() {
            return new this.constructor(this._text, this._styles).copy(this)
          }
        }
        class yx extends hx {
          constructor(t) {
            super(t, !1), (this._text = t.getText()), (this._styles = t.getStyles())
          }
          getText() {
            return this._text
          }
          getStyles() {
            return this._styles
          }
          setStyles(t) {
            ;(this._styles = t), this.texture.dispose(), this.setTexture(qy(xx(this._text, t).imageData))
          }
          setText(t) {
            ;(this._text = t),
              this.texture.dispose(),
              this.setTexture(qy(xx(t, this._styles).imageData)),
              this._update()
          }
          _update() {
            ;(this.textureHeight = this.texture.image.height),
              (this.textureWidth = this.texture.image.width),
              (this.texture.needsUpdate = !0),
              (this.material.needsUpdate = !0)
            const { x: t, y: e } = this._internalScale
            this.setScale(t, e)
          }
        }
        const xx = (t, e) => {
          const {
              align: n = 'center',
              background: i = '',
              baseline: r = 'middle',
              borderColor: s = '',
              borderRadius: o = 0,
              borderWidth: a = 0,
              fillStyle: l = 'SlateBlue',
              fontFamily: c = 'Arial',
              fontSize: h = 48,
              fontWeight: u = '',
              lineHeight: d = 1,
              lineWidth: p = 4,
              padding: m = 0,
              strokeStyle: f = ''
            } = e,
            { offset: { x: g = 0, y: v = 0 } = {} } = e
          let y, x
          'number' != typeof m ? ((y = m.x || 0), (x = m.y || 0)) : ((y = m), (x = m))
          const b = `${u} ${h}px ${c}`,
            w = Xy.getContext('2d')
          w.clearRect(0, 0, Xy.width, Xy.height)
          const _ = t.split('\n')
          w.font = b
          const M = ((t, e, n, i = 1) => {
              const r = e + n
              let s = jy.get(r)
              if (!s) {
                const o = document.createElement('p')
                ;(o.style.fontFamily = n),
                  (o.style.fontSize = `${e}px`),
                  (o.style.whiteSpace = 'nowrap'),
                  (o.style.lineHeight = i.toString()),
                  (o.textContent = t),
                  document.body.appendChild(o),
                  (s = Math.ceil(o.offsetHeight)),
                  document.body.removeChild(o),
                  jy.set(r, s)
              }
              return s
            })(t, h, c, d),
            T = l ? 2 * p : p,
            S = M * _.length + 2 * x + 2 * a,
            E = ((t, e) => Math.max(...e.map(e => Math.ceil(t.measureText(e).width))))(w, _) + T + 2 * y + 2 * a
          ;(Xy.height = S),
            (Xy.width = E),
            s &&
              ((w.strokeStyle = s), Wy(w, a / 2, a / 2, Xy.width - a, Xy.height - a, o), (w.lineWidth = a), w.stroke()),
            i && ((w.fillStyle = i), Wy(w, a, a, Xy.width - 2 * a, Xy.height - 2 * a, s ? o / 2 : o), w.fill()),
            (w.font = b),
            (w.textAlign = n),
            (w.textBaseline = r),
            f && p && ((w.strokeStyle = f), (w.lineWidth = T)),
            l && (w.fillStyle = l)
          for (var A = 0; A < _.length; A++) {
            let t = A * M + M / 2,
              e = 0
            'left' === n && ((e = T / 2), (e += y), (e += a)),
              'center' === n && (e = E / 2),
              'right' === n && ((e = E - T / 2), (e -= y), (e -= a)),
              (t += x),
              (t += a),
              (t += v),
              (e += g),
              f && p && w.strokeText(_[A], e, t),
              l && w.fillText(_[A], e, t)
          }
          return { imageData: w.getImageData(0, 0, Xy.width, Xy.height), width: E, height: S }
        }
        class bx extends ux {
          constructor(t, e) {
            super(t.texture), (this.positionOffset = { x: 0, y: 0 }), (this.JSONHash = t.json), e && this.setFrame(e)
          }
          setScale(t, e) {
            ;(this._internalScale.x = t), (this._internalScale.y = e || t), this.scaleFrame()
          }
          scaleFrame() {
            var t
            if (!(null === (t = this._frame) || void 0 === t ? void 0 : t.name)) return
            const {
                frame: { w: e, h: n }
              } = this.getFrame(this._frame.name),
              i = (e * this._internalScale.x) / this._pixelRatio,
              r = (n * this._internalScale.y) / this._pixelRatio
            this.scale.set(i, r, 1)
          }
          sizeFrame(t, e) {
            ;(this.texture.wrapS = this.texture.wrapT = ft),
              this.texture.repeat.set(t, e),
              (this.texture.needsUpdate = !0)
          }
          offsetTexture(t, e) {
            this.texture.offset.setX(t), this.texture.offset.setY(e)
          }
          flipX(t) {
            ;(this._flipX = t), this.update()
          }
          getFrame(t) {
            return this.JSONHash.frames[t]
          }
          setFrame(t) {
            this.update(t)
          }
          update(t) {
            if ((t || (t = this._frame.name), !t)) return
            const e = this.getFrame(t)
            e || console.warn(`Frame ${t} not found!`)
            const { frame: n, rotated: i, trimmed: r, spriteSourceSize: s, sourceSize: o } = e
            ;(this._frame.name = t), (this.texture.rotation = 0)
            const a = n.x / this.textureWidth
            let l = 1 - (n.y + n.h) / this.textureHeight,
              c = n.w,
              h = n.h
            if (
              ((this._frame.width = c),
              (this._frame.height = h),
              i &&
                ((this.texture.rotation = Math.PI / 2),
                (l = 1 - n.y / this.textureHeight),
                ([c, h] = [h, c]),
                this._flipX && (this.texture.rotation *= -1)),
              r)
            ) {
              const t = ((o.w - n.w) / 2 - s.x) / (1 / this._internalScale.x),
                e = ((o.h - n.h) / 2 - s.y) / (1 / this._internalScale.x)
              this._flipX
                ? (this.position.x += t - this.positionOffset.x)
                : (this.position.x -= t - this.positionOffset.x),
                (this.position.y += e - this.positionOffset.y),
                (this.positionOffset.x = t),
                (this.positionOffset.y = e)
            }
            let u = a,
              d = l,
              p = c / this.textureWidth
            const m = h / this.textureHeight
            this._flipX && ((p *= -1), i ? (d -= n.w / this.textureHeight) : (u += n.w / this.textureWidth)),
              this.offsetTexture(u, d),
              this.sizeFrame(p, m),
              this.scaleFrame()
          }
        }
        var wx = r(626)
        const _x = {
            colors: { dynamic: '#ff0000', static: '#90ee90', sensor: '#ffff00', sleeping: '#464646' },
            lineWidth: 2,
            fill: !1,
            opacity: 0.25
          },
          Mx = (t, e = 0, n, i) => {
            const r = ((t = {}) => {
                const { colors: e } = _x
                return t.isStatic ? e.static : t.isSensor ? e.sensor : t.isSleeping ? e.sleeping : e.dynamic
              })(t),
              s = _x.opacity,
              o = _x.lineWidth,
              a = _x.fill
            let l = null != n ? n : r + Math.round(255 * s).toString(16)
            a || (l = null != n ? n : 'transparent'),
              !t.isSleeping || t.isStatic || t.isSensor || (l = null != n ? n : r)
            const c = null != i ? i : r
            ;(t.render.fillStyle = l),
              (t.render.strokeStyle = c),
              (t.render.lineWidth = o),
              e >= 5 ||
                t.parts.forEach(t => {
                  Mx(t, e + 1, l, c)
                })
          }
        class Tx {
          constructor(t = !0) {
            ;(this._objects = new Map()), (this.width = window.innerWidth), (this.height = window.innerHeight)
            const e = t
            if (
              ((this.engine = wx.Engine.create({ enableSleeping: !0 })),
              (this.world = this.engine.world),
              (this.runner = wx.Runner.create()),
              e)
            ) {
              const t = document.createElement('canvas')
              ;(t.id = 'matter-debug'),
                (t.style.position = 'absolute'),
                (t.style.top = '0px'),
                (t.style.left = '0px'),
                (t.style.pointerEvents = 'none'),
                document.body.append(t),
                (this.render = wx.Render.create({
                  canvas: t,
                  engine: this.engine,
                  options: {
                    width: this.width,
                    height: this.height,
                    background: 'transparent',
                    wireframeBackground: 'transparent',
                    wireframes: !1,
                    showConvexHulls: !0,
                    showPositions: !0,
                    showVelocity: !0
                  }
                })),
                wx.Render.run(this.render)
            }
            wx.Runner.run(this.runner, this.engine), wx.Events.on(this.engine, 'afterUpdate', () => this.update())
          }
          destroy() {
            wx.World.clear(this.world, !1), wx.Engine.clear(this.engine)
          }
          parsePhysics(t) {
            const e = JSON.parse(t)
            delete e.generator_info
            let n = {}
            for (const t in e) {
              const i = e[t].fixtures
              n = Object.assign(Object.assign({}, n), { [t]: i })
            }
            return n
          }
          addBodyFromFixtures(t, e, n) {
            const i = []
            let r
            return (
              n.forEach(n => {
                let r
                n.vertices
                  ? (r = this.add.fromVertices(t, e, n.vertices))
                  : n.circle
                  ? (r = this.add.circle(t + n.circle.x, e + n.circle.y, n.circle.radius))
                  : console.log('Shape not recognized!'),
                  r && i.push(r)
              }),
              (r = i.length > 1 ? wx.Body.create({ parts: i }) : i[0]),
              wx.Body.setPosition(r, { x: t, y: e }),
              r
            )
          }
          fromVertices_Fixed(t, e, n, i = {}) {
            const r = []
            for (var s = 0; s < n.length; s++) {
              const o = wx.Bodies.fromVertices(t, e, [n[s]], Object.assign({}, i))
              r.push(o)
              const a = wx.Vertices.centre(n[s])
              wx.Body.setPosition(o, { x: o.position.x + a.x, y: o.position.y + a.y })
            }
            return wx.Body.create(Object.assign(Object.assign({}, i), { parts: r }))
          }
          fromVertices(t, e, n, i = {}) {
            return this.fromVertices_Fixed(t, e, n, Object.assign({}, i))
          }
          setBounds(t = 0, e = 0, n = this.width, i = this.height, r = 50) {
            wx.World.add(this.world, [
              this.add.rectangle(t + n / 2, e + 0 - r / 2, n + 2 * r, r, { isStatic: !0 }),
              this.add.rectangle(t + n / 2, e + i + r / 2, n + 2 * r, r, { isStatic: !0 }),
              this.add.rectangle(t + 0 - r / 2, e + i / 2, r, i + 2 * r, { isStatic: !0 }),
              this.add.rectangle(t + n + r / 2, e + i / 2, r, i + 2 * r, { isStatic: !0 })
            ])
          }
          rectangle(t, e, n, i, r = {}) {
            return wx.Bodies.rectangle(t, e, n, i, Object.assign({}, r))
          }
          circle(t, e, n, i = {}) {
            return wx.Bodies.circle(t, e, n, Object.assign({}, i))
          }
          existing(t) {
            this.add.bodyToSprite(t), this._objects.set(t.body.id.toString(), t)
          }
          calcBodyOffset(t) {
            const e = t.body,
              n = e.bounds.max.x - e.bounds.min.x,
              i = e.bounds.max.y - e.bounds.min.y,
              r = wx.Vector.sub(e.bounds.min, e.position),
              s = (e.position, { x: r.x + n / 2, y: r.y + i / 2 })
            t._bodyOffset = s
          }
          _addBodyToSprite(t) {
            this.add.body(t.body), this.calcBodyOffset(t)
            const e = t.getScale().x,
              n = t.getScale().y
            ;((t, e, n) => {
              t.circleRadius ||
                t.parts.forEach(t => {
                  ;((t, e, n) => {
                    t.circleRadius && (e === n ? (t.circleRadius *= e) : (t.circleRadius = void 0))
                  })(t, e, n)
                }),
                wx.Body.scale(t, e, n)
            })(t.body, e, n),
              (t.setBodyPosition = (e, n) => {
                wx.Body.setPosition(t.body, { x: e - t.getBodyOffset().x, y: n - t.getBodyOffset().y })
              })
          }
          _addBody(t) {
            wx.World.add(this.world, t)
          }
          get add() {
            return {
              body: this._addBody.bind(this),
              bodyToSprite: this._addBodyToSprite.bind(this),
              fromVertices: this.fromVertices.bind(this),
              circle: this.circle.bind(this),
              existing: this.existing.bind(this),
              rectangle: this.rectangle.bind(this)
            }
          }
          adjustDebugColor(t) {
            Mx(t)
          }
          update() {
            this._objects.forEach(t => {
              const { body: e } = t,
                { angle: n, position: i } = e,
                { x: r, y: s } = i,
                o = new Wn(t.getBodyOffset().x, t.getBodyOffset().y)
              o.rotateAround(new Wn(), n), t.setPosition(r + o.x, this.height - s - o.y), t.setRotation(-n), Mx(e)
            })
          }
        }
        class Sx extends Em.Events {
          constructor() {
            super(...arguments), (this.id = -1)
          }
          get add() {
            return { axis: (t = {}) => this.addAxis(t), button: (t = {}) => this.addButton(t) }
          }
          addAxis(t = {}) {
            this.id++
            const { styles: e = { left: 35, bottom: 35, size: 100 } } = t,
              n = this.circle({ styles: e }),
              i = this.thumb({ styles: e })
            n.appendChild(i), document.body.appendChild(n)
            const { maxRadius: r = 40, rotationDamping: s = 0.06, moveDamping: o = 0.01 } = t,
              a = {
                id: this.id,
                domElement: i,
                maxRadius: r,
                maxRadiusSquared: r * r,
                origin: { left: i.offsetLeft, top: i.offsetTop },
                offset: { x: 0, y: 0 },
                rotationDamping: s,
                moveDamping: o
              }
            if (null == a ? void 0 : a.domElement) {
              const { domElement: t } = a
              'ontouchstart' in window
                ? t.addEventListener('touchstart', t => {
                    t.preventDefault(), this.tap(t, a), t.stopPropagation()
                  })
                : t.addEventListener('mousedown', t => {
                    t.preventDefault(), this.tap(t, a), t.stopPropagation()
                  })
            }
            return {
              onMove: t => {
                this.on(`axis_onmove_${a.id}`, e => {
                  t(e)
                })
              }
            }
          }
          addButton(t = {}) {
            this.id++
            const { styles: e = { right: 35, bottom: 35, size: 80 }, letter: n = 'A' } = t,
              i = this.circle({ styles: e }),
              r = this.letter({ letter: n })
            i.appendChild(r), document.body.appendChild(i)
            const s = { id: this.id, domElement: i, offset: { x: 0, y: 0 } }
            return (
              (null == s ? void 0 : s.domElement) && this.click(s),
              {
                onClick: t => {
                  this.on(`button_onclick_${s.id}`, e => {
                    t(e)
                  })
                },
                onRelease: t => {
                  this.on(`button_onrelease_${s.id}`, e => {
                    t(e)
                  })
                }
              }
            )
          }
          circle(t = {}) {
            const { styles: e } = t,
              { top: n, right: i, bottom: r, left: s, size: o } = e,
              a = document.createElement('div')
            let l = `position:absolute; width:${o}px; height:${o}px; background:rgba(126, 126, 126, 0.5); border:#444 solid medium; border-radius:50%; cursor: pointer; `
            return (
              n && (l += `top:${n}px; `),
              i && (l += `right:${i}px; `),
              r && (l += `bottom:${r}px; `),
              s && (l += `left:${s}px; `),
              (a.style.cssText = l),
              a
            )
          }
          thumb(t = {}) {
            const { styles: e } = t,
              { size: n } = e,
              i = document.createElement('div')
            return (
              (i.style.cssText = `position: absolute; left: ${n / 4}px; top: ${n / 4}px; width: ${n / 2}px; height: ${
                n / 2
              }px; border-radius: 50%; background: #fff; `),
              i
            )
          }
          letter(t = {}) {
            const { letter: e } = t,
              n = document.createElement('span')
            return (
              (n.innerText = e),
              (n.style.cssText =
                'position: absolute; text-align: center; top: 4px; width: 80px; height: 80px; font-size: 64px; color: #fff; '),
              n
            )
          }
          click(t) {
            const { id: e, domElement: n } = t
            'ontouchstart' in window
              ? (n.addEventListener('touchstart', t => {
                  t.preventDefault(), this.emit(`button_onclick_${e}`)
                }),
                n.addEventListener('touchend', t => {
                  t.preventDefault(), this.emit(`button_onrelease_${e}`)
                }))
              : (n.addEventListener('mousedown', t => {
                  t.preventDefault(), this.emit(`button_onclick_${e}`), t.stopPropagation()
                }),
                n.addEventListener('mouseup', t => {
                  t.preventDefault(), this.emit(`button_onrelease_${e}`), t.stopPropagation()
                }))
          }
          tap(t, e) {
            ;(t = t || window.event),
              (e.offset = this.getMousePosition(t)),
              'ontouchstart' in window
                ? ((document.ontouchmove = t => {
                    t.target === e.domElement && this.move(t, e)
                  }),
                  (document.ontouchend = t => {
                    t.target === e.domElement && this.up(e)
                  }))
                : ((document.onmousemove = t => {
                    t.target === e.domElement && this.move(t, e)
                  }),
                  (document.onmouseup = t => {
                    this.up(e)
                  }))
          }
          move(t, e) {
            const { domElement: n, maxRadius: i, maxRadiusSquared: r, origin: s, offset: o, id: a } = e
            t = t || window.event
            const l = this.getMousePosition(t)
            let c = l.x - o.x,
              h = l.y - o.y
            const u = c * c + h * h
            if (u > r) {
              const t = Math.sqrt(u)
              ;(c /= t), (h /= t), (c *= i), (h *= i)
            }
            ;(n.style.top = `${h + n.clientHeight / 2}px`), (n.style.left = `${c + n.clientWidth / 2}px`)
            const d = -(h - s.top + n.clientHeight / 2) / i,
              p = (c - s.left + n.clientWidth / 2) / i
            this.emit(`axis_onmove_${a}`, { top: d, right: p })
          }
          up(t) {
            const { domElement: e, origin: n, id: i } = t
            'ontouchstart' in window
              ? ((document.ontouchmove = null), (document.touchend = null))
              : ((document.onmousemove = null), (document.onmouseup = null)),
              (e.style.top = `${n.top}px`),
              (e.style.left = `${n.left}px`),
              this.emit(`axis_onmove_${i}`, { top: 0, right: 0 })
          }
          getMousePosition(t) {
            return {
              x: t.targetTouches ? t.targetTouches[0].pageX : t.clientX,
              y: t.targetTouches ? t.targetTouches[0].pageY : t.clientY
            }
          }
        }
        class Ex {
          constructor(t, e, n) {
            ;(this.camera = t), (this.target = e), (this.config = n)
            const {
              offset: i = new ei(0, 0, 0),
              sensitivity: r = new Wn(1, 1),
              radius: s = 8,
              targetRadius: o = 10,
              interpolationFactor: a = 0.05,
              pointerLock: l = !0,
              autoUpdate: c = !0,
              theta: h = 0,
              phi: u = 0,
              maxPhi: d = 85,
              minPhi: p = -85
            } = n
            ;(this.offset = i),
              (this.sensitivity = r),
              (this.radius = s),
              (this.targetRadius = o),
              (this.interpolationFactor = a),
              (this.theta = h),
              (this.phi = u),
              (this.maxPhi = d),
              (this.minPhi = p)
          }
          update(t, e) {
            const n = this.target.position.clone().add(this.offset)
            ;(this.theta -= t * (this.sensitivity.x / 2)),
              (this.theta %= 360),
              (this.phi += e * (this.sensitivity.y / 2)),
              (this.phi = Math.min(this.maxPhi, Math.max(this.minPhi, this.phi))),
              (this.radius = Vn.lerp(this.radius, this.targetRadius, this.interpolationFactor)),
              (this.camera.position.x =
                n.x + this.radius * Math.sin((this.theta * Math.PI) / 180) * Math.cos((this.phi * Math.PI) / 180)),
              (this.camera.position.y = n.y + this.radius * Math.sin((this.phi * Math.PI) / 180)),
              (this.camera.position.z =
                n.z + this.radius * Math.cos((this.theta * Math.PI) / 180) * Math.cos((this.phi * Math.PI) / 180)),
              this.camera.updateMatrix(),
              this.camera.lookAt(n)
          }
        }
        class Ax {
          constructor(t, e, n) {
            ;(this.camera = t), (this.target = e), (this.config = n)
            const {
              offset: i = new ei(0, 0, 0),
              sensitivity: r = new Wn(1, 1),
              radius: s = 8,
              targetRadius: o = 10,
              interpolationFactor: a = 0.05,
              pointerLock: l = !0,
              autoUpdate: c = !0
            } = n
            ;(this.offset = i),
              (this.sensitivity = r),
              (this.radius = s),
              (this.targetRadius = o),
              (this.interpolationFactor = a),
              (this.theta = 0),
              (this.phi = 0)
          }
          update(t, e) {
            const n = this.target.position.clone().add(this.offset)
            this.camera.position.copy(n),
              (this.theta -= t * (this.sensitivity.x / 2)),
              (this.theta %= 360),
              (this.phi += e * (-this.sensitivity.y / 2)),
              (this.phi = Math.min(85, Math.max(-85, this.phi)))
            const i = new ei()
            ;(i.x = n.x + this.radius * Math.sin((this.theta * Math.PI) / 180) * Math.cos((this.phi * Math.PI) / 180)),
              (i.y = n.y + this.radius * Math.sin((this.phi * Math.PI) / 180)),
              (i.z = n.z + this.radius * Math.cos((this.theta * Math.PI) / 180) * Math.cos((this.phi * Math.PI) / 180)),
              this.camera.updateMatrix(),
              this.camera.lookAt(i)
          }
        }
        class Lx {
          constructor(t, e = !0) {
            ;(this._element = t), (this._isRunning = !1), e && this.request()
          }
          isLocked() {
            return !!document.pointerLockElement
          }
          exit() {
            ;(this._isRunning = !1), document.exitPointerLock(), this.removeListeners()
          }
          removeListeners() {
            document.removeEventListener('pointerlockchange', () => this.pointerLockChangeHandler()),
              this._element.removeEventListener('pointerdown', () => this.pointerDownHandlerHandler())
          }
          pointerLockChangeHandler() {
            this._isRunning && this._request()
          }
          pointerDownHandlerHandler() {
            this._isRunning && this._element.requestPointerLock()
          }
          request() {
            ;(this._isRunning = !0), this._request()
          }
          _request() {
            document.addEventListener('pointerlockchange', () => this.pointerLockChangeHandler(), { once: !0 }),
              document.pointerLockElement ||
                this._element.addEventListener('pointerdown', () => this.pointerDownHandlerHandler(), { once: !0 })
          }
        }
        class Rx {
          constructor(t, e = !0) {
            ;(this._element = t),
              (this._isRunning = !1),
              (this._position = { x: 0, y: 0 }),
              (this._delta = { x: 0, y: 0 }),
              (this._onMoveCallback = () => {}),
              (this._isPointerDown = !1),
              e && this.start()
          }
          get isTouchDevice() {
            return 'ontouchstart' in window
          }
          get isPointerDown() {
            return this._isPointerDown
          }
          start() {
            this._isRunning ||
              ((this._isRunning = !0),
              this.isTouchDevice
                ? (this._element.addEventListener('touchstart', t => this.onTouchStart(t)),
                  this._element.addEventListener('touchend', t => this.onTouchEnd(t)),
                  this._element.addEventListener('touchmove', t => this.onTouchMove(t)))
                : (this._element.addEventListener('mousedown', t => this.onPointerDown(t)),
                  this._element.addEventListener('mouseup', t => this.onPointerUp(t)),
                  this._element.addEventListener('mouseleave', t => this.onPointerLeave(t)),
                  this._element.addEventListener('mouseover', t => this.onPointerOver(t)),
                  this._element.addEventListener('mousemove', t => this.onPointerMove(t))))
          }
          stop() {
            this.isTouchDevice
              ? (this._element.removeEventListener('touchstart', t => this.onTouchStart(t)),
                this._element.removeEventListener('touchend', t => this.onTouchEnd(t)),
                this._element.removeEventListener('touchmove', t => this.onTouchMove(t)))
              : (this._element.removeEventListener('mousedown', t => this.onPointerDown(t)),
                this._element.removeEventListener('mouseleave', t => this.onPointerLeave(t)),
                this._element.removeEventListener('mouseup', t => this.onPointerUp(t)),
                this._element.removeEventListener('mouseover', t => this.onPointerOver(t)),
                this._element.removeEventListener('mousemove', t => this.onPointerMove(t))),
              (this._isRunning = !1)
          }
          removeListeners() {
            this.stop()
          }
          onMove(t) {
            this._onMoveCallback = t
          }
          onPointerDown(t) {
            this._isPointerDown = !0
          }
          onPointerUp(t) {
            this._isPointerDown = !1
          }
          onPointerLeave(t) {
            this._isPointerDown = !1
          }
          onPointerMove(t) {
            const e = t.movementX,
              n = t.movementY
            ;(this._delta = { x: e, y: n }), this._onMoveCallback(this._delta)
          }
          onPointerOver(t) {}
          onTouchStart(t) {
            const e = t.touches[0].clientX,
              n = t.touches[0].clientY
            this._position = { x: e, y: n }
          }
          onTouchEnd(t) {
            ;(this._position = { x: 0, y: 0 }), (this._delta = { x: 0, y: 0 }), this._onMoveCallback(this._delta)
          }
          onTouchMove(t) {
            const e = t.touches[0].clientX,
              n = t.touches[0].clientY
            ;(this._delta = { x: e - this._position.x, y: n - this._position.y }),
              this._onMoveCallback(this._delta),
              (this._position = { x: e, y: n })
          }
        }
        var Px = {
          uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
          vertexShader: [
            'varying vec2 vUv;',
            'void main() {',
            '\tvUv = uv;',
            '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
            '}'
          ].join('\n'),
          fragmentShader: [
            'uniform float opacity;',
            'uniform sampler2D tDiffuse;',
            'varying vec2 vUv;',
            'void main() {',
            '\tvec4 texel = texture2D( tDiffuse, vUv );',
            '\tgl_FragColor = opacity * texel;',
            '}'
          ].join('\n')
        }
        function Cx() {
          ;(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1)
        }
        Object.assign(Cx.prototype, {
          setSize: function () {},
          render: function () {
            console.error('THREE.Pass: .render() must be implemented in derived pass.')
          }
        }),
          (Cx.FullScreenQuad = (function () {
            var t = new _u(-1, 1, 1, -1, 0, 1),
              e = new Qr()
            e.setAttribute('position', new Ur([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
              e.setAttribute('uv', new Ur([0, 2, 0, 0, 2, 0], 2))
            var n = function (t) {
              this._mesh = new gs(e, t)
            }
            return (
              Object.defineProperty(n.prototype, 'material', {
                get: function () {
                  return this._mesh.material
                },
                set: function (t) {
                  this._mesh.material = t
                }
              }),
              Object.assign(n.prototype, {
                dispose: function () {
                  this._mesh.geometry.dispose()
                },
                render: function (e) {
                  e.render(this._mesh, t)
                }
              }),
              n
            )
          })())
        var Ix = function (t, e) {
          Cx.call(this),
            (this.textureID = void 0 !== e ? e : 'tDiffuse'),
            t instanceof _s
              ? ((this.uniforms = t.uniforms), (this.material = t))
              : t &&
                ((this.uniforms = ws.clone(t.uniforms)),
                (this.material = new _s({
                  defines: Object.assign({}, t.defines),
                  uniforms: this.uniforms,
                  vertexShader: t.vertexShader,
                  fragmentShader: t.fragmentShader
                }))),
            (this.fsQuad = new Cx.FullScreenQuad(this.material))
        }
        Ix.prototype = Object.assign(Object.create(Cx.prototype), {
          constructor: Ix,
          render: function (t, e, n) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
              (this.fsQuad.material = this.material),
              this.renderToScreen
                ? (t.setRenderTarget(null), this.fsQuad.render(t))
                : (t.setRenderTarget(e),
                  this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                  this.fsQuad.render(t))
          }
        })
        var Dx = function (t, e) {
          Cx.call(this),
            (this.scene = t),
            (this.camera = e),
            (this.clear = !0),
            (this.needsSwap = !1),
            (this.inverse = !1)
        }
        Dx.prototype = Object.assign(Object.create(Cx.prototype), {
          constructor: Dx,
          render: function (t, e, n) {
            var i,
              r,
              s = t.getContext(),
              o = t.state
            o.buffers.color.setMask(!1),
              o.buffers.depth.setMask(!1),
              o.buffers.color.setLocked(!0),
              o.buffers.depth.setLocked(!0),
              this.inverse ? ((i = 0), (r = 1)) : ((i = 1), (r = 0)),
              o.buffers.stencil.setTest(!0),
              o.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
              o.buffers.stencil.setFunc(s.ALWAYS, i, 4294967295),
              o.buffers.stencil.setClear(r),
              o.buffers.stencil.setLocked(!0),
              t.setRenderTarget(n),
              this.clear && t.clear(),
              t.render(this.scene, this.camera),
              t.setRenderTarget(e),
              this.clear && t.clear(),
              t.render(this.scene, this.camera),
              o.buffers.color.setLocked(!1),
              o.buffers.depth.setLocked(!1),
              o.buffers.stencil.setLocked(!1),
              o.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295),
              o.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
              o.buffers.stencil.setLocked(!0)
          }
        })
        var Ox = function () {
          Cx.call(this), (this.needsSwap = !1)
        }
        ;(Ox.prototype = Object.create(Cx.prototype)),
          Object.assign(Ox.prototype, {
            render: function (t) {
              t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
          })
        var Nx = function (t, e) {
          if (((this.renderer = t), void 0 === e)) {
            var n = { minFilter: Mt, magFilter: Mt, format: Gt },
              i = t.getSize(new Wn())
            ;(this._pixelRatio = t.getPixelRatio()),
              (this._width = i.width),
              (this._height = i.height),
              ((e = new Qn(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name =
                'EffectComposer.rt1')
          } else (this._pixelRatio = 1), (this._width = e.width), (this._height = e.height)
          ;(this.renderTarget1 = e),
            (this.renderTarget2 = e.clone()),
            (this.renderTarget2.texture.name = 'EffectComposer.rt2'),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2),
            (this.renderToScreen = !0),
            (this.passes = []),
            void 0 === Px && console.error('THREE.EffectComposer relies on CopyShader'),
            void 0 === Ix && console.error('THREE.EffectComposer relies on ShaderPass'),
            (this.copyPass = new Ix(Px)),
            (this.clock = new Ku())
        }
        Object.assign(Nx.prototype, {
          swapBuffers: function () {
            var t = this.readBuffer
            ;(this.readBuffer = this.writeBuffer), (this.writeBuffer = t)
          },
          addPass: function (t) {
            this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
          },
          insertPass: function (t, e) {
            this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
          },
          removePass: function (t) {
            const e = this.passes.indexOf(t)
            ;-1 !== e && this.passes.splice(e, 1)
          },
          isLastEnabledPass: function (t) {
            for (var e = t + 1; e < this.passes.length; e++) if (this.passes[e].enabled) return !1
            return !0
          },
          render: function (t) {
            void 0 === t && (t = this.clock.getDelta())
            var e,
              n,
              i = this.renderer.getRenderTarget(),
              r = !1,
              s = this.passes.length
            for (n = 0; n < s; n++)
              if (!1 !== (e = this.passes[n]).enabled) {
                if (
                  ((e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n)),
                  e.render(this.renderer, this.writeBuffer, this.readBuffer, t, r),
                  e.needsSwap)
                ) {
                  if (r) {
                    var o = this.renderer.getContext(),
                      a = this.renderer.state.buffers.stencil
                    a.setFunc(o.NOTEQUAL, 1, 4294967295),
                      this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
                      a.setFunc(o.EQUAL, 1, 4294967295)
                  }
                  this.swapBuffers()
                }
                void 0 !== Dx && (e instanceof Dx ? (r = !0) : e instanceof Ox && (r = !1))
              }
            this.renderer.setRenderTarget(i)
          },
          reset: function (t) {
            if (void 0 === t) {
              var e = this.renderer.getSize(new Wn())
              ;(this._pixelRatio = this.renderer.getPixelRatio()),
                (this._width = e.width),
                (this._height = e.height),
                (t = this.renderTarget1.clone()).setSize(
                  this._width * this._pixelRatio,
                  this._height * this._pixelRatio
                )
            }
            this.renderTarget1.dispose(),
              this.renderTarget2.dispose(),
              (this.renderTarget1 = t),
              (this.renderTarget2 = t.clone()),
              (this.writeBuffer = this.renderTarget1),
              (this.readBuffer = this.renderTarget2)
          },
          setSize: function (t, e) {
            ;(this._width = t), (this._height = e)
            var n = this._width * this._pixelRatio,
              i = this._height * this._pixelRatio
            this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i)
            for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
          },
          setPixelRatio: function (t) {
            ;(this._pixelRatio = t), this.setSize(this._width, this._height)
          }
        })
        var Bx = function () {
          ;(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1)
        }
        Object.assign(Bx.prototype, {
          setSize: function () {},
          render: function () {
            console.error('THREE.Pass: .render() must be implemented in derived pass.')
          }
        }),
          (Bx.FullScreenQuad = (function () {
            var t = new _u(-1, 1, 1, -1, 0, 1),
              e = new Qr()
            e.setAttribute('position', new Ur([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
              e.setAttribute('uv', new Ur([0, 2, 0, 0, 2, 0], 2))
            var n = function (t) {
              this._mesh = new gs(e, t)
            }
            return (
              Object.defineProperty(n.prototype, 'material', {
                get: function () {
                  return this._mesh.material
                },
                set: function (t) {
                  this._mesh.material = t
                }
              }),
              Object.assign(n.prototype, {
                dispose: function () {
                  this._mesh.geometry.dispose()
                },
                render: function (e) {
                  e.render(this._mesh, t)
                }
              }),
              n
            )
          })())
        var Fx = function (t, e, n, i, r) {
          Cx.call(this),
            (this.scene = t),
            (this.camera = e),
            (this.overrideMaterial = n),
            (this.clearColor = i),
            (this.clearAlpha = void 0 !== r ? r : 0),
            (this.clear = !0),
            (this.clearDepth = !1),
            (this.needsSwap = !1),
            (this._oldClearColor = new Ar())
        }
        Fx.prototype = Object.assign(Object.create(Cx.prototype), {
          constructor: Fx,
          render: function (t, e, n) {
            var i,
              r,
              s = t.autoClear
            ;(t.autoClear = !1),
              void 0 !== this.overrideMaterial &&
                ((r = this.scene.overrideMaterial), (this.scene.overrideMaterial = this.overrideMaterial)),
              this.clearColor &&
                (t.getClearColor(this._oldClearColor),
                (i = t.getClearAlpha()),
                t.setClearColor(this.clearColor, this.clearAlpha)),
              this.clearDepth && t.clearDepth(),
              t.setRenderTarget(this.renderToScreen ? null : n),
              this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              t.render(this.scene, this.camera),
              this.clearColor && t.setClearColor(this._oldClearColor, i),
              void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = r),
              (t.autoClear = s)
          }
        })
        var zx = {
            uniforms: {
              tDiffuse: { value: null },
              tDisp: { value: null },
              byp: { value: 0 },
              amount: { value: 0.08 },
              angle: { value: 0.02 },
              seed: { value: 0.02 },
              seed_x: { value: 0.02 },
              seed_y: { value: 0.02 },
              distortion_x: { value: 0.5 },
              distortion_y: { value: 0.6 },
              col_s: { value: 0.05 }
            },
            vertexShader: [
              'varying vec2 vUv;',
              'void main() {',
              '\tvUv = uv;',
              '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
              '}'
            ].join('\n'),
            fragmentShader: [
              'uniform int byp;',
              'uniform sampler2D tDiffuse;',
              'uniform sampler2D tDisp;',
              'uniform float amount;',
              'uniform float angle;',
              'uniform float seed;',
              'uniform float seed_x;',
              'uniform float seed_y;',
              'uniform float distortion_x;',
              'uniform float distortion_y;',
              'uniform float col_s;',
              'varying vec2 vUv;',
              'float rand(vec2 co){',
              '\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
              '}',
              'void main() {',
              '\tif(byp<1) {',
              '\t\tvec2 p = vUv;',
              '\t\tfloat xs = floor(gl_FragCoord.x / 0.5);',
              '\t\tfloat ys = floor(gl_FragCoord.y / 0.5);',
              '\t\tvec4 normal = texture2D (tDisp, p*seed*seed);',
              '\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {',
              '\t\t\tif(seed_x>0.){',
              '\t\t\t\tp.y = 1. - (p.y + distortion_y);',
              '\t\t\t}',
              '\t\t\telse {',
              '\t\t\t\tp.y = distortion_y;',
              '\t\t\t}',
              '\t\t}',
              '\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {',
              '\t\t\tif(seed_y>0.){',
              '\t\t\t\tp.x=distortion_x;',
              '\t\t\t}',
              '\t\t\telse {',
              '\t\t\t\tp.x = 1. - (p.x + distortion_x);',
              '\t\t\t}',
              '\t\t}',
              '\t\tp.x+=normal.x*seed_x*(seed/5.);',
              '\t\tp.y+=normal.y*seed_y*(seed/5.);',
              '\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));',
              '\t\tvec4 cr = texture2D(tDiffuse, p + offset);',
              '\t\tvec4 cga = texture2D(tDiffuse, p);',
              '\t\tvec4 cb = texture2D(tDiffuse, p - offset);',
              '\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);',
              '\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);',
              '\t\tgl_FragColor = gl_FragColor+ snow;',
              '\t}',
              '\telse {',
              '\t\tgl_FragColor=texture2D (tDiffuse, vUv);',
              '\t}',
              '}'
            ].join('\n')
          },
          kx = function (t) {
            Cx.call(this), void 0 === zx && console.error('THREE.GlitchPass relies on DigitalGlitch')
            var e = zx
            ;(this.uniforms = ws.clone(e.uniforms)),
              null == t && (t = 64),
              (this.uniforms.tDisp.value = this.generateHeightmap(t)),
              (this.material = new _s({
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
              })),
              (this.fsQuad = new Cx.FullScreenQuad(this.material)),
              (this.goWild = !1),
              (this.curF = 0),
              this.generateTrigger()
          }
        kx.prototype = Object.assign(Object.create(Cx.prototype), {
          constructor: kx,
          render: function (t, e, n) {
            ;(this.uniforms.tDiffuse.value = n.texture),
              (this.uniforms.seed.value = Math.random()),
              (this.uniforms.byp.value = 0),
              this.curF % this.randX == 0 || 1 == this.goWild
                ? ((this.uniforms.amount.value = Math.random() / 30),
                  (this.uniforms.angle.value = Vn.randFloat(-Math.PI, Math.PI)),
                  (this.uniforms.seed_x.value = Vn.randFloat(-1, 1)),
                  (this.uniforms.seed_y.value = Vn.randFloat(-1, 1)),
                  (this.uniforms.distortion_x.value = Vn.randFloat(0, 1)),
                  (this.uniforms.distortion_y.value = Vn.randFloat(0, 1)),
                  (this.curF = 0),
                  this.generateTrigger())
                : this.curF % this.randX < this.randX / 5
                ? ((this.uniforms.amount.value = Math.random() / 90),
                  (this.uniforms.angle.value = Vn.randFloat(-Math.PI, Math.PI)),
                  (this.uniforms.distortion_x.value = Vn.randFloat(0, 1)),
                  (this.uniforms.distortion_y.value = Vn.randFloat(0, 1)),
                  (this.uniforms.seed_x.value = Vn.randFloat(-0.3, 0.3)),
                  (this.uniforms.seed_y.value = Vn.randFloat(-0.3, 0.3)))
                : 0 == this.goWild && (this.uniforms.byp.value = 1),
              this.curF++,
              this.renderToScreen
                ? (t.setRenderTarget(null), this.fsQuad.render(t))
                : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t))
          },
          generateTrigger: function () {
            this.randX = Vn.randInt(120, 240)
          },
          generateHeightmap: function (t) {
            for (var e = new Float32Array(t * t * 3), n = t * t, i = 0; i < n; i++) {
              var r = Vn.randFloat(0, 1)
              ;(e[3 * i + 0] = r), (e[3 * i + 1] = r), (e[3 * i + 2] = r)
            }
            return new Rs(e, t, t, Ht, Ot)
          }
        })
        var Ux = {
          uniforms: {
            tDiffuse: { value: null },
            tSize: { value: new Wn(256, 256) },
            center: { value: new Wn(0.5, 0.5) },
            angle: { value: 1.57 },
            scale: { value: 1 }
          },
          vertexShader: [
            'varying vec2 vUv;',
            'void main() {',
            '\tvUv = uv;',
            '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
            '}'
          ].join('\n'),
          fragmentShader: [
            'uniform vec2 center;',
            'uniform float angle;',
            'uniform float scale;',
            'uniform vec2 tSize;',
            'uniform sampler2D tDiffuse;',
            'varying vec2 vUv;',
            'float pattern() {',
            '\tfloat s = sin( angle ), c = cos( angle );',
            '\tvec2 tex = vUv * tSize - center;',
            '\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;',
            '\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;',
            '}',
            'void main() {',
            '\tvec4 color = texture2D( tDiffuse, vUv );',
            '\tfloat average = ( color.r + color.g + color.b ) / 3.0;',
            '\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );',
            '}'
          ].join('\n')
        }
      })(),
      s
    )
  })()
})
//# sourceMappingURL=enable3d.phaserExtension.0.22.0.min.js.map
